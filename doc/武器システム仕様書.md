# 武器システム仕様書

## 概要

武器はキャラクターの戦闘スタイル全体を決定する中核要素。
装備した武器によって戦闘規格・ステータスボーナス・使用可能スキルが変わる。

---

## 武器とは何か — 設計思想

**武器は「味方（操作キャラ）専用の着脱可能なラッピング層」である。**

武器の中身を分解すると、すべて既存の概念のパッケージングに過ぎない:

| 武器の構成要素 | 本質 |
|--------------|------|
| WeaponSkill | ただの BaseSkill |
| TenDayBonusData | ただの十日能力値加算 |
| protocols | ただの戦闘規格の選択肢 |
| CombinationEntries | ただのスキル差し替えテーブル |
| WeaponPhysical | ただの物理属性 |
| IsBlade | ただのフラグ |

敵が「剣で斬る」動作をする場合、そのスキル自体に威力・属性・物理特性がすべて含まれているし、敵のステータス値にはボーナス相当分が最初から織り込まれている。敵は「武器」という概念を経由する必要がない。

### なぜ武器システムが存在するか

**「プレイヤーが取り替えるから」の一点に尽きる。**

味方キャラクターは操作される存在であり、プレイヤーが戦略的に装備を選択・変更する。この「取り替え可能性」こそが武器システムの存在理由であり、そこから派生するすべての仕組み（適応ラグ、規格サイクル、武器選択UI、能力値チェック、掛け合わせ）は「操作する人間がいる」ことを前提としている。

```
敵キャラクター:
  スキル = 直接定義（威力・属性・物理特性すべて込み）
  ステータス = 直接定義（ボーナス込みの最終値）
  → 武器という中間層は不要

味方キャラクター:
  スキル = 武器が提供（WeaponSkill / CombinationEntries）
  ステータス = 素の値 + 武器ボーナス（TenDayBonusData）
  戦闘規格 = 武器が決定（protocols）
  → 「取り替え」のために武器という中間層が必要
```

武器システムとは、プレイヤーの戦略的選択を可能にするためのインターフェース層である。

---

## データモデル

### BaseWeapon (`Assets/Script/BaseWeapon.cs`)

| フィールド | 型 | 説明 |
|-----------|-----|------|
| `id` | `int` | 武器ID（WeaponManagerのマスターリスト内で一意） |
| `name` | `string` | 武器名（UI表示用） |
| `protocols` | `List<BattleProtocol>` | この武器で使用可能な戦闘規格（複数設定可能） |
| `protocol` | `BattleProtocol`（getterのみ） | 後方互換: `protocols[0]` を返す |
| `HasMultipleProtocols` | `bool`（getterのみ） | `protocols.Count > 1` |
| `WeaponSkill` | `BaseSkill` | 武器専用スキル |
| `TenDayBonusData` | `WeaponTenDayAbilityBonusData` | 十日能力ボーナス（スキル特判別） |
| `TenDayValues` | `SerializableDictionary<TenDayAbility, float>` | 装備に必要な十日能力値 |
| `SlashColor` | `Color` | 武器スラッシュアニメーションの色（デフォルト: 白） |
| `IsBlade` | `bool` | 刃物武器かどうか |

### WeaponTenDayAbilityBonusData

武器が十日能力に与えるボーナス。スキルの特殊判別性質に応じて4種のデータを持つ。

| データ | 適用条件 |
|--------|---------|
| `NormalData` | 常時適用（スキル不問） |
| `BladeData` | 使用スキルが `IsBlade` の時のみ加算 |
| `MagicData` | 使用スキルが `IsMagic` の時のみ加算 |
| `TLOAData` | 使用スキルが `IsTLOA` の時のみ加算 |

`GetTenDayAbilityDictionary(isBlade, isMagic, isTLOA)` で NormalData に該当データを加算して返す。

### WeaponManager (`Assets/Script/Weapon/WeaponManager.cs`)

- シングルトン（`DontDestroyOnLoad`）
- `_masterList` に通常武器を `[SerializeReference]` で保持
- `_freehandWeapon` にフリーハンド武器を別枠で保持（リストとは分離）
- `GetAtID(int id)` でID指定取得（フリーハンドも含む）
- `GetFreehandWeapon()` でフリーハンド武器を取得
- `AllWeapons` は全武器を返す（フリーハンド含む、キャッシュ付き）

---

## 武器の装備

### 装備処理 (`BaseStates.WeaponManager.cs`)

```
ApplyWeapon(int ID)
  → NowUseWeapon = WeaponManager.Instance.GetAtID(ID)
  → NowBattleProtocol = NowUseWeapon.protocol  // protocols[0]
  → 武器変更時: 適応率99%の名目ラグを適用（UIの一貫性のため）
```

- キャラクターは `InitWeaponID` をインスペクタで設定
- 初期化時に `ApplyWeapon(InitWeaponID)` が呼ばれる
- `NowUseWeapon` は `[NonSerialized]` でランタイム専用
- 武器スキル・掛け合わせスキルの初期化もここで行われる

### 必要能力値

- `BaseWeapon.TenDayValues` フィールドにデータ構造は**存在する**
- **装備時の能力値チェックロジックは未実装**
- 現状: 能力値が足りなくても装備できてしまう

---

## 戦闘規格 (BattleProtocol)

武器の `protocol` フィールドで決まる。戦闘全体のスタイルを支配する。

### 列挙値

| 値 | 表示 | 意味 |
|----|------|------|
| `LowKey` | 地味 | 堅実型。デフォルト防御: AcrobatMinor |
| `Tricky` | トライキー | 変則型。デフォルト防御: Duster |
| `Showey` | 派手 | 攻撃型。デフォルト防御: CentralHeavenStrike |
| `none` | なし | フリーハンドのデフォルト規格。狙い流れ・排他ATK/DEFなし |

### 戦闘規格が影響するもの

**1. 攻撃力 (ATK)**

`AttackPowerConfig` (`Assets/Script/Config/AttackPowerConfig.cs`) にて定義。

- 共通ATK係数: 全規格で適用される十日能力→ATK変換
- 排他ATK係数: 規格ごとに固有の十日能力→ATK変換が追加
  - LowKey: Taraiton(0.9), SpringWater(1.7), HumanKiller(1.0), UnextinguishedPath(0.3)
  - Tricky: Miza(1.2), PersonaDivergence(0.8), Vond(0.7), Enokunagi(0.5), Rain(0.6)
  - Showey: Vail(1.11), WaterThunderNerve(0.2), HumanKiller(1.0)
  - none: 排他ATK係数なし（追加攻撃力がない）

**2. 防御力 (DEF) — AimStyle経由**

`DefensePowerConfig` (`Assets/Script/Config/DefensePowerConfig.cs`) にて定義。

- 戦闘規格 → デフォルト防御スタイル(AimStyle) → 排他DEF係数
- AimStyle 6種: CentralHeavenStrike, AcrobatMinor, Doublet, QuadStrike, Duster, PotanuVolf
- `SwitchDefenceStyle` で攻撃者の規格に応じて防ぎ方が切り替わる
- none攻撃を受けた場合 → `AimStyle.none` が強制 → 排他DEF係数なし（防御力低下）

**3. デフォルト防御パターン**

`DefaultDefensePatternPerProtocol` 辞書で、各規格に対するデフォルト防御AimStyleとしきい値が定義されている。

---

## 武器とスキルの関係

### スキル特殊判別性質 (SkillSpecialFlag)

スキルは3つのフラグを持てる（`BaseSkill.Core.cs`）:

| フラグ | プロパティ | 意味 |
|--------|-----------|------|
| `TLOA` | `IsTLOA` | TLOAスキル |
| `Magic` | `IsMagic` | 魔法スキル |
| `Blade` | `IsBlade` | 刃物スキル |

### 刃物武器チェック（スキル使用制限）

`SkillResourceFlow.CanCastSkill()` で判定:

```
IsBlade スキル → 刃物武器(IsBlade=true)装備が必須
非Blade スキル → 武器に関係なく使用可能
```

AI (`BattleAIBrain`) もスキル選択時にこの判定を使用。

### 武器ボーナスの適用タイミング — TenDayValues参照の使い分け

十日能力の参照には2つのメソッドがある（`BaseStates.StatesNumber.cs`）:

| メソッド | 返す値 | 用途 |
|---------|--------|------|
| `TenDayValuesBase()` | `_baseTenDayValues` + 武器 `NormalData` のみ | 素の能力値。パッシブ効果、防御側の値、UI表示、強さ比較など |
| `TenDayValuesForSkill()` | `_baseTenDayValues` + 武器 `NormalData` + スキル特判ボーナス | スキル実行中の攻撃側の値。ATK/ダメージ計算など |

#### ForSkill() の内部動作

`NowUseSkill` を参照し、スキルの `IsBlade/IsMagic/IsTLOA` フラグに応じて武器の `BladeData/MagicData/TLOAData` を加算する。`NowUseSkill` が null の場合（戦闘外・ターン外）は `NormalData` のみとなり、`Base()` と同じ結果になる。

#### 使い分けの原則

```
攻撃者がスキルを行使する文脈 → ForSkill()
  例: ATK計算、スキル威力計算、精神ATKブースト

それ以外の全て → Base()
  例: 防御者の値、パッシブ効果、パーティ強さ比較、
      UI表示、十日能力の成長/消費、ランダム能力選択
```

この区別は「武器のスキル特判ボーナスは、そのスキルを使っている本人にしか意味がない」という設計に基づく。防御者やパッシブが攻撃者の武器特判ボーナスを参照することはない。

#### 戦闘終了時の挙動

- `NowUseSkill = null` に設定（`BaseStates.CallBack.cs:196`）
- これにより戦闘後は `ForSkill()` も `NormalData` のみとなる

### 精神補正への影響

`ComputeSkillPowers()` (`BaseStates.ReactionSkill.cs:21-31`) での計算:

| 条件 | 精神補正の適用率 |
|------|----------------|
| 通常スキル | 20% |
| TLOAスキル | 40% |
| **刃物武器装備時** | **0%（1.0固定、精神補正完全無効）** |
| 精神HPへのダメージ | 100%（武器に関係なく常にフル） |
| ライバハル | 100%（武器に関係なく常にフル） |

刃物武器のトレードオフ: 精神属性の相性に左右されない安定ダメージを得る代わりに、精神相性が有利な場合のボーナスも消える。

### 即死刃物クリティカル

`BladeCriticalCalculation()` (`BaseStates.Damage.cs`) で実装済み。

**発生条件**:
1. スキルが `IsBlade`
2. 追加HPを抜けた後に本体へのダメージが残っている
3. 被害者のHPがダメージより多い（まだ死なない状態）

**計算**:
1. しきい値判定: `min(攻撃者Blades/150, 1) × (5/12)` のパーセントで発生チェック
2. 発生率: `攻撃者Blades / 被害者十日能力総量` のパーセントで最終判定
3. 成功時: 残りHP分のダメージが加算 → 即死

**生存チャンス**: `CalculateBladeDeathCriticalSurvivalChance()` で被害者のパワーやBlades値に基づく耐え判定あり。

---

## フリーハンド（無装備状態）

### 仕様

- 武器を装備していない状態 = `フリーハンド` というBaseWeaponを強制装備
- 武器スキル: 「掴んで投げる」（スキル命中率15%）
- **全戦闘規格を使用可能**: `protocols` に `[LowKey, Tricky, Showey, none]` を設定可能
- デフォルト規格: `none`（`protocols[0]`）
- WeaponManagerの `_freehandWeapon` フィールドに別枠で保持（`_masterList` には含まない）

### none戦闘規格の影響

- 狙い流れ(AimStyle)がない → 攻撃側の排他ATK係数なし
- 防ぎ方がない → 防御側は `AimStyle.none` → 排他DEF係数なし（共通防御力のみ）
- 掴んで投げるを食らった側は一時的に無防備状態になる（次のAimStyleがnone固定化）
- TLOAスキルの「ゆりかご」計算でフリーハンドは有利になる（**実装済み** — フリーハンド感情転換: `lerp(mood, |mood|, 0.75)`）

### フリーハンドからの規格切替

- フリーハンドは複数規格を持つため、規格サイクルボタンで切替可能
- フリーハンド→他規格への切替時: 適応率 **90〜100% ランダム**スタート
- 通常の規格切替（77〜100%）より軽いペナルティ

### 実装状況

- `SwitchDefenceStyle` で `BattleProtocol.none` → `AimStyle.none` の処理: **実装済み**
- フリーハンドBaseWeaponデータ: WeaponManagerの `_freehandWeapon` フィールドで管理: **実装済み**
- 武器外し → フリーハンド自動切替: WeaponSelectAreaの「武器を外す」ボタンで `GetFreehandWeapon()` → `ApplyWeapon()`: **実装済み**

---

## 複数規格武器（実装済み）

通常の武器は1つの戦闘規格だが、一部の武器は複数の規格を選択可能。設計メモ（十日印象能力.md:185）にて構想。
`BaseWeapon.protocols` は `List<BattleProtocol>` であり、インスペクタから任意の数だけ設定できる。フリーハンドも同じリストで全規格を持つ。

### 複数規格武器の意義

通常の武器変更では武器スキル・十日能力ボーナス・物理属性など**すべてが入れ替わる**。
複数規格武器は「武器そのもののアドバンテージ（スキル、ボーナス、掛け合わせ等）を保持したまま、戦闘規格だけを切り替えられる」特殊な武器。

- 武器変更 = **プリセットの切替**（武器ごとのスキル・ボーナス・規格がまるごと入れ替わる）
- 規格変更 = **意識・技法の切替**（同じ武器の中で戦い方だけ変える）

この区別が適応ラグの設計根拠になっている。

### 実装状況

- `BaseWeapon.protocols` は `List<BattleProtocol>` で複数規格に対応済み
- `HasMultipleProtocols` プロパティで複数規格判定
- 後方互換の `protocol` getter（`protocols[0]`）で既存コード互換性を維持
- 規格サイクルボタン（`CharaconfigController.cs`）で切替UI実装済み

### 適応ラグ（実装済み）

複数規格武器で戦闘規格を切り替えた際に発生する**排他ATK係数の反映率ペナルティ**。設計メモでは複数規格武器の箇条書き内にのみ記述されており、**複数規格武器のサブ機能**として位置づけられる。

#### ラグの対象と条件

| 切替条件 | 適応率スタート | 回復 |
|---------|--------------|------|
| 同じ規格を継続 | 100% | — |
| 休憩ポイントで切替（規格・武器とも） | 100% | ペナルティなし |
| 規格A → 規格B（戦場） | **77〜100% ランダム**（平均88.5%） | 線形6戦で100%回復 |
| フリーハンド → 規格（戦場） | **90〜100% ランダム**（平均95%） | 線形6戦で100%回復 |
| 武器変更（戦場） | **99%** 固定（名目上。実質影響なし） | 1戦で100%回復 |
| 武器主六面の魂 | **常に100%** | 適応ラグ免除 |

**適応率が掛かる対象**: `AttackPowerConfig.GetExclusiveATK(protocol)` の排他ATK係数のみ。共通ATK係数・DEF・AGI・EYEには影響しない。

#### 回復カーブ

**線形、6戦で全回復。** ランダムスタートで平均が甘くなる分、回復を遅くして罰の重みを維持する。

計算式: `adaptationRate = min(1.0, startRate + battleCount × (1.0 - startRate) / 6)`

| 戦闘数 | 最悪(77%) | 平均(88.5%) | 幸運(95%) |
|--------|----------|------------|----------|
| 0（直後） | 77.0% | 88.5% | 95.0% |
| 1戦後 | 80.8% | 90.4% | 95.8% |
| 2戦後 | 84.7% | 92.3% | 96.7% |
| 3戦後 | 88.5% | 94.2% | 97.5% |
| 4戦後 | 92.3% | 96.2% | 98.3% |
| 5戦後 | 96.2% | 98.1% | 99.2% |
| 6戦後 | **100%** | **100%** | **100%** |

#### 適応ラグの設計判断の経緯

この仕様は以下の議論を経て決定された。結論だけでなく経緯を残すことで、将来の仕様変更時に「なぜこうなったか」を振り返れるようにする。

**Phase 1: ラグの本質 — 「判断ミスへの罰」**

適応ラグは「休憩地点で次の戦闘の傾向を読んで規格を選ぶ」という戦略ゲームにおいて、**読みが外れた時に戦場で慌てて切り替えるとしばらく弱くなる**という仕組み。プレイヤーの判断力を試すシステムであり、単純に「痛い」からこそ意味がある。

初期案として「慣れていない状態ではクリティカル率が上がる（ブレが生じる）」という補償メカニズムが検討されたが、以下の理由で棄却:
- クリティカル率上昇は**罰を帳消しにする**ギャンブル的インセンティブになり、慎重に規格を選ぶゲーム性を損なう
- このゲームは十日能力21種・AimStyle6種・排他係数と既に十分複雑であり、ラグ中のクリティカルスケーリングは不要な複雑性
- 単純に「攻撃力が下がる」だけならプレイヤーが直感的に理解できる

**Phase 2: 武器変更との関係 — 「ラグは複数規格武器のサブ機能」**

設計メモの構造を精査した結果、適応ラグの記述は**複数規格武器の箇条書き内にのみ**存在し、武器変更の文脈には一切記述がないことが判明。これにより適応ラグは複数規格武器のサブ機能として位置づけられた。

武器変更にラグを適用しない実質的理由:
1. **対価の非対称性**: 規格切替は「武器のアドバンテージを手放さずに規格だけ変える贅沢」→だからペナルティが要る。武器変更は「スキル・ボーナス・規格が全部変わる」→全取替自体がコスト
2. **武器収集の動機**: 武器変更にペナルティがあると「新しい武器を装備したくない」本末転倒が起きる
3. **武器主六面の魂の特別感**: 六面の魂が「常時100%」で特別なのは、複数規格武器にラグがあるからこそ。全武器にラグがあると価値が希薄化する

**Phase 3: UIの嘘 — 「名目上の99%」**

上記の結論（武器変更にラグなし）に対し、**プレイヤーの認知的一貫性**の観点から反論が出た:

> 規格変更にラグがあるのに武器変更に一切ないと、プレイヤーは「なぜ片方だけ？同じ戦場で同じように変えてるのに」と疑問を持つ。

これは数値設計の合理性ではなく、**プレイヤーが画面の前で何を感じるか**という認知体験の問題。解決策として「UIと世界観の辻褄合わせ」を目的とした**名目上の99%ラグ**を導入:

- **実質影響ゼロ**: 99%は1%のATK低下であり、ゲームバランスへの影響は無視できる
- **UIの一貫性**: 「適応中」表示が武器変更でも出ることで、「変更すると慣れが要る」ルールが全体に適用されていると認識できる
- **世界観の導線**: プレイヤーが「武器変更の方が軽いのはなぜ？」と気づく → 武器変更=道具（プリセット）の切替、規格変更=意識・技法の切替、という世界観の理解に自発的に至る
- **完成度の印象**: 機能的にはゼロでも、細部まで設計された微細な要素としてゲームへの信頼感を生む

#### 最終仕様まとめ

| 変更種別 | 適応率スタート | 回復 | 性質 |
|---------|--------------|------|------|
| 規格切替（戦場） | 77〜100% ランダム | 線形6戦 | 判断ミスへの罰。運の振れ幅が体験の多様性を生む |
| フリーハンド→規格（戦場） | 90〜100% ランダム | 線形6戦 | 素手からの規格移行。軽めのペナルティ |
| 武器変更（戦場） | 99% 固定 | 1戦 | UIの一貫性と世界観の辻褄合わせ（名目上） |
| 休憩地点での変更 | 100% | — | 安全な環境での戦略的選択 |
| 武器主六面の魂 | 常に100% | — | 特殊武器の特権 |

#### 実装詳細

休憩地点が未実装のため、休憩リセットは保留。それ以外（複数規格データモデル・適応ラグ・回復カーブ・UI）は実装済み。

**Step 1: データモデル変更 — `BaseWeapon.cs`（実装済み）**

```
// 変更前
public BattleProtocol protocol;

// 変更後
public List<BattleProtocol> protocols = new();
```

- 単一 `protocol` → 複数 `protocols` (List)
- 通常武器: `[LowKey]`、複数規格武器: `[LowKey, Showey]` 等、フリーハンド: `[LowKey, Tricky, Showey, none]` など、すべてインスペクタで自由に設定可能
- 後方互換: `protocol` プロパティ（get）を残し、`protocols[0]` を返す。既存コードの大半は変更不要
- `HasMultipleProtocols` プロパティ追加（`protocols.Count > 1`）

**Step 1.5: フリーハンドの分離 — `WeaponManager.cs`（実装済み）**

フリーハンドを `_masterList` から分離し、WeaponManagerに専用フィールドとして持つ:

```csharp
// 変更前
[SerializeReference] private List<BaseWeapon> _masterList;

// 変更後
[SerializeReference] private List<BaseWeapon> _masterList;
[SerializeReference] private BaseWeapon _freehandWeapon; // 別枠で明示的に設定
```

- インスペクタ上で「通常武器リスト」と「フリーハンド」が明確に分かれる
- `isFreehand` フラグは不要。データの構造自体がフリーハンドを表現する
- `GetAtID()` はフリーハンドのIDにも対応:

```csharp
public BaseWeapon GetAtID(int id)
{
    if (_freehandWeapon != null && _freehandWeapon.id == id)
        return _freehandWeapon;
    return _masterList.FirstOrDefault(weapon => weapon.id == id);
}

public BaseWeapon GetFreehandWeapon() => _freehandWeapon;
```

- `AllWeapons` にフリーハンドも含まれる（通常武器+フリーハンドの統合リスト）

**Step 2: 適応率フィールド — `BaseStates`（WeaponManager partial）（実装済み）**

```csharp
[NonSerialized] private float _adaptationRate = 1.0f;
[NonSerialized] private float _adaptationStartRate;    // ランダムで決まったスタート値
[NonSerialized] private int _battlesSinceProtocolSwitch; // 規格切替後のBM戦闘回数
public float AdaptationRate => _adaptationRate;
```

**Step 3: 規格切替API — `BaseStates`（WeaponManager partial）（実装済み）**

```csharp
public void SwitchProtocol(BattleProtocol newProtocol)
{
    if (NowBattleProtocol == newProtocol) return;

    // 適応率スタート値をランダム決定
    bool isFromFreehand = (NowUseWeapon == WeaponManager.Instance.GetFreehandWeapon());
    float minRate = isFromFreehand ? 0.90f : 0.77f;
    _adaptationStartRate = Random.Range(minRate, 1.0f);
    _adaptationRate = _adaptationStartRate;
    _battlesSinceProtocolSwitch = 0;

    NowBattleProtocol = newProtocol;
}
```

**Step 4: 武器変更時の名目ラグ — `ApplyWeapon()` 内（実装済み）**

```csharp
// 武器変更時: 99%固定の名目ラグ
_adaptationStartRate = 0.99f;
_adaptationRate = 0.99f;
_battlesSinceProtocolSwitch = 0;
```

**Step 5: 戦闘回数による回復 — 戦闘終了コールバック（実装済み）**

`BaseStates.CallBack.cs` の戦闘終了処理で呼び出す:

```csharp
public void RecoverAdaptation()
{
    if (_adaptationRate >= 1.0f) return;
    _battlesSinceProtocolSwitch++;
    _adaptationRate = Mathf.Min(1.0f,
        _adaptationStartRate + _battlesSinceProtocolSwitch * (1.0f - _adaptationStartRate) / 6f);
}
```

**Step 6: ATK計算への反映 — `BaseStates.StatesNumber.cs`（実装済み）**

`b_ATK()` 内の排他ATK係数ループ（271行目付近）に `* _adaptationRate` を乗算:

```csharp
// 変更前
total += coeff.Value * tenDayValue;

// 変更後
total += coeff.Value * tenDayValue * _adaptationRate;
```

**Step 7: 規格切替UI — CharaConfig WalkContainer（実装済み）**

**サイクルボタン方式**: ボタンを押すたびに次の規格に送る。ラベルは現在の規格名を表示。

```
[地味] → 押す → [派手] → 押す → [地味] → …     （複数規格武器: 2つの例）
[地味] → 押す → [トライキー] → 押す → [派手] → 押す → [なし] → 押す → [地味] → …  （フリーハンド等）
```

- 武器の `protocols` リストを順番にサイクル。「あ、まだあるの？」という小さな驚きを演出
- `HasMultipleProtocols` が true の武器装備時のみ表示（単一規格武器では非表示）
- ボタン1つ + ラベル1つ（`Button` + `TextMeshProUGUI`）で実装可能。`ToggleSingleController` は使わない
- コールバックで `SwitchProtocol(nextProtocol)` を呼ぶ
- WalkContainer内に配置（WeaponSelectAreaの近く）
- 武器変更時にラベルを `protocols[0]` の名前にリセット

**Step 8: 既存コード影響箇所の修正（実装済み）**

`protocol` → `protocols` への変更に伴い修正が必要な箇所:

| ファイル | 現在 | 変更後 |
|---------|------|--------|
| `WeaponManager.cs` | `GetFreehandWeapon()` が `protocol == none` で検索 | `_freehandWeapon` フィールドを直接返す |
| `WeaponManager.cs` | `GetAtID()` が `_masterList` のみ検索 | `_freehandWeapon.id` も先にチェック |
| `BaseStates.WeaponManager.cs` | `NowBattleProtocol = weapon.protocol` | `NowBattleProtocol = weapon.protocols[0]`（デフォルトは先頭） |
| `WeaponSelectArea.cs` | `weapon.protocol == none` でドロップダウン除外 | `AllWeapons` にフリーハンドも含まれる。除外ロジック不要 |
| `WeaponSelectArea.cs` | 規格名が単一表示 | 複数規格の場合の表示を考慮（例: `"剣 (地味/派手) [刃]"`） |
| `SwitchDefenceStyle()` | `NowBattleProtocol == none` でAimStyle.none | 変更不要（フリーハンドでもnone規格を選択していれば同じ動作） |

設計メモソース: `C:\Users\teinshiiin\Documents\20\notes\豚岬フォルダ\十日印象能力.md` 184-189行目

---

## 武器主六面の魂（特殊武器・未実装）

設計メモに記述あり。6つの「面」を持つ特殊な武器。

### 仕様

- 戦闘中に面を切り替えることで規格が変わる
- 適応ラグが発生しない（常時100%）
- 各面がそれぞれ異なる規格・ボーナスを持つ可能性
- BaseWeaponモデルでは未表現（フィールドなし）

---

## 狙い流れ (AimStyle) 詳細

### 6種のAimStyleと物理属性適性

各AimStyleには物理属性の適性が設定されている（設計メモ: 狙い流れ.md）:

| AimStyle | 日本語名 | 物理属性適性 |
|----------|---------|-------------|
| CentralHeavenStrike | 中天一弾 | なし |
| AcrobatMinor | アクロバマイナ体術 | なし |
| Doublet | ダブレット | ヴォル転(volten) |
| QuadStrike | 四弾差し込み | なし |
| Duster | ダスター | 床ずれ(dishSmack) |
| PotanuVolf | ポタヌヴォルフのほうき術 | ヴォル転(volten) |

### 物理属性一致ボーナス（実装済み）

- **武器の物理属性**とAimStyleの物理属性適性が一致した場合、**3回目以降**の連続攻撃で **1.3倍** のATKブースト
- `CheckPhysicsConsecutiveAimBoost()` in `BaseStates.Damage.cs` — `attacker.NowUseWeapon.ToPhysicalProperty()` で武器物理属性を参照
- 適性はコード内にハードコード（Doublet/PotanuVolf→volten, Duster→dishSmack）

---

## 掛け合わせ（実装済み）

### 概要

武器装備中に「非武器スキル」を使うと、武器と非武器スキルの組み合わせに応じた**別のスキル（掛け合わせスキル）**が発動するシステム。
ゲーム演出的には「特定の武器で非武器スキルを行うことで特殊な強化版スキルになる」という見せ方。

### 戦闘中のスキル選択UI（前提）

戦闘中のスキル選択には2種類のボタンがある:

| ボタン種別 | 説明 |
|-----------|------|
| **武器スキルボタン** | 装備中の武器に紐づく固定スキル（`BaseWeapon.WeaponSkill`）を発動 |
| **非武器スキルボタン群** | キャラクターが持つ武器以外のスキルを選択・発動 |

### 掛け合わせの発動フロー

```
1. プレイヤーが非武器スキルを選択
2. BattleSession.ApplySkillSelect() → ResolveCombination()
3. 装備中の武器の CombinationEntries を AllySkill.ID で検索
   → ヒット: 掛け合わせスキルに差し替えて SKillUseCall() へ
   → ミス: 元の非武器スキルをそのまま SKillUseCall() へ
4. 武器スキルそのものを選択した場合は掛け合わせしない
```

### データモデル

`BaseWeapon.CombinationEntries` に武器ごとの掛け合わせを定義。

```
BaseWeapon
  └── CombinationEntries: List<WeaponCombinationEntry>
        ├── [0] { sourceSkillId: 3, combinedSkill: (BaseSkillインスタンス) }
        ├── [1] { sourceSkillId: 7, combinedSkill: (BaseSkillインスタンス) }
        └── ...
```

`WeaponCombinationEntry` (`BaseWeapon.cs`):

| フィールド | 型 | 説明 |
|-----------|-----|------|
| `sourceSkillId` | `int` | 掛け合わせ元の非武器スキルのID（`AllySkill.ID`） |
| `combinedSkill` | `BaseSkill` | 掛け合わせ後に発動するスキル（武器上に直接保持） |

### 設定場所（インスペクタ）

```
WeaponManager (シーン上のシングルトン)
  └── _masterList
        └── [武器を展開]
              └── CombinationEntries
                    └── [+] で追加
                          ├── sourceSkillId: (AllySkill.ID)
                          └── combinedSkill: (BaseSkillを設定)
```

### フリーハンドとの関係

- フリーハンドに掛け合わせエントリを定義しなければ掛け合わせは発生しない
- システム側で明示的にブロックする必要はない

### 実装箇所

| ファイル | 変更内容 |
|---------|---------|
| `BaseWeapon.cs` | `WeaponCombinationEntry` クラス、`CombinationEntries` フィールド、`GetCombinedSkill()` メソッド |
| `BattleSession.cs` | `ResolveCombination()` メソッド、`ApplySkillSelect()` に掛け合わせ解決を挿入 |

### 将来の拡張

- 掛け合わせ発動時の演出分岐（UI通知・エフェクト） — 本仕様書の範疇外。演出システム側で扱う
- ~~掛け合わせスキルのリソースコスト設計~~ — **設計確定**: 掛け合わせスキル（combinedSkill）自身のコストを消費する。掛け合わせは「武器で別の運用をする」であり、出す技のコストを払うのが自然。元スキルのコストでは安コスト＋高火力の抜け道になる

---

## 物理属性（実装済み）

### 3種類の物理属性

| 属性 | enum値 | 概要 |
|------|--------|------|
| 暴断 | `heavy` | 重量系 |
| ヴォ流転 | `volten` | 電撃系 |
| 床ずれ | `dishSmack` | 打撃系 |

### 既存の実装（以前から存在）

- `PhysicalProperty` enum（`heavy`, `volten`, `dishSmack`, `none`）— スキル用
- `BaseSkill.SkillPhysical` — スキルごとの物理属性
- キャラ物理耐性（`HeavyResistance`, `voltenResistance`, `DishSmackRsistance`）— 乗算係数
- VitalLayer物理耐性 — バリアごとの乗算係数
- `CheckPhysicsConsecutiveAimBoost()` — AimStyle+武器物理属性一致で3回目以降の連続攻撃1.3倍

### 武器の物理属性（今回追加）

- `WeaponPhysicalProperty` enum（`heavy`, `volten`, `dishSmack`）— **noneなし、武器は必ず属性を持つ**
- `BaseWeapon.WeaponPhysical` — 武器ごとの物理属性
- `BaseWeapon.ToPhysicalProperty()` — スキル用enumへの変換メソッド

### 武器×スキルの物理属性ルール

| 条件 | 使われる物理属性 | 耐性適用回数 |
|------|-----------------|-------------|
| スキルと武器の物理属性が**一致** | スキルの属性 | **2回**（物理2）|
| スキルと武器の物理属性が**不一致** | **スキル優先** | 1回 |
| スキルが`none`、武器にあり | **武器の属性** | 1回（物理1）|

「物理2」= 耐性が2回かかる（例: 耐性0.8 → 0.8×0.8=0.64、耐性1.2 → 1.2×1.2=1.44）

実装箇所: `ApplyPhysicalResistance()` in `BaseStates.Damage.cs`

---

## 引き締め値（実装済み）

設計メモ（引き締め値.md）にて詳述。防ぎ方（AimStyle）の切り替え速度を制御するパラメータ。

### 仕組み

- 十日能力 `NightInkKnight` の値に基づく（`GetTightenMindCorrectionStage()` — NightInkKnight÷10の切り捨て）
- 値が高いほど防御スタイルの切り替えが速い
- `CalcTransformCountMax()` — AimStyle組み合わせ辞書で対応に必要な最大カウントを算出、tightenStageが高いほど減少
- `CalcTransformCountIncrement()` — tightenStageが高いほど1ターンあたりの変革カウント増分が大きい
- パワーがhighの場合、50%の確率で補正段階+1
- ~~`UnextinguishedPath`（未消光の道）の追加ボーナス~~ — **不採用**（設計メモ: 十日印象能力.md 189-192行目に原案あり）
  - 原案: 引き締め補正段階が閾値超過でDEFに未消光×1.0加算、さらに上でEYEに未消光×2.0加算
  - 不採用理由: 十日能力Aの段階で十日能力Bの係数が動的に変わる仕組みは、十日能力の「独立した印象値」という設計原則に反する。閾値によるステップ関数も既存の線形換算システムと文法が異なり、バランス調整が困難。引き締めへの報酬が欲しい場合は、引き締めの軸内（切替速度・切替中の防御低下軽減等）で設計すべき

### 実装箇所

| 関数 | 役割 |
|------|------|
| `GetTightenMindCorrectionStage()` | NightInkKnight→補正段階変換 |
| `UpdateAimStyleMemory()` | 短期記憶の更新、カウント到達で防御スタイル変更 |
| `CalcTransformCountIncrement()` | 1回あたりのカウント増分（段階が高いほど大きい） |
| `CalcTransformCountMax()` | AimStyle組み合わせごとの必要最大カウント算出 |

---

## パワー（士気）システムとの関係

設計メモ（パワー.md）にて定義。武器と直接は関係しないが、戦闘の文脈で武器効果に影響。

### パワーレベル

| レベル | 意味 | 影響 |
|--------|------|------|
| high | 高い | ダメージ増加・刃物クリティカル耐性 |
| medium | 普通 | 標準 |
| low | 低い | ダメージ減少 |
| lowlow | 最低 | 大幅ダメージ減少 |

- 刃物クリティカルの生存チャンス(`CalculateBladeDeathCriticalSurvivalChance`)でパワー参照は**実装済み**

---

## TLOAスキルとの関係

設計メモ（TLOAスキル.md）にて詳述。武器を持たない（フリーハンド）状態でTLOAスキルの「ゆりかご」計算が有利になる。

### ゆりかご（実装済み）

- TLOAスキルのスキルレベルを動的に変動させるシステム
- フリーハンド装備時は「感情転換」により不調でもゆりかごレベルが上がる
- 詳細: `doc/ゆりかごシステム仕様書.md`

---

## 魔法スキルとの関係

設計メモ（魔法スキル.md）にて詳述。

### 除算ベースのダメージ計算

- 魔法スキルは通常攻撃と異なり除算ベースの計算式を使用
- 「ケレケレ」という魔法固有の変数が存在
- 武器の `MagicData` ボーナスがこの計算に乗る

---

## 追加HP（バリアレイヤー）

設計メモ（追加HP.md）にて詳述。武器に直接関係しないが、刃物クリティカルの発生条件に影響。

- 追加HPレイヤーを持つキャラクターは、そのレイヤーを破る必要がある
- 刃物クリティカルは追加HPレイヤーを貫通した後の**本体ダメージ**で判定
- 追加HP自体は**実装済み**

---

## 実装状況一覧

### 実装済み

| 機能 | 実装場所 | 備考 |
|------|---------|------|
| 武器マスターリスト管理 | `WeaponManager.cs` | シングルトン、ID検索 |
| 武器装備・戦闘規格変更 | `BaseStates.WeaponManager.cs` | `ApplyWeapon()` |
| スキル特判別の十日能力ボーナス | `BaseStates.StatesNumber.cs` `TenDayValuesBase()`/`TenDayValuesForSkill()` | Blade/Magic/TLOAボーナス |
| 戦闘規格による排他ATK | `AttackPowerConfig.cs` | 3規格+none |
| AimStyleによる排他DEF | `DefensePowerConfig.cs` | 6スタイル |
| 刃物スキル使用制限 | `SkillResourceFlow.cs:80-81` | 刃物武器必須チェック |
| 刃物武器の精神補正無効化 | `BaseStates.ReactionSkill.cs:28` | `modifierForSkillPower = 1.0f` |
| 即死刃物クリティカル | `BaseStates.Damage.cs` | しきい値・発生率・生存チャンス |
| none戦闘規格の防御処理 | `BaseStates.Damage.cs:SwitchDefenceStyle` | none → AimStyle.none |
| 戦闘終了時のNowUseSkill null化 | `BaseStates.CallBack.cs:196` | ボーナス解除 |
| UI: 武器名+戦闘規格表示 | `StatesBannerController.cs` | 「武器:○○ -戦闘規格:○○」 |
| UI: 武器ボーナス表示 | `TenDaysMordalAreaController.cs` | Normal/Blade/Magic/TLOAの内訳 |
| 全武器リスト公開 | `WeaponManager.cs` | `AllWeapons` プロパティ（IReadOnlyList、フリーハンド含む） |
| フリーハンド取得 | `WeaponManager.cs` | `GetFreehandWeapon()` — `_freehandWeapon` フィールドを直接返す |
| フリーハンド分離 | `WeaponManager.cs` | `_freehandWeapon` 専用フィールドで `_masterList` と分離管理 |
| 複数規格データモデル | `BaseWeapon.cs` | `protocols: List<BattleProtocol>` + 後方互換 `protocol` getter |
| 適応ラグ（規格切替） | `BaseStates.WeaponManager.cs` | `SwitchProtocol()` — 77〜100%ランダムスタート、線形6戦回復 |
| 適応ラグ（武器変更） | `BaseStates.WeaponManager.cs` | `ApplyWeapon()` 内 — 99%名目ラグ |
| 適応ラグATK反映 | `BaseStates.StatesNumber.cs` | 排他ATK係数に `* _adaptationRate` 乗算 |
| 適応ラグ回復 | `BaseStates.CallBack.cs` | `RecoverAdaptation()` — 戦闘終了時に呼出し |
| 規格サイクルボタン | `CharaconfigController.cs` | `HasMultipleProtocols` 時のみ表示、押下でサイクル |
| 規格サイクルUI配置 | `SampScene.unity` | WalkContainer内にProtocolCycleButton+Label配置、CharaconfigControllerにワイヤリング完了 |
| ApplyWeapon null安全性 | `BaseStates.WeaponManager.cs` | ID不正時にフリーハンドへフォールバック |
| 武器変更サブパネル | `WeaponSelectArea.cs` | TMP_Dropdown + グレーアウト + 「武器を外す」ボタン |
| 武器ボタン（CharaConfig） | `CharaconfigController.cs` | クリックハンドラ + BattleContextHubガード |
| 戦闘時自動クローズ | `PlayersUIService.cs` | `OnBattleStart()` で `WeaponSelectArea.Close()` |
| CharaConfig状態分割 | `CharaConfigContent.cs` | BattleContainer/WalkContainer で walk/battle/novel 切替 |
| 能力値不足グレーアウト | `WeaponSelectArea.cs` | `BaseTenDayValues` vs `BaseWeapon.TenDayValues` で判定、選択不可 |
| フリーハンド装備（武器を外す） | `WeaponSelectArea.cs` | RemoveWeaponBtn → `GetFreehandWeapon()` → `ApplyWeapon()` |
| 掛け合わせ（武器×非武器スキル） | `BaseWeapon.cs`, `BattleSession.cs` | `CombinationEntries` で定義、`ResolveCombination()` で差し替え |
| 武器の物理属性 | `BaseWeapon.cs`, `BaseStates.Damage.cs` | `WeaponPhysicalProperty` enum（noneなし）、一致で耐性2回適用 |
| 武器スキルボタン（バトルUI） | `PlayersUIBindings.cs`, `AllyClass.cs`, `PlayersUIService.cs` | `AllyUISet.WeaponSkillButton` + `OnWeaponSkillBtnCallBack()` |
| 物理属性AimStyle適性ボーナス | `BaseStates.Damage.cs:CheckPhysicsConsecutiveAimBoost` | 武器物理属性とAimStyle適性一致で3回目以降×1.3。Doublet/PotanuVolf→volten, Duster→dishSmack |
| 引き締め値（防御切替速度） | `BaseStates.Damage.cs` | `GetTightenMindCorrectionStage()`等4関数。NightInkKnight÷10で段階算出、短期記憶でAimStyle切替制御 |
| TLOAゆりかご（カトレア案） | `BaseSkill.SkillLevel.cs:CalcCradleSkillLevel` | 連続調子+使いこなし+戦闘増幅+フリーハンド感情転換 |
| ライバハル馴化式 | `BaseStates.StatesNumber.cs:RivahalDream` | 総量方式+馴化式（raw²/(raw+Rivahal×K)） |
| 武器スラッシュエフェクト | `WeaponSlashAnimator.cs`, `SkillExecutor.cs` | 武器スキル/掛け合わせ発動時の斬撃線アニメーション。詳細: `doc/武器スラッシュエフェクト仕様書.md` |

### 未実装

| 機能 | 設計メモの記述 | 備考 |
|------|-------------|------|
| **武器主六面の魂** | 6面の特殊武器。戦闘中に面を切替可能。適応ラグ免除 | 専用BaseWeaponサブクラスなし |
| ~~TLOAゆりかご優位（フリーハンド時）~~ | ~~フリーハンド時にTLOAのゆりかご計算で有利になる~~ | **実装済み** — `BaseSkill.SkillLevel.cs:CalcCradleSkillLevel` フリーハンド感情転換 |
| **武器インベントリ** | — | キャラクター別の武器所持管理 |
| **武器入手システム** | — | ドロップ・ショップ・報酬等 |
| **休憩地点での適応率リセット** | 休憩地点で規格/武器変更した場合はラグなし（100%） | 休憩地点システム自体が未実装 |
| ~~引き締め段階による未消光DEF/EYEボーナス~~ | ~~引き締め段階が閾値超過でDEFに未消光×1.0、さらに上でEYEに未消光×2.0加算~~ | **不採用**: 十日能力の独立性原則に反する。引き締めの報酬は引き締めの軸内で設計すべき |

---

## 武器変更UI設計

### 配置場所

CharaConfigContent 内の **WalkContainer**（非戦闘時のみ表示されるコンテナ）。
CharaConfigContent は TabState に応じて BattleContainer / WalkContainer を切り替える。

### CharaConfigContent の状態分割

```
CharaConfigContent  [CharaConfigContent.cs + CharaconfigController.cs]
├── ボタン空間ラベル名         ← 共有（常時表示）: キャラ名
├── StatesBanner              ← 共有（常時表示）: ステータス表示
├── LeftButton / RightButton  ← 共有（常時表示）: キャラ切替
├── BattleContainer           ← battle時のみ表示
│   ├── GoToSelectEmotionalAttachmentSkill
│   ├── GoToTenDayAbilityArea
│   ├── StopConsecutiveATKForNextTurnBtn
│   ├── キャラ枠線
│   ├── 割り込みカウンタートグル / ラベル
│   ├── passiveText ×3
│   ├── EmotionalAttachmentSkillSelectArea（サブパネル）
│   └── TenDaysArea（サブパネル）
└── WalkContainer             ← walk時のみ表示
    ├── GoToWeaponSelectButton    ← 「武器」ボタン
    ├── ProtocolCycleButton       ← 規格サイクルボタン（HasMultipleProtocols時のみ表示）
    │   └── ProtocolCycleLabel    ← 現在の規格名表示
    └── WeaponSelectArea          ← 武器選択サブパネル（初期inactive）
        ├── GoBackBtn                ← 戻るボタン（右上）
        ├── RemoveWeaponBtn          ← 「武器を外す」ボタン（左上）
        ├── CurrentWeaponText        ← 現在の装備表示
        ├── TMP_Dropdown（武器リスト）← フリーハンド含む全武器表示、能力不足グレーアウト
        └── MemoText                 ← ステータスメッセージ
```

**TabState による切替ルール（CharaConfigContent.cs）:**

| TabState | BattleContainer | WalkContainer |
|----------|----------------|---------------|
| walk | 非表示 | **表示** |
| Skill, SelectTarget, SelectRange, TalkWindow, NextWait | **表示** | 非表示 |
| FieldDialogue, EventDialogue, NovelChoice | 非表示 | 非表示 |

### 方式: TMP_Dropdown + サブパネル

武器リストには **TMP_Dropdown** を使用（Prefab不要、スクロール内蔵）。

### 武器リストの表示内容

ドロップダウンの各項目に表示するテキスト:

```
武器名 (規格) [刃]          ← 単一規格武器
武器名 (規格1/規格2) [刃]   ← 複数規格武器
```

例: `ロングソード (地味) [刃]`、`杖 (トライキー)`、`双剣 (地味/派手) [刃]`
能力不足: `<color=#888888>大剣 (派手) [刃] ※能力不足</color>`（グレー表示、選択不可）
※ フリーハンドも `AllWeapons` に含まれるためドロップダウンに表示される。「武器を外す」ボタンでも操作可能。

### 操作フロー

```
1. walk状態でCharaConfigタブを開く（WalkContainerが表示される）
2. 左右ボタンでキャラを選択
3. 「武器」ボタンをタップ
   → BattleContextHub.IsInBattle ガードで戦闘中は無効
4. WeaponSelectArea がサブパネルとして表示される
   → ShowWeapons() でドロップダウンに武器リストを設定
   → フリーハンド含む全武器を表示、能力不足武器はグレーアウト
   → 現在の装備武器が初期選択される
5. ドロップダウンから武器を選択（能力不足の武器は選択不可・巻き戻し）
   → actor.ApplyWeapon(selectedWeapon.id)
   → 現在の武器テキスト・メモテキストを更新
   → StatesBanner.Bind() で表示を反映
6. 「武器を外す」ボタンをタップ
   → フリーハンド（BattleProtocol.none）を自動装備
   → フリーハンド装備中はボタン非アクティブ
7. GoBackBtn で戻る → WeaponSelectArea.SetActive(false)
```

### 能力値不足のグレーアウト

- `BaseWeapon.TenDayValues` の各エントリに対し、キャラクターの `BaseTenDayValues` と比較
- 1つでも不足 → ドロップダウンで `<color=#888888>武器名 ※能力不足</color>` 表示
- 選択操作は巻き戻され、「能力値が不足しています」メッセージ表示

### フリーハンドの扱い

- フリーハンド = `WeaponManager._freehandWeapon` で別枠管理（インスペクタ上は分離）
- `AllWeapons` にはフリーハンドも含まれる（通常武器+フリーハンドの統合キャッシュリスト）
- ドロップダウンにもフリーハンドが表示される
- `WeaponManager.GetFreehandWeapon()` で明示的なフリーハンド取得も可能
- `ApplyWeapon()` でID不正時のフォールバックとしても使用
- フリーハンド装備中は「武器を外す」ボタンが非アクティブ

### 非戦闘制限（3重防御）

| 制限 | 仕組み | 実装場所 |
|------|--------|---------|
| **状態分割** | walk時のみWalkContainer表示 → battle時は武器UIが見えない | `CharaConfigContent.SwitchContent()` |
| **ガード** | `BattleContextHub.IsInBattle` でボタン無効化＋クリック無視 | `CharaconfigController.cs` |
| **自動クローズ** | 戦闘開始時に `WeaponSelectArea.Close()` | `PlayersUIService.OnBattleStart()` |

### 武器データソース（暫定）

| 段階 | データソース | 説明 |
|------|-------------|------|
| **Phase 1**（現在） | `WeaponManager.AllWeapons` 全件 | マスター全武器から選択可能。インベントリ無視 |
| **Phase 2**（将来） | キャラ別武器インベントリ | 所持武器のみ表示。入手・喪失と連動 |

### 変更ファイル一覧

| ファイル | 変更内容 | 状態 |
|---------|---------|------|
| `WeaponSelectArea.cs` | TMP_Dropdown + グレーアウト + フリーハンドボタン | 完了 |
| `WeaponManager.cs` | `AllWeapons`, `GetFreehandWeapon()` | 完了 |
| `BaseStates.WeaponManager.cs` | `ApplyWeapon()` null安全性 + フリーハンドフォールバック | 完了 |
| `CharaconfigController.cs` | 武器ボタン + `BaseTenDayValues` パス | 完了 |
| `CharaConfigContent.cs` | `SwitchContent()` 実装（BattleContainer/WalkContainer切替） | 完了 |
| `PlayersUIService.cs` | `OnBattleStart()` で WeaponSelectArea.Close() | 完了 |
| `PlayersUIRefs.cs` | WeaponSelectArea SerializeField 追加 | 完了 |
| `PlayersRuntime.cs` | refs.WeaponSelectArea を UIService に渡す | 完了 |
| `BaseWeapon.cs` | `WeaponCombinationEntry` + `CombinationEntries` + `GetCombinedSkill()` | 完了 |
| `BattleSession.cs` | `ResolveCombination()` — 掛け合わせ差し替えロジック | 完了 |
| `BaseWeapon.cs` | `WeaponPhysicalProperty` enum + `WeaponPhysical` フィールド + 変換メソッド | 完了 |
| `BaseStates.Damage.cs` | `ApplyPhysicalResistance()` 武器×スキル物理属性ルール | 完了 |
| `BaseStates.BattleBrainSimlate.cs` | `ApplyPhysicalResistance()` 呼び出し更新 | 完了 |
| `PlayersUIBindings.cs` | `AllyUISet.WeaponSkillButton` フィールド追加 | 完了 |
| `AllyClass.cs` | `OnWeaponSkillBtnCallBack()` 武器スキルコールバック | 完了 |
| `PlayersUIService.cs` | 武器ボタンのバインド + interactable制御 | 完了 |
| `SampScene.unity` | 全UI配置・参照接続・レイアウト完了（RemoveWeaponBtn含む） | 完了 |

---

## データフロー図

```
[WeaponManager]
  ├── _masterList（通常武器）
  └── _freehandWeapon（フリーハンド別枠）
  │
  ▼ GetAtID(InitWeaponID)
[BaseWeapon]
  ├── protocols ─────────────────────┐
  ├── IsBlade ───────────────────────┤
  ├── TenDayBonusData ───────────────┤
  └── WeaponSkill                    │
                                     ▼
[BaseStates]                  ┌─────────────┐
  NowUseWeapon ◄──────────── │ ApplyWeapon │
  NowBattleProtocol ◄─────── │ (99%名目ラグ)│
  _adaptationRate ◄────────── └─────────────┘
  │                           ┌──────────────────┐
  ├── SwitchProtocol() ◄───── │ 規格サイクルボタン │
  │   (77-100%ランダムラグ)    └──────────────────┘
  ├── RecoverAdaptation() ←── 戦闘終了時コールバック
  │
  ├── TenDayValuesBase() / TenDayValuesForSkill()
  │     ├── _baseTenDayValues（素の十日能力）
  │     └── + WeaponBonus（Base: NormalDataのみ / ForSkill: +スキル特判Data）
  │           ▼
  │     ATK / DEF / EYE / AGI の計算に波及
  │
  ├── SkillResourceFlow.CanCastSkill()
  │     └── IsBlade スキル → NowUseWeapon.IsBlade チェック
  │
  ├── ComputeSkillPowers()
  │     └── IsBlade武器 → 精神補正無効化
  │
  └── BladeCriticalCalculation()
        └── IsBlade スキル + ダメージ残存 → 即死判定
```

---

## 関連ファイル一覧

| ファイル | 役割 |
|---------|------|
| `Assets/Script/BaseWeapon.cs` | 武器データモデル |
| `Assets/Script/Weapon/WeaponManager.cs` | 武器マスターリスト管理 |
| `Assets/Script/BaseStates/BaseStates.WeaponManager.cs` | 装備処理・BattleProtocol定義 |
| `Assets/Script/BaseStates/BaseStates.StatesNumber.cs` | 十日能力+武器ボーナス→4大ステ計算 |
| `Assets/Script/Config/AttackPowerConfig.cs` | ATK共通/排他係数 |
| `Assets/Script/Config/DefensePowerConfig.cs` | DEF共通/排他係数 |
| `Assets/Script/SkillResourceFlow.cs` | スキル使用可否判定（刃物チェック含む） |
| `Assets/Script/BaseStates/Battle/BaseStates.ReactionSkill.cs` | スキル威力計算・精神補正 |
| `Assets/Script/BaseStates/Battle/BaseStates.Damage.cs` | ダメージ処理・刃物クリティカル・防御切替 |
| `Assets/Script/BaseStates/Battle/BaseStates.BattleEvent.cs` | 戦闘イベント処理 |
| `Assets/Script/BaseStates/BaseStates.CallBack.cs` | 戦闘終了時のNowUseSkill null化 |
| `Assets/Script/BaseSkill/BaseSkill.Core.cs` | SkillSpecialFlag定義 |
| `Assets/Script/BaseSkill/BaseSkill.HasMethod.cs` | IsBlade/IsMagic/IsTLOAプロパティ |
| `Assets/Script/Battle/Core/BattleSession.cs` | スキル選択処理・掛け合わせ解決 |
| `Assets/Script/BattleAIBrains/BattleAIBrain.cs` | AI武器タイプ考慮 |
| `Assets/Script/USERUI/StatesBanner/StatesBannerController.cs` | 武器名+規格UI表示 |
| `Assets/Script/USERUI/MordalArea/TenDaysMordaleAreaController.cs` | 武器ボーナスUI表示 |
| `Assets/Script/Extensions/BattleProtocolExtensions.cs` | 戦闘規格の表示名ユーティリティ |
| `Assets/Script/Players/UI/PlayersUIBindings.cs` | AllyUISet定義（WeaponSkillButton含む） |
| `Assets/Script/Players/Runtime/AllyClass.cs` | OnWeaponSkillBtnCallBack（武器ボタン押下処理） |
| `Assets/Script/Players/PlayersUIService.cs` | 武器ボタンのバインド・interactable制御 |
| `Assets/Script/Players/UI/CharacterUIRegistry.cs` | キャラ別UI管理（シングルトン） |
| `Assets/Script/BaseStates/Battle/BaseStates.BattleBrainSimlate.cs` | AIダメージシミュレート（物理耐性対応） |
| `Assets/Script/Battle/WeaponSlash/WeaponSlashAnimator.cs` | 武器スラッシュアニメーション（斬撃線エフェクト） |

### 設計メモ（ソース）

以下の設計メモから情報を取得。本ドキュメントの未実装項目の詳細はこれらを参照。

| ファイル | 内容 |
|---------|------|
| `武器システム.md` | 武器システム全体の構想メモ |
| `十日印象能力.md` | 全十日能力のATK/DEF/AGI/EYE係数テーブル、複数規格武器、適応ラグ |
| `フリーハンド.md` | 無装備時の仕様 |
| `掴んで投げる.md` | フリーハンド武器スキル（命中率15%） |
| `掛け合わせ.md` | 武器スキル×通常スキルの組み合わせ構想 |
| `物理属性.md` | Heavy/Volten/DishSmackの3属性、キャラ耐性 |
| `狙い流れ.md` | AimStyle物理属性適性、一致ボーナス |
| `引き締め値.md` | NightInkKnightベースの防御切替速度 |
| `武器主六面の魂.md` | 6面特殊武器、適応ラグ免除 |
| `スキル特殊判別性質.md` | Blade/TLOA/Magicフラグの定義 |
| `刃物武器とスキル.md` | 刃物クリティカル即死計算式 |
| `TLOAスキル.md` | TLOAダメージ上限、ゆりかご |
| `魔法スキル.md` | 除算ベースダメージ、ケレケレ |
| `豚の精神補正.md` | 精神補正率(TLOA=40%, 通常=20%, 刃物=0%) |
| `パワー.md` | 士気レベルによるダメージ変動 |
| `追加HP.md` | バリアレイヤー |
| `none防ぎ方の考察について.md` | none AimStyleの詳細な防御挙動 |
