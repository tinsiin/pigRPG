# スキルレベル仕様書

スキルレベルの算出、レベルごとのデータ構造、有限/無限の成長設計をまとめた仕様書。

ゆりかご（TLOAスキル専用の動的レベル変動）については → `ゆりかごシステム仕様書.md`

> 参照メモ: `スキルレベル.md`, `豚のスキル.md`

---

## 1. スキルレベルの算出

```
スキルレベル = 永続使用回数 ÷ レベルアップ除数（切り捨て）
```

| スキル種別 | レベルアップ除数 | 定数名 |
|-----------|---------------|--------|
| TLOAスキル | 120回 | `TLOA_LEVEL_DIVIDER` |
| 非TLOAスキル | 50回 | `NOT_TLOA_LEVEL_DIVIDER` |

TLOAスキルは成長が遅い。これはゆりかごシステムによる動的補正を前提とした設計。

> 実装: `BaseSkill.SkillLevel.cs:36-49` `_nowSkillLevel` プロパティ（virtual）

---

## 2. 設計思想: 明示コピー方式

**全レベルが全プロパティの完全な値セットを持つ。**

スキルは成長とともに名前・属性・攻撃性質すら変わりうるため、
「固定値」と「レベル別オプション」という区分は設けない。

```
SkillLevelData[0]: 全値入り（＝ベース）
SkillLevelData[1]: 全値入り（[+]コピーして、変えたい部分だけ編集）
SkillLevelData[2]: 全値入り（同上）

→ 値の読み取り = そのレベルのデータを直接読むだけ
→ 哨兵値なし、逆向き検索なし、nullチェックなし
```

### 2.1 値の読み取り

```csharp
int _levelIndex => Math.Min(_nowSkillLevel, FixedSkillLevelData.Count - 1);

// 全プロパティが同じパターン
public string SkillName     => FixedSkillLevelData[_levelIndex].SkillName;
public float  SkillPower    => FixedSkillLevelData[_levelIndex].SkillPower;
public int    SKillDidWaitCount => FixedSkillLevelData[_levelIndex].SkillDidWaitCount;
// ... 以下全て同じ
```

### 2.2 Inspector上での運用

```
[+]ボタンを押す → 前レベルのデータが丸ごとコピーされる（Unity標準動作）
                → 変えたいプロパティだけ編集する
                → 変えないプロパティは前レベルの値がそのまま残る
```

- Lv0を後から修正した場合、Lv1以降への自動伝播はしない
- **全レベル一括コピーボタン（▼）**で特定フィールドの値を全レベルにコピー可能
- **差分ハイライト**で前レベルと異なるフィールドがゴールド背景で表示される

### 2.3 レベルを超えた場合

リスト末尾のデータが使われ続ける（`Math.Min`によるクランプ）。
加えて `_infiniteSkillPowerUnit` / `_infiniteSkillTenDaysUnit` による
無限スケーリング加算が適用される（既存の仕組み、変更なし）。

### 2.4 特殊プロパティパターン

一部のプロパティはレベルデータの直接読み取りに加え、ランタイム合成がある:

| プロパティ | パターン | 説明 |
|-----------|---------|------|
| `SkillType` | `LevelData.BaseSkillType \| bufferSkillType` | 戦闘中バッファとのビット合成 |
| `SubEffects` | `LevelData.SubEffects.Concat(bufferSubEffects)` | バッファとの連結 |
| `DEFATK` | 連続攻撃2回目以降はMoveSetのDEFATKを使用、それ以外はLevelData | 分岐ロジック |
| `CashMoveSet()` | LevelDataからキャッシュに読み込み | 連続攻撃中のレベル変化防止 |

---

## 3. SkillLevelData 構造

スキルはレベルごとのデータを `FixedSkillLevelData`（`List<SkillLevelData>`）として持つ。**最低1つ必須**。

```
FixedSkillLevelData:
  [0] = レベル0のデータ（初期状態）
  [1] = レベル1のデータ
  ...
  [N] = レベルNのデータ（有限リストの最後）
```

### 3.1 セクション構成

| # | セクション | フィールド数 |
|---|-----------|------------|
| 1 | 基本情報 | 6 |
| 2 | スキル性質 | 6 |
| 3 | 威力・命中・ダメージ | 7 |
| 4 | コスト・補正 | 7 |
| 5 | 連撃・ストック・トリガー | 7 |
| 6 | 前のめり | 3 |
| 7 | ムーブセット | 2 |
| 8 | エフェクト・パッシブ付与 | 10 |
| | **合計** | **48** |

### 3.2 全フィールド詳細

| セクション | フィールド名 | 型 | デフォルト値 | 備考 |
|-----------|------------|-----|------------|------|
| **① 基本情報** | | | | |
| | SkillName | string | "" | |
| | SkillSpiritual | SpiritualProperty | 0 | |
| | SkillPhysical | PhysicalProperty | 0 | |
| | Impression | SkillImpression | 0 | |
| | MotionFlavor | MotionFlavorTag | null | ScriptableObject参照 |
| | SpecialFlags | SkillSpecialFlag | 0 | Flags enum |
| **② スキル性質** | | | | |
| | BaseSkillType | SkillType | 0 | Flags enum |
| | ConsecutiveType | SkillConsecutiveType | 0 | Flags enum |
| | ZoneTrait | SkillZoneTrait | 0 | Flags enum |
| | DistributionType | AttackDistributionType | 0 | |
| | PowerRangePercentageDictionary | SerializableDictionary | new() | |
| | HitRangePercentageDictionary | SerializableDictionary | new() | |
| **③ 威力・命中** | | | | |
| | SkillPower | float | 0 | |
| | TenDayValues | TenDayAbilityDictionary | null | |
| | SkillHitPer | int | 0 | 百分率 |
| | MentalDamageRatio | float | 0 | |
| | DefAtk | float | 0 | |
| | PowerSpread | float[] | null | |
| | Cantkill | bool | false | |
| **④ コスト・補正** | | | | |
| | RequiredNormalP | int | 0 | |
| | RequiredAttrP | SerializableDictionary | new() | |
| | RequiredRemainingHPPercent | float | 0 | |
| | EvasionModifier | float | **1f** | 乗算補正 |
| | AttackModifier | float | **1f** | 乗算補正 |
| | AttackMentalHealPercent | float | **80f** | |
| | SkillDidWaitCount | int | 0 | |
| **⑤ 連撃・ストック** | | | | |
| | RandomConsecutivePer | float | 0 | |
| | DefaultStockCount | int | **1** | |
| | StockPower | int | **1** | |
| | StockForgetPower | int | **1** | |
| | TriggerCountMax | int | 0 | |
| | CanCancelTrigger | bool | **true** | |
| | TriggerRollBackCount | int | 0 | |
| **⑥ 前のめり** | | | | |
| | AggressiveOnExecute | PhaseAggressiveSetting | new(true, false) | |
| | AggressiveOnTrigger | PhaseAggressiveSetting | new(false, false) | |
| | AggressiveOnStock | PhaseAggressiveSetting | new(false, false) | |
| **⑦ ムーブセット** | | | | |
| | A_MoveSet | List\<MoveSet\> | null | |
| | B_MoveSet | List\<MoveSet\> | null | |
| **⑨ エフェクト・パッシブ** | | | | |
| | SubEffects | List\<int\> | new() | |
| | SubVitalLayers | List\<int\> | new() | |
| | CanEraceEffectIDs | List\<int\> | new() | |
| | CanEraceEffectCount | int | 0 | |
| | CanEraceVitalLayerIDs | List\<int\> | new() | |
| | CanEraceVitalLayerCount | int | 0 | |
| | TargetSelection | SkillPassiveTargetSelection | 0 | |
| | ReactionCharaAndSkillList | List\<...\> | new() | |
| | SkillPassiveEffectCount | int | **1** | |
| | SkillPassiveGibeSkillFilter | SkillFilter | new() | |

### 3.3 対象外フィールド（レベルシステム自体のメタパラメータ）

| フィールド | 型 | 場所 | 理由 |
|-----------|-----|------|------|
| `_infiniteSkillPowerUnit` | float | BaseSkill | 全レベル共通のスケーリング設定 |
| `_infiniteSkillTenDaysUnit` | float | BaseSkill | 同上 |

---

## 4. 有限/無限の二層構造

### 4.1 有限範囲（レベル ≤ リスト上限）

`FixedSkillLevelData[_levelIndex]` のデータをそのまま使用。

### 4.2 無限範囲（レベル > リスト上限）

有限リスト最終エントリを基礎値とし、超過分に無限単位を乗算して加算。

```
超過レベル数 = 現在レベル - (有限リスト数 - 1)

SkillPower = 最終のSkillPower + _infiniteSkillPowerUnit × 超過レベル数
TenDayValues = 最終のTenDayValues + _infiniteSkillTenDaysUnit × 超過レベル数
```

無限単位を持つのは SkillPower と TenDayValues の2つだけ。他の値は無限範囲でも有限リスト最終の値がそのまま使われ続ける。

> 実装: `BaseSkill.SkillPowe.cs`, `BaseSkill.TenDays.cs`

---

## 5. MoveSetのキャッシュ化

### 5.1 問題

連続攻撃中にスキル使用回数が増加してレベルが上がると、MoveSet参照先が変わって連続攻撃の手順がズレる恐れがある。

### 5.2 解決策

**連続攻撃開始時にMoveSetをキャッシュ**し、連続攻撃中はキャッシュを参照し続ける。

```
CashMoveSet() → A_MoveSet_Cash / B_MoveSet_Cash にコピー
DecideNowMoveSet_A0_B1() → キャッシュから参照
```

- プレイヤーがスキルボタンを押した時点でキャッシュされる
- 連続攻撃が終わるまでキャッシュは変更されない
- MoveSet以外の値はキャッシュされない（毎回最新レベルを参照）

> 実装: `BaseSkill.MoveSet.cs`

### 5.3 MoveSet構造

```
MoveSet:
  States: List<AimStyle>    — 2発目以降の狙い流れ（States[i] = i+2発目）
  DEFATKList: List<float>   — 2発目以降の防御係数（同じ長さ）
```

- 初回（1発目）は `SetSingleAimStyle()` で別途設定
- 総ヒット数 = 1（初回） + States.Count
- A/Bはパターン数と手数（States.Count）を必ず揃えること

---

## 6. AllySkill の拡張

味方スキルは SkillPower にHP固定加算を追加する override を持つ。

```csharp
protected override float _skillPower(bool IsCradle, BaseStates actor = null)
{
    return base._skillPower(IsCradle, actor) + CurrentHPFixedAdditionSkillPower(actor);
}
```

レベルデータの仕組み自体は変わらない。基礎のレベル計算結果に加算されるだけ。

> 実装: `AllySkill.cs`

---

## 7. Inspector / エディタ拡張

### 7.1 BaseSkillDrawer（BaseSkillEditor.cs）

BaseSkill全体のカスタムエディタ。以下を表示:
- 概要パネル（スキル名・テンプレート・バリデーション）
- レベルリスト（SkillLevelDataDrawerに委譲）
- 無限スケーリング設定（_infiniteSkillPowerUnit / _infiniteSkillTenDaysUnit）

### 7.2 SkillLevelDataDrawer（SkillLevelDataDrawer.cs）

各レベルエントリのPropertyDrawer。9セクションfoldout構造で全プロパティを日本語ラベル付きで表示。

#### 差分ハイライト

前レベルと値が異なるフィールドをゴールド背景で表示。
Lv0は比較対象なし。再帰的にSerializedPropertyを型別比較する。

#### 全レベル一括コピーボタン（▼）

各フィールド右端の▼ボタンをクリックすると、そのフィールドの値を全レベルにコピーする。
コピー後は差分ハイライトが消え、全レベルで同じ値になったことを確認できる。
Undo対応済み（`ApplyModifiedProperties` 経由）。

---

## 8. ディープコピー

### 8.1 InitDeepCopy（BaseSkill.Core.cs）

ランタイム用にBaseSkillをディープコピーする。

コピー対象:
- `FixedSkillLevelData` — 全要素を `Clone()` でディープコピー
- `_infiniteSkillPowerUnit` / `_infiniteSkillTenDaysUnit` — 値コピー
- ムーブセットキャッシュ（`A_MoveSet_Cash` / `B_MoveSet_Cash`） — 現在レベルのMoveSetから初期化
- `ReactiveSkillPassiveList` — リストコピー

### 8.2 SkillLevelData.Clone()

全フィールドのディープコピー。値型はそのままコピー、参照型（List, Dictionary, 配列等）は個別にディープコピー。

---

## 実装箇所一覧

### データ定義

| ファイル | 内容 |
|---------|------|
| `BaseSkill.SkillLevel.cs` | レベルアップ定数、`_nowSkillLevel`、`_levelIndex`、`FixedSkillLevelData`、無限単位、ゆりかご計算 |
| `BaseSkill.SkillLevel.cs` | `SkillLevelData` クラス（全40フィールド + Clone()） |

### 値の参照（全ファイル）

全プロパティは `FixedSkillLevelData[_levelIndex].Xxx` の直接読み取り。

| ファイル | プロパティ数 | 内容 |
|---------|------------|------|
| `BaseSkill.Core.cs` | 14 | SkillName, SkillSpiritual, SkillPhysical, Impression, MotionFlavor, SpecialFlags, SkillType(バッファ合成), ConsecutiveType, ZoneTrait, RequiredNormalP, RequiredAttrP, RequiredRemainingHPPercent, Cantkill, SKillDidWaitCount, EvasionModifier, AttackModifier, AttackMentalHealPercent |
| `BaseSkill.SkillHit.cs` | 1 | SkillHitPer |
| `BaseSkill.PowerSpread.cs` | 1 | PowerSpread |
| `BaseSkill.MentalDamageRatio.cs` | 1 | MentalDamageRatio |
| `BaseSkill.MoveSet.cs` | 2 | MoveSet A/B（キャッシュ付き） |
| `BaseSkill.DEFATK.cs` | 1 | DefAtk（MoveSet分岐あり） |
| `BaseSkill.Consecutive.cs` | 4 | RandomConsecutivePer, DefaultStockCount, StockPower, StockForgetPower |
| `BaseSkill.Trigger.cs` | 3 | TriggerCountMax, TriggerRollBackCount, CanCancelTrigger |
| `BaseSkill.Effects.cs` | 6 | SubEffects(バッファ合成), SubVitalLayers, CanEraceEffectIDs, CanEraceEffectCount, CanEraceVitalLayerIDs, CanEraceVitalLayerCount |
| `BaseSkill.Distribution.cs` | 3 | DistributionType, PowerRangePercentageDictionary, HitRangePercentageDictionary |
| `BaseSkill.AggressiveCommit.cs` | 3 | AggressiveOnExecute/Trigger/Stock |
| `BaseSkill.SkillPassive.cs` | 4 | TargetSelection, ReactionCharaAndSkillList, SkillPassiveEffectCount, SkillPassiveGibeSkillFilter |

### 必須値（無限スケーリング対象）

| ファイル | 内容 |
|---------|------|
| `BaseSkill.SkillPowe.cs` | `_skillPower(IsCradle)` — 有限/無限分岐 |
| `BaseSkill.TenDays.cs` | `TenDayValues(IsCradle)` — 有限/無限分岐 |

### ディープコピー

| ファイル | 内容 |
|---------|------|
| `BaseSkill.Core.cs` | `InitDeepCopy()` — SkillLevelData Clone + MoveSetキャッシュ + パッシブ |
| `BaseSkill.SkillLevel.cs` | `SkillLevelData.Clone()` — 値型コピー + 参照型ディープコピー |

### エディタ拡張

| ファイル | 内容 |
|---------|------|
| `SkillLevelDataDrawer.cs` | 9セクションfoldout + 差分ハイライト + 一括コピーボタン |
| `BaseSkillEditor.cs` | 概要パネル + バリデーション + レベルリスト + 無限スケーリング |

### 拡張

| ファイル | 内容 |
|---------|------|
| `AllySkill.cs` | `_skillPower` override（HP固定加算） |

---

## 設計メモソース

| ファイル | 内容 |
|---------|------|
| `スキルレベル.md` | スキルレベルの全体設計、有限/無限、MoveSetキャッシュ |
| `豚のスキル.md` | スキルシステム全体（性質、印象構造、ターン系プロパティ） |
| `スキルの分散割合.md` | 4種分散タイプ（Random, Beam, Explosion, Throw） |
| `連続攻撃.md` | MoveSet設計、連続攻撃の形式 |
| `狙い流れ.md` | AimStyleの種類と防御補正ルール |
