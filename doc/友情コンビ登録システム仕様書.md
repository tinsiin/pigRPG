# 友情コンビ登録システム仕様書

本書は「友情コンビ登録システム」の設計仕様をまとめたもの。全13未決事項は解決済み。コアシステムは実装済み。

関連仕様書:
- `doc/パーティ属性仕様書.md` — 既存の精神属性相性マッチングシステム
- `doc/総合戦闘仕様書.md` — 戦闘メカニクス全般
- `doc/総合キャラクター仕様書.md` — 精神属性、人間状況、パワーレベル等
- `doc/敵思考AI実装計画.md` — 登録済みコンビの協調行動AI（本システムの責務外。§9参照）

---

## 1. コンセプト

### 背景

現在の敵出現システム（`EnemyCollectAI`）は、遭遇のたびに精神属性をランダム生成し、相性判定で即席のグループを組む。グループに永続性はなく、「前回も一緒にいた敵同士」という概念が存在しない。

### 目的

戦闘を通じて「息の合った敵グループ」を永続的に登録し、以降の遭遇で固定チームとして再登場させる。これにより：

- **連携の説得力**: 登録済みコンビは互いのスキルを知っている前提の連携をしても違和感がない
- **ローグライク性**: ゲームをリプレイするたびに人間関係がリセットされ、毎回異なるコンビが生まれる
- **物語性**: プレイヤーが「またこいつらか」と敵グループに愛着や因縁を持てる

### 既存システムとの関係

既存の精神属性相性マッチングシステムは**そのまま維持**する。友情コンビ登録はその上に載せる追加レイヤーであり、既存のランダムマッチングを置き換えるものではない。

---

## 2. 既存実装（土台）

友情コンビ登録の前提となる、既に実装済みのシステム。

### 2.1 精神属性相性マッチング

| 要素 | 実装箇所 | 概要 |
|---|---|---|
| 精神属性（SpiritualProperty） | `BaseStates.StatesState.cs` | ビットフラグ。15種。遭遇時にランダム生成 |
| 相性値テーブル | `csvData/characterMatchData.csv` | 10×10行列。0〜160の相性値 |
| 種別相性 | `EnemyCollectManager.TypeMatchUp()` | TLOA/Machine/Life間の確率的相性 |
| 属性相性 | `EnemyCollectManager.ImpressionMatchUp()` | 精神属性間の確率的相性 |
| 同情効果 | `EncounterEnemySelector.HasSympathy()` | HP≤50%で相性判定確率2倍 |

### 2.2 敵グループ形成フロー（EncounterEnemySelector）

1. エンカウント判定
2. 最初の1体をランダム選出 → `InitializeMyImpression()`
3. 一人で終わるか判定（`LonelyMatchUp`）
4. 追加メンバー候補との相性判定（種別 × 属性、全既存メンバーとの合致が必要）
5. パーティー属性の決定（`calculatePartyProperty`）

### 2.3 パーティー属性

| 値 | 日本語 | 性質 |
|---|---|---|
| TrashGroup | 馬鹿共 | バラバラ・結束弱 |
| HolyGroup | 聖戦 | 強結束・使命感 |
| MelaneGroup | メレーンズ | 王道的 |
| Odradeks | オドラデクス | 秩序から離れている |
| Flowerees | 花樹 | オサレ |

### 2.4 戦闘メカニクス（クオリティ測定に関連しうるもの）

| メカニクス | 概要 |
|---|---|
| 慣れ補正（AdaptToSkill） | 同印象の攻撃を繰り返し受けると防御側が適応。印象が分散していれば適応されにくい |
| VitalLayer | バリア。破壊後に追撃が入れば連携パターン |
| 精神HP乖離 | 物理HPと精神HPの差が閾値を超えると発動。両面攻撃の結果として起きうる |
| 前のめり（ヴァンガード） | パーティ内1名が前線。交代・阻止の役割分担 |
| 人間状況（Demeanor） | 感情状態。仲間の死亡で変化（CloseAllyDeath）。覚悟・怒りへの変遷は絆の証拠 |
| 同情効果 | HP半分以下で相性判定2倍。傷つきながらの共闘 |
| オーバーキル/Broken | 余剰ダメージによる完全破壊。コンビ解消の条件候補 |

---

## 3. 登録システム設計

### 3.1 二層構成

コンビ登録には2つのパスを設ける。

#### 正規パス（実力コンビ）

戦闘中に複数の「コンビを組むきっかけ」が起きたグループほど登録されやすくなる。全登録の**マジョリティ**を占める想定。

**カウント式確率テーブル**: 4つのシグナル（§3.2）のうち何個が該当したかで登録確率が決まる。各シグナルに重み差は設けない。現実の友情と同じく、コンビを組むきっかけは多様であり、特定のきっかけが他より重要ということはない。より多くの事象が重なるほど自然にコンビが成立する。

| 該当数 | 登録確率 |
|---|---|
| 0個 | 0%（腐れ縁パスに任せる） |
| 1個 | 3% |
| 2個 | 12% |
| 3個 | 30% |
| 4個 | 60% |

#### 腐れ縁パス（ポンコツコンビ）

相性値・戦闘結果に**関係なく**、低確率で無条件に登録される。

| 条件 | 詳細 |
|---|---|
| 相性条件 | なし |
| 戦闘条件 | なし |
| 登録確率 | **4%**（正規パスの0個=0%との棲み分け） |

#### 判定順序

正規パスを先に判定し、不発だった場合のみ腐れ縁パスの抽選に進む。両パスが同時に成立することはない。

#### 設計意図

- 正規パスだけだと「強い組み合わせ」しか生まれない
- 腐れ縁パスにより「相性最悪なのに何故か一緒にいるポンコツコンビ」が低頻度で発生
- プレイヤーが「なんでこいつら一緒なの？」と想像する余白が生まれる
- ただし腐れ縁パスの確率が高すぎるとポンコツだらけになるため、正規パスがマジョリティを維持するバランスが必要

### 3.2 戦術クオリティの候補

正規パスの「戦闘条件」として使いうる既存メカニクスからのシグナル一覧。全部入れる必要はなく、採用候補として列挙する。

#### 候補A: 戦果（最もシンプル）

味方を1人でも撃破できたかどうか。

- **測定**: 戦闘終了時に味方の死亡回数をカウント
- **利点**: 実装が極めて簡単。「結果を出した組」という明快な基準
- **欠点**: 偶然の一撃で達成できてしまう場合がある

#### 候補B: 慣れ補正の分散度

敵グループが多様なスキル印象で攻撃し、味方の慣れ補正が特定印象に偏らなかった度合い。

- **測定**: 戦闘終了時に味方側 `AdaptToSkill` の記憶分布を確認。偏りが小さいほどスコア高
- **利点**: 「多角的な攻め」を直接測れる。既存の慣れ補正システムがそのまま測定器
- **欠点**: スキル印象の多様性は敵の保有スキルに依存するため、個体差で結果が偏る

#### 候補C: VitalLayer破壊 → 追撃

敵Aがバリアを破壊し、次に別の敵Bが同じ対象にヒットした。

- **測定**: `BarrierLayers` でレイヤー破壊が発生した同ターンまたは直後ターンに、別の敵が同対象にヒットしたか
- **利点**: 明確な連携パターン
- **欠点**: VitalLayer自体が全員に付いているわけではないため、発生頻度が低い

#### 候補D: 精神HP乖離の誘発

敵グループの攻撃により味方に `MentalDiverGence`（アッパー/ダウナー乖離）が発動した。

- **測定**: 戦闘中に味方側で乖離が発生したかどうか
- **利点**: 物理面と精神面の両面攻撃ができていた証拠
- **欠点**: 乖離発生は被害者の人間状況にも大きく依存するため、敵の連携だけでは制御しにくい

#### 候補E: 前のめり活用

敵グループ内でヴァンガードの交代・阻止が発生し、役割分担ができていた。

- **測定**: 敵グループ内のヴァンガード交代回数、`TryBlockVanguard` 成功回数
- **利点**: タンク＋アタッカーの役割分担を反映
- **欠点**: 前のめり自体が全戦闘で発生するわけではない

#### 候補F: 人間状況の変遷

仲間の死亡（`ApplyConditionChangeOnCloseAllyDeath`）により人間状況が覚悟・怒りに変化した。戦術というより「絆」の指標。

- **測定**: CloseAllyDeathコールバック発生 + Demeanor変化の記録
- **利点**: 物語的な説得力が高い。「仲間の死に感化された」
- **欠点**: 仲間が死なないと発動しないため、強いグループほど発動しにくい

#### 候補G: ダメージ効率

敵グループの総ステータスに対する与ダメージの比率。弱い敵が大きな戦果を出していれば連携が良かった証拠。

- **測定**: 総与ダメージ ÷ 敵グループの合計ステータス
- **利点**: 総合的な戦闘パフォーマンスを1つの数値で表現
- **欠点**: 定義次第では相性やパワーレベル差に左右される

#### 推奨組み合わせ（暫定）

全候補を入れると測定コストが膨らむため、以下の3軸程度を重み付け合算する案：

1. **戦果**（候補A）— 結果の軸。最低限これは欲しい
2. **慣れ分散度**（候補B）— 戦術の軸。測定コスト低め
3. **人間状況変遷**（候補F）— 絆の軸。物語的な厚み

残りは「あれば加点」程度のオプション。

#### 採用シグナル（確定）

上記候補を検討した結果、測定コストと表現力のバランスから以下の4つを採用。測定タイミングが「結成時」と「戦闘終了時」に綺麗に分かれる。

| # | シグナル | 候補元 | 何を見るか | タイミング |
|---|---|---|---|---|
| 1 | **戦果** | 候補A | 味方を1人でも倒せたか | 戦闘終了時 |
| 2 | **仲間の死** | 候補Fの簡略版 | 戦闘中に敵側メンバーが死亡した事実（人間状況の変遷は問わない） | 戦闘終了時 |
| 3 | **同情効果** | 既存実装の転用 | グループ結成時に `sympathy=true`（HP≤50%）で加入が成立したか。1人でも同情加入していれば発動 | グループ結成時 |
| 4 | **ダメージ効率** | 候補G | 身の丈超えダメージ（後述） | 戦闘終了時 |

**慣れ分散度（候補B）は不採用**。測定コストに対して効果が読みにくいため。

**合算方法: カウント式**。4シグナルそれぞれをbool化（ダメージ効率は閾値≥1.0でtrue）し、該当数で§3.1のカウント式確率テーブルを引く。シグナル間に重み差は設けない。

#### ダメージ効率の定義

**身の丈超えダメージ方式を採用**。

```
ダメージ効率 = 登録対象メンバーの総与ダメージ ÷ 登録対象メンバーの総MaxHP
```

- 効率 ≥ 1.5: 自分たちのHP総量を大幅に超えるダメージ。連携が良い証拠
- 効率 ≈ 1.0: 自分たちの体力分のダメージ。普通
- 効率 ≤ 0.3: ほぼ何もできなかった

**評価対象の原則**: ダメージ効率の分子（総与ダメージ）・分母（総MaxHP）はともに、**実際にコンビとして登録されるメンバーのみ**で算出する。途中で逃走した敵や、登録対象外の残存敵は計算に含まない。

| 経路 | 評価対象 |
|---|---|
| 通常経路（戦闘終了時） | 戦闘終了時の残存メンバー（= 登録候補） |
| グループ逃走経路 | 逃走者リスト（自発 + 連鎖） |

**測定方法**: 味方の `damageDatas` リストを走査し、評価対象メンバーが与えたダメージを逆算して集計する。分母は評価対象メンバーのMaxHP合計。リアルタイムカウンタは不要。

**採用理由**: 記録が一括計算で済む。「戦果」との組み合わせ前提なので精密さより簡潔さを優先。

**閾値（カウント式でtrue扱いにする基準値）**: ダメージ効率 ≥ 1.0。

### 3.3 登録判定のタイミングと条件

#### 前提条件

- **全ての戦闘結果**（勝利・敗北・逃走）で登録判定が行われる
- **敵グループが2人以上**の場合のみ対象。ソロ敵はスキップ
- **既に登録済みのコンビ**は再判定せず、再遭遇カウントを加算して終了

#### 結果倍率（OnBattleEnd経由）

戦闘終了時（`OnBattleEnd`）に、戦闘結果に応じて正規パスの確率に倍率がかかる。**腐れ縁パス（4%）は倍率なしの固定値**。

| 結果 | フラグ条件 | 倍率 | 例: 2シグナル(12%) |
|---|---|---|---|
| 敵勝利 | `Wipeout && ActerFaction == Ally` | ×1.5 | → 18% |
| 味方勝利 | `Wipeout && ActerFaction == Enemy` | ×1.0 | → 12% |
| 味方逃走 | `AlliesRunOut` | ×1.0 | → 12% |

#### グループ逃走倍率（戦闘中・別経路） ✅実装済み

敵の連鎖逃走で**2人以上が同時に逃げた**場合、「グループ逃走」として戦闘中に即座にコンビ登録判定が走る。これは `OnBattleEnd` とは別経路で、`EscapeHandler.EscapeACT()` 内で連鎖逃走者の除去前に実行される。

| 条件 | 倍率 |
|---|---|
| 連鎖逃走者 ≥ 1人（= 合計2人以上逃走） | ×2.0 |

登録対象は**全逃走者**（自発的に逃げた1体 + 連鎖逃走者）。「一緒に逃げた全員」をコンビとして登録する。

実装: `EscapeHandler.cs` → `BattleManager.TryRegisterGroupEscapeCombo()` コールバック

##### グループ逃走の背景

既存の連鎖逃走メカニクスを「グループ逃走」として再解釈するアプローチ。新メカニクスの追加ではなく、連鎖逃走の「1人が逃げたら仲間もつられて逃げる」という演出がグループの絆を自然に表現するため、その結果をコンビ登録のトリガーとして活用する。

##### 連鎖逃走の判定条件

1体が逃走成功した後、残りの敵に対して連鎖判定:

1. **相性値ベース**: 逃げた敵との相性値 ≥ 77 → 無条件で連鎖
2. **精神属性ベース**: 属性ごとの逃走率で確率判定

| 精神属性 | 連鎖逃走率 |
|---|---|
| Psycho | 100% |
| Kindergarten | 80% |
| BaleDrival | 60% |
| LiminalWhiteTile | 55% |
| GodTier | 50% |
| Devil / Doremis | 40% |
| Cquiest | 25% |
| Pillar | 10% |
| Sacrifaith | 5% |
| None | 0% |

##### パターン別の判定結果

| 状況 | 逃走者 | 残存敵 | グループ逃走？ | 登録対象 | 戦闘 |
|---|---|---|---|---|---|
| A逃走 → B,C連鎖 | A,B,C | 0 | **Yes**（×2.0） | [A,B,C] | 終了 |
| A逃走 → B,C連鎖、D残る | A,B,C | D | **Yes**（×2.0） | [A,B,C] | 続行 |
| A逃走 → Bのみ連鎖 | A,B | C残る | **Yes**（×2.0） | [A,B] | 続行 |
| A逃走 → 連鎖なし | A | B,C残る | No | — | 続行 |
| 2体: A逃走 → B連鎖 | A,B | 0 | **Yes**（×2.0） | [A,B] | 終了 |
| 2体: A逃走 → 連鎖なし | A | B | No | — | 続行 |

##### 逃走フローの統合 ✅実装済み

連鎖逃走はかつて2ターンに分裂していたが、1ターン内での即時解決に統合された。

```
【旧: 2ターン分裂】
ターンN:   A逃走成功 → A除去 → 連鎖リスト作成(DominoRunOutEnemies) → ターン終了
ターンN+1: DominoEscapeACT() → 連鎖者を除去 → ターン終了

【現行: 1ターン即時解決】
ターンN: A逃走成功 → A除去 → 連鎖判定(CollectChainEscapers) →
  連鎖者2人以上？ → Yes → グループ逃走: コンビ登録判定(×2.0)
  → 連鎖者を即時除去 → ターン終了 → ACTPop(EnemyGroupEmpty検知)
```

変更内容:
- `EscapeHandler.EscapeACT()`: 連鎖判定→除去を同一メソッド内で完結
- `DominoEscapeACT()` を廃止
- `TurnExecutor.ACTPop()` / `BattleFlow.CharacterActBranchingAsync()` からドミノ分岐を削除

#### 判定タイミング

**通常経路**: `BattleManager.OnBattleEnd()` 内、`ResetCharactersUseThinges()` の後、`RecovelyStart()` の前。このタイミングでは `EnemyGroup` / `AllyGroup` の参照と `damageDatas` がまだ無傷。

**グループ逃走経路**: `EscapeHandler.EscapeACT()` 内、連鎖逃走者を `EscapeAndRemove()` する直前。連鎖逃走者はまだ `Ours` に残っており、シグナル収集・GUID取得が可能。

---

## 4. コンビの再登場

### 4.1 再登場条件

登録済みコンビのメンバーが**2人以上生存（broken以外）**の場合、再登場の対象となる。

#### メンバーの状態と再登場への影響

| メンバーの状態 | 再登場への影響 |
|---|---|
| 生存中 | 再登場対象 |
| 死亡 + 復活可能（`Reborn=true`） | 歩数条件（`CanReborn`）を満たすまで待機。復活後は再登場対象に復帰 |
| broken（完全破壊） | 永久除外。二度と出現しない（§5.1の解消ルール適用） |

コンビの有効メンバー（生存中 + 復活済み）が2人以上いる場合にのみ、§4.2の再登場フローの対象となる。1人しか有効でない場合、もう1人が復活するまでコンビとしては出現しない（個体としても§4.2の除外ルールにより出現しない）。

### 4.2 再登場フロー（自然混入方式）

独立した出現率パラメータは設けない。通常のランダムエンカウントフローの中にコンビ再結成を自然に組み込む。

```
1. 有効敵プールから1体目をランダム選出（= リーダー）

2a. リーダーが登録済みコンビのメンバーだった場合
    → コンビ相方を有効敵プールから収集（再結成）
    → 相性判定をスキップ（登録済みコンビのため確定加入）
    → broken判定済みの相方のみ追加

2b. リーダーがどのコンビにも属していない場合
    → 候補プールから登録済みコンビメンバーを全て除外
    → 通常の相性判定で追加メンバーを探す（既存フロー）
```

**コンビメンバーの出現制約**: 登録済みコンビのメンバーは、自分のコンビが再結成される場合（2a）にのみ出現する。リーダーがフリーの場合（2b）は追加候補から除外される。これにより「コンビなのにバラバラに出る」「片方だけ出て事故死/brokenされる」を防ぐ。

**出現率の決まり方**: 有効敵プール中にコンビメンバーが何体いるかで自然に決まる。敵100体中コンビメンバーが3体なら、3/100の確率でコンビ再結成のきっかけが生まれる。専用パラメータの調整が不要。

### 4.3 再登場時の強化

メモ（`ReEncount敵ステータス変化.md`）に構想あり：

- ReEncountを繰り返すたびにパッシブ付与スキルや回復率が上昇
- 友情登録グループなら下限が高い

**現時点の方針**: コンビ登録データに「再遭遇回数」を持たせるのみ。強化の具体内容はReEncountシステム全体の設計と合わせて後日決定する。

### 4.4 コンビの最大人数

**最大3体**。既存の `EncounterEnemySelector` のグループ上限（`Mathf.Clamp(number, 1, 3)`）と一致。2人コンビも3人トリプルも登録可。

### 4.5 ローグライクリセット

ニューゲーム時にコンビ登録データを**全消去**する。メモの原文にある「リプレイするたびに人間関係がリセット、違う並列の世界に来たような感覚」をそのまま実現。セーブデータのクリアと同タイミングで消去。

---

## 5. コンビの存続と消滅

### 5.1 基本原則

**コンビは「解散」しない。** メンバーがbrokenで減っていくだけ。最後の1人になっても、かつてのコンビの名残としてソロで出現し続ける。フリーに戻ることはなく、通常のランダムグループにも混ざらない。

### 5.2 有効メンバーと出現ルール

```
有効メンバー = 非brokenの数（生存中 + 死亡だが復活可能）
出撃可メンバー = 生存中のみ（今すぐ出られる）
```

| 有効メンバー数 | 出撃可の状況 | 結果 |
|---|---|---|
| ≥ 2 | 出撃可 ≥ 2 | **コンビで出現** |
| ≥ 2 | 出撃可 ≤ 1 | **出現しない（復活待ち）** |
| = 1 | 出撃可 = 1 | **ソロで出現（永遠にひとりぼっち）** |
| = 1 | 出撃可 = 0 | **出現しない（復活待ち）** |
| = 0 | — | **コンビ消滅（全員broken）** |

### 5.3 新規メンバーの追加

しない。元の組み合わせを尊重する。

---

## 6. ストーリーキャラとの共存

ストーリーやイベントに登場する名前付き敵キャラは、ランダムマッチングとは別枠で管理する。

| 敵の種別 | マッチング方式 | 友情コンビ登録 |
|---|---|---|
| ランダム敵 | 精神属性相性マッチング → 友情コンビ登録対象 | 対象 |
| ストーリー固定敵 | 固定配置。ランダムマッチングに混入しない | 対象外 |

ストーリー固定敵は「固定サイドオブジェクト」として通常マッチングとは独立した枠に配置する。

**実装方式**: `EncounterSO` にboolフラグ `isStoryEncounter` を追加。trueのエンカウントは `UnityBattleRunner` で `ComboRegistry` を渡さないことにより、友情コンビ登録（登録判定・再結成・broken記録）の全てが自動的にスキップされる。✅実装済み

---

## 7. 実装アーキテクチャ

### 7.1 ファイル構成

| ファイル | 役割 |
|---|---|
| `Assets/Script/Walk/Encounter/FriendshipComboData.cs` | セーブデータ構造体群 |
| `Assets/Script/Walk/Encounter/FriendshipComboRegistry.cs` | ランタイムのコンビデータ管理 |
| `Assets/Script/Walk/Encounter/FriendshipComboJudge.cs` | シグナル収集 + 登録判定ロジック |
| `Assets/Script/Walk/Encounter/EncounterEnemySelector.cs` | コンビ再出現の分岐ロジック（既存ファイル拡張） |
| `Assets/Script/Enemy/NormalEnemy.cs` | 個体GUID（既存ファイル拡張） |
| `Assets/Script/BattleGroup.cs` | sympathy/MaxHPフラグ（既存ファイル拡張） |
| `Assets/Script/BattleManager.cs` | 登録判定フック + グループ逃走コンビ登録（既存ファイル拡張） |
| `Assets/Script/Battle/CoreRuntime/EscapeHandler.cs` | 連鎖逃走の即時解決 + グループ逃走コールバック（既存ファイル拡張） |
| `Assets/Script/Battle/BattleInitializer.cs` | ComboRegistry受け渡し（既存ファイル拡張） |
| `Assets/Script/Walk/Battle/UnityBattleRunner.cs` | GameContext→Initializer中継（既存ファイル拡張） |
| `Assets/Script/Walk/GameContext.cs` | ComboRegistry保持 + GUID復元（既存ファイル拡張） |
| `Assets/Script/Walk/WalkProgressData.cs` | セーブ/ロード統合（既存ファイル拡張） |

### 7.2 データフロー

```
[戦闘開始]
  GameContext.ComboRegistry
    → UnityBattleRunner (抽出)
      → BattleInitializer (パラメータ受け渡し)
        → EncounterEnemySelector.SelectGroup (コンビ分岐判定)
        → BattleManager.ComboRegistry (プロパティ注入)

[戦闘終了 — 通常経路]
  BattleManager.OnBattleEnd()
    → TryRegisterFriendshipCombo()
      → GetOutcomeMultiplier() (敵勝利×1.5, その他×1.0)
      → FriendshipComboJudge.CollectSignals() (4シグナル収集)
      → FriendshipComboJudge.ShouldRegister(multiplier) (確率判定)
      → ComboRegistry.Register() (コンビ登録)

[グループ逃走 — 別経路（戦闘中）]
  EscapeHandler.EscapeACT()
    → CollectChainEscapers() (連鎖判定)
    → chainEscapers.Count >= 1 ? (合計2人以上逃走)
      → _onGroupEscape コールバック
        → BattleManager.TryRegisterGroupEscapeCombo()
          → FriendshipComboJudge.CollectSignals() (4シグナル収集)
          → FriendshipComboJudge.ShouldRegister(2.0f) (×2.0で判定)
          → ComboRegistry.Register() (コンビ登録)
    → 連鎖者を即時除去

[セーブ]
  WalkProgressData.FromContext()
    → ComboRegistry.Export() → FriendshipCombos
    → GameContext.ExportComboEnemyStates() → EnemyStates

[ロード]
  WalkProgressData.ApplyToContext()
    → ComboRegistry.Import() (コンビ + 敵状態復元)
    → GameContext.GetRuntimeEnemies() で GUID 復元
```

### 7.3 データ構造

#### FriendshipComboSaveData（コンビ1件）

| フィールド | 型 | 内容 |
|---|---|---|
| `ComboId` | `string` | コンビ識別子（GUID） |
| `MemberGuids` | `List<string>` | メンバーの個体IDリスト |
| `IsKusareEnPath` | `bool` | 腐れ縁パスで登録されたか |
| `ReEncountCount` | `int` | 再遭遇回数 |

#### EnemyPersistenceData（敵個体の永続化）

| フィールド | 型 | 内容 |
|---|---|---|
| `EnemyGuid` | `string` | 個体GUID |
| `EncounterId` | `string` | 所属EncounterSOのId |
| `TemplateIndex` | `int` | EncounterSO.EnemyList内のインデックス |
| `IsBroken` | `bool` | 完全破壊されたか |
| `HP` | `float` | 現在HP |
| `MentalHP` | `float` | 現在精神HP |

#### FriendshipComboRegistry（ランタイム管理）

| メソッド | 機能 |
|---|---|
| `Register(combo)` | コンビ登録 + GUIDキャッシュ更新 |
| `FindComboByMemberGuid(guid)` | GUIDからコンビをO(1)検索 |
| `GetEnemyState(guid)` | 個体の永続データ取得 |
| `GetEnemyStateByEncounterIndex(id, idx)` | Encounter+インデックスから永続データ取得 |
| `GetActiveMembers(combo)` | 有効メンバー数（非broken） |
| `MarkBroken(guid)` | brokenフラグ設定。`BattleManager.OnBattleEnd()` から呼び出し |
| `Export()` / `Import(data)` | セーブ/ロード |
| `Clear()` | ニューゲーム時の全消去 |

### 7.4 敵個体の永続化

`NormalEnemy` に `string EnemyGuid` プロパティを追加。遅延初期化で初回アクセス時に `System.Guid.NewGuid().ToString()` を発行。

- `DeepCopy()` 時に新GUIDを発行（新個体なので新ID）
- `RestoreGuid(string)` でセーブデータからのGUID復元が可能
- テンプレート（ScriptableObject上の定義）のGUIDは使用しない。ランタイムコピーのみ

#### GUID ↔ ランタイムNormalEnemy の紐付け（セーブ/ロード時）

`GameContext.GetRuntimeEnemies()` でDeepCopy生成時に、`ComboRegistry.GetEnemyStateByEncounterIndex()` で保存済みGUIDをチェックし、存在すれば `RestoreGuid()` で復元する。これによりロード後も同一GUIDでコンビメンバーを特定できる。

### 7.5 既知の制限事項

- **HP/broken状態のロード後未復元**: `GetRuntimeEnemies()` でGUIDは復元されるが、HP・broken・MentalHPはDeepCopy初期値のまま。セッション内はキャッシュで問題なし。ロード後はコンビ再結成時に `GetEnemyState().IsBroken` でbroken判定が効くため、コンビ機能としては正常動作する。ただしフリーエンカウント側でbroken敵がリセット状態で出現する可能性があり、これは全体的な敵状態永続化の課題（本システム固有ではない）

---

## 8. 実装上の障壁と対策

### 8.1 敵個体の永続化 ✅実装済み

~~現状: 遭遇ごとに `InitializeMyImpression()` で属性がランダム再生成。個体の追跡不可。~~

**方式**: `NormalEnemy` に `string EnemyGuid` フィールドを追加。初回生成時に `System.Guid.NewGuid().ToString()` で発行。セーブデータにGUIDを含め、コンビ登録データはこのGUIDで個体を参照する。

実装:
- 個体GUIDの発行: `NormalEnemy.EnemyGuid`（遅延初期化）
- DeepCopy時の新GUID発行: `NormalEnemy.DeepCopy()`
- GUID復元: `NormalEnemy.RestoreGuid(string)` + `GameContext.GetRuntimeEnemies()` でロード時適用
- 個体状態の永続化: `EnemyPersistenceData` 構造体 + `WalkProgressData` によるJSON保存

### 8.2 登録データの永続化 ✅実装済み

コンビ登録情報の保存。

| データ | 保存先 |
|---|---|
| コンビID | `FriendshipComboSaveData.ComboId` |
| メンバーの個体IDリスト | `FriendshipComboSaveData.MemberGuids` |
| 登録パス（正規 or 腐れ縁） | `FriendshipComboSaveData.IsKusareEnPath` |
| 再遭遇回数 | `FriendshipComboSaveData.ReEncountCount` |

永続化フロー: `GameContext.ComboRegistry` → `WalkProgressData.FromContext()` でエクスポート → JSON保存 → `WalkProgressData.ApplyToContext()` でインポート

### 8.3 逃走フロー統合 + グループ逃走コンビ登録 ✅実装済み

連鎖逃走を2ターン分裂から1ターン即時解決に統合し、グループ逃走（合計2人以上逃走）時にコンビ登録判定を発火させる仕組み。

| 変更ファイル | 変更内容 |
|---|---|
| `EscapeHandler.cs` | `DominoEscapeACT()` 廃止。`EscapeACT()` 内で連鎖判定→除去を即時完結。`onGroupEscape` コールバック追加。`GetRunOutEnemies` → `CollectChainEscapers` にリネーム（ローカルリストを返す） |
| `TurnExecutor.cs` | `ACTPop()` からドミノ分岐（`DominoRunOutEnemies.Count > 0`）を削除 |
| `BattleFlow.cs` | `CharacterActBranchingAsync()` からドミノ分岐を削除、`DominoEscapeAct()` メソッド削除 |
| `BattleManager.cs` | `TryRegisterGroupEscapeCombo()` 追加（×2.0）。`EscapeHandler` 生成時にコールバック接続 |

### 8.4 EncounterEnemySelectorへの分岐追加 ✅実装済み

`EncounterEnemySelector.Select()` に以下の分岐を追加:

1. リーダー選出後、`FriendshipComboRegistry.FindComboByMemberGuid()` で所属コンビを検索
2. コンビメンバーなら `AssembleComboGroup()` で再結成（相性チェックスキップ、broken判定あり）
3. フリーリーダーなら `ExcludeComboMembers()` でコンビメンバーを候補から除外し、通常フローへ

`ComboRegistry` は `BattleInitializer` 経由の名前付きパラメータで `SelectGroup()` に渡される。

### 8.5 broken接続 ✅実装済み

戦闘終了時に `BattleManager.MarkBrokenEnemies()` が敵グループを走査し、`broken == true` の個体を `ComboRegistry.MarkBroken(guid)` に反映する。これによりbrokenされた敵はコンビ再登場時に除外される。

呼び出し順: `OnBattleEnd()` → `TryRegisterFriendshipCombo()` → `MarkBrokenEnemies()` → `RecovelyStart()`

### 8.6 戦術クオリティの測定 ✅実装済み

`FriendshipComboJudge.CollectSignals()` で4シグナルを収集:

| シグナル | 測定方法 |
|---|---|
| 戦果 | `allyGroup.Ours` の死亡判定走査 |
| 仲間の死 | `enemyGroup.Ours` の死亡判定走査 |
| 同情効果 | `BattleGroup.HasFormationSympathy`（結成時に `EncounterEnemySelector` が記録） |
| ダメージ効率 | 味方の `damageDatas` を走査し、**登録対象メンバーのみ**の与ダメ ÷ 登録対象メンバーのMaxHP合計で算出。閾値≥1.0。通常経路は残存メンバー、グループ逃走経路は逃走者リストが評価対象 |

`FriendshipComboJudge.ShouldRegister()` でカウント式確率テーブルを適用し、正規パス → 腐れ縁パスの順に判定。

---

## 9. 未決事項一覧

#1〜#13は解決済み。#14〜#16はグループ逃走関連の追加項目。

| # | 項目 | 内容 | 状態 |
|---|---|---|---|
| ~~1~~ | ~~正規パスの登録確率~~ | ~~条件を満たした上で何%で登録するか~~ | **決定済**: カウント式（0/3/12/30/60%） |
| ~~2~~ | ~~腐れ縁パスの登録確率~~ | ~~ポンコツ過多にならない適切な値~~ | **決定済**: 4% |
| ~~3~~ | ~~戦術クオリティの採用候補~~ | ~~§3.2のどれを使うか。重み配分~~ | **決定済**: 4シグナル等価、カウント式 |
| ~~4~~ | ~~ダメージ効率の閾値~~ | ~~何をもって「効率が良い」とするか~~ | **決定済**: ≥1.0（身の丈超え方式） |
| ~~5~~ | ~~正規パスの相性値閾値~~ | ~~相性値が何以上で正規パスの候補とするか~~ | **廃止**: グループ結成時の相性判定で既にフィルタ済み。正規パスの条件は4シグナルのみ |
| ~~6~~ | ~~登録上限~~ | ~~同時に存在できるコンビの最大数~~ | **決定済**: 制限なし（実プレイで判断） |
| ~~7~~ | ~~再登場の出現率~~ | ~~通常ランダムとの比率~~ | **廃止**: 自然混入方式により専用パラメータ不要（§4.2） |
| ~~8~~ | ~~再登場時の強化内容~~ | ~~パッシブ・回復率等の具体的な数値~~ | **決定済**: 再遭遇回数のみ記録、内容は後日 |
| ~~9~~ | ~~部分解消のルール~~ | ~~トリプルから1人broken時の扱い~~ | **決定済**: コンビは解散しない。broken除外、残1人でもソロ出現。全員brokenで消滅 |
| ~~10~~ | ~~ストーリー固定敵の実装方式~~ | ~~「固定サイドオブジェクト」の具体設計~~ | **決定済・実装済**: `EncounterSO.isStoryEncounter` + `UnityBattleRunner` でComboRegistry非注入 |
| ~~11~~ | ~~敵個体の永続ID方式~~ | ~~GUID？連番？ セーブデータ構造~~ | **決定済**: `System.Guid` 文字列、JSON保存 |
| ~~12~~ | ~~ローグライクリセット範囲~~ | ~~ゲームリプレイ時にどこまでリセットするか~~ | **決定済**: ニューゲーム時に全消去 |
| ~~13~~ | ~~コンビの最大人数~~ | ~~2人（コンビ）まで？ 3人（トリプル）まで？ それ以上？~~ | **決定済**: 最大3体（既存上限と一致） |
| ~~14~~ | ~~2体グループのグループ逃走~~ | ~~2体[A,B]でA逃走→B連鎖の場合、連鎖者はBだけ（1人）なのでグループ逃走にならない~~ | **決定済**: 条件を「連鎖者≥1（=合計2人以上逃走）」に変更。登録対象は全逃走者（自発+連鎖）。2体グループでも成立 |
| 15 | **グループ逃走の演出** | グループ逃走時のバトルメッセージ差し替え等 | **未決** |
| 16 | **連鎖逃走の確率バランス** | 全連鎖の発生頻度が適切か。現在の属性別確率テーブルの調整 | **未決** |

---

## 10. 本システムの意義と責務範囲

### 意義

本システムは以下の2つの価値を**同時に**提供する：

- **物語性**: 「またこいつらか」——敵グループに因縁や愛着が生まれる。ローグライクのリプレイごとに異なるコンビが形成され、毎回違う敵の人間関係が楽しめる
- **難易度性**: 戦闘で結果を出した強い組み合わせが再登場しやすくなる。プレイヤーは過去に苦戦した敵コンビとの再戦に備える必要が生まれる

### 責務範囲

本システムの責務は **「誰と誰が一緒に出るか」の決定** まで。

元のメモにあった「味方のスキルを知っている前提の連携」——すなわち **「一緒に出た上でどう戦うか」** は敵思考AIシステムの責務であり、本システムのスコープ外。

ただし、本システムが提供する**「登録済みコンビかどうか」のフラグ**は、将来の敵AIシステムが参照して連携行動（スキル連携、集中攻撃、カバー行動等）を実装する際の基盤となる。

```
友情コンビ登録システム（本書）     敵思考AIシステム（将来）
┌──────────────────┐          ┌──────────────────┐
│ 誰と誰が一緒に出るか │ ──フラグ──→ │ 一緒に出た上でどう戦うか │
│ コンビの登録・再登場  │          │ スキル連携・戦術行動    │
└──────────────────┘          └──────────────────┘
```

---

## 改訂履歴

| 日付 | 内容 |
|---|---|
| 2026-02-27 | 初版作成。メモ「友情コンビ登録システム.md」と既存実装の照合をもとに構想を整理 |
| 2026-02-27 | 正規パス確率方式（カウント式）、腐れ縁パス確率（4%）、ダメージ効率定義（身の丈超え≥1.0）確定 |
| 2026-02-27 | #6,8,9,10,11,12,13 確定。残り未決: #5（相性値閾値）、#7（再登場出現率） |
| 2026-02-27 | #5 廃止（既存フィルタで十分）、#7 廃止（自然混入方式で専用パラメータ不要）。全未決事項解消 |
| 2026-02-27 | §4.1 メンバー死亡/復活時の再登場ルール追記。§9 システムの意義・責務範囲・敵AIとの関係を追記 |
| 2026-02-27 | §5 全面改訂。コンビは解散しない方針に。最後の1人はソロで出現し続ける |
| 2026-02-27 | 構想書 → 仕様書に昇格。§3.3 登録判定詳細、§7 実装アーキテクチャ、§8 実装済みステータスを追記。コア実装完了 |
| 2026-03-01 | §3.3 結果倍率を全結果対応に変更（敵勝利×1.5、味方勝利/逃走×1.0）。グループ逃走経路（×2.0）追加 |
| 2026-03-01 | §3.3 グループ逃走の詳細追記: 連鎖逃走条件テーブル、パターン別判定、逃走フロー統合（2ターン→1ターン） |
| 2026-03-01 | §7.1 EscapeHandler.cs追加。§7.2 グループ逃走データフロー追加。§8.3 逃走フロー統合セクション追加 |
| 2026-03-01 | §9 未決事項 #14-#16 追加（2体グループ問題、演出、確率バランス） |
| 2026-03-01 | #14 解決: グループ逃走条件を「連鎖者≥1（合計2人以上逃走）」に変更。登録対象を全逃走者に拡大 |
| 2026-03-01 | §8.5 broken接続を実装。BattleManager.OnBattleEnd()からComboRegistry.MarkBroken()への反映 |
| 2026-03-01 | §6 ストーリー固定敵除外を実装。EncounterSO.isStoryEncounter + UnityBattleRunnerでComboRegistry非注入 |
