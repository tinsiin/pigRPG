# エフェクト配置システム設計書

## 1. 背景と課題

### 現状

エフェクトシステムは現在、再生の仕組み（EffectPlayer / EffectRenderer / ShapeDrawer）とエディタツール（KFX Editor / Effect Previewer）のみ。**バトルシステムとの紐づけはまだない**（スキル発動→エフェクト再生のような導線は未実装）。

エフェクトの配置は `EffectLayer.SetupRectTransform()` で常にアイコン中心に正方形で固定される:

```csharp
// 現在の配置ロジック
float shortSide = Mathf.Min(parentWidth, parentHeight);
rt.anchorMin = new Vector2(0.5f, 0.5f);
rt.anchorMax = new Vector2(0.5f, 0.5f);
rt.anchoredPosition = Vector2.zero;       // 常に中央
rt.sizeDelta = new Vector2(shortSide, shortSide);  // 常に正方形
```

### 課題

| 課題 | 説明 |
|------|------|
| **サイズ可変に未対応** | 敵アイコンはスプライトのピクセルサイズそのまま（可変）。エフェクトは短辺フィットの正方形で固定 |
| **位置調整ができない** | アイコンの「頭上」「足元」等にエフェクトをずらして配置できない |
| **はみ出すエフェクトが困難** | アイコンより大きい爆発・オーラ等が短辺に閉じ込められる |
| **全体エフェクト不可** | バトルフィールド全体にかかるエフェクト（全体攻撃・天候等）の描画先がない |

### 要件

1. **アイコン相対エフェクト**: オーバーサイズキャンバスで柔軟にデザインし、可変アイコンサイズに自動対応
2. **フィールドエフェクト**: EyeArea全体を基底とした、アイコンに依存しないエフェクト
3. 両方を**1つのGUIウィンドウ**でデザインできること（KFX / フレームベース問わず）

### スコープ

**今回作るもの:**
- エフェクトの配置位置を定義するシステム（icon_rect / field）
- 配置をGUIで設定するエディタウィンドウ
- ランタイムの配置計算ロジック

**今回作らないもの:**
- バトルスキルとエフェクトの紐づけ（「この技を使ったらこのエフェクトが出る」等の導線）
- エフェクトの中身（形状・アニメーション）の制作は既存のKFX Editor / テキスト編集の領分

---

## 2. 設計概要

2つの配置モードを導入する。エフェクトJSONの `"target"` フィールドで切り替える。

```
エフェクトJSON
"target": "icon" / "field"

┌─────────────────────────┐  ┌─────────────────────────┐
│     icon モード           │  │     field モード          │
│                          │  │                          │
│  キャンバス内に icon_rect  │  │  キャンバスが              │
│  を定義し、そこが実際の    │  │  ViewportArea全体に       │
│  アイコンに合うように      │  │  マッピングされる          │
│  スケーリング・配置される  │  │                          │
│                          │  │  アイコンに依存しない      │
│  描画先: BattleIconUI     │  │  描画先: ViewportArea     │
└─────────────────────────┘  └─────────────────────────┘
```

---

## 3. icon モード — アイコン相対エフェクト

### 3.1 核心: icon_rect

エフェクトキャンバスの中に **「ここが実際のアイコンに対応する領域」を示す参照矩形** を定義する。ランタイムではこの矩形が実際のアイコンサイズに合うようにキャンバス全体がスケーリング・配置される。

```
エフェクトキャンバス (200 x 200)
┌─────────────────────────────────────┐
│                                     │
│      余剰領域（はみ出し演出用）       │
│                                     │
│    ┌───────────────────────┐        │
│    │                       │        │
│    │    icon_rect           │        │
│    │    (70, 30, 60, 140)  │        │
│    │    ← アイコン想定領域   │        │
│    │                       │        │
│    └───────────────────────┘        │
│                                     │
│      余剰領域                        │
│                                     │
└─────────────────────────────────────┘
```

icon_rect の位置を変えるだけで、エフェクトのアイコン相対位置を自由に調整できる:

| icon_rect の配置 | 結果 |
|-----------------|------|
| キャンバス中央 | エフェクトがアイコンを中心に均等に広がる |
| キャンバス下寄り | エフェクトがアイコン上方（頭上）に展開 |
| キャンバス上寄り | エフェクトがアイコン下方（足元）に展開 |
| キャンバス右寄り | エフェクトがアイコン左方に展開 |

### 3.2 スケーリングロジック

```
入力:
  icon_actual  = 実際のアイコン Icon RectTransform のサイズ (w, h)
  icon_rect    = JSON定義の参照矩形 { x, y, width, height }
  canvas_size  = エフェクトキャンバスサイズ

1. スケール計算
   scale = Min(icon_actual.w / icon_rect.width,
               icon_actual.h / icon_rect.height)

2. RawImage の表示サイズ
   display_size = canvas_size * scale

3. オフセット計算（icon_rect中心をアイコン中心に合わせる）
   canvas_center   = canvas_size / 2
   icon_rect_center = (icon_rect.x + icon_rect.width/2,
                        icon_rect.y + icon_rect.height/2)
   offset = (canvas_center - icon_rect_center) * scale
   ※ Y軸はキャンバス座標(下向き)→RectTransform(上向き)の変換が必要

4. 配置
   rt.sizeDelta = (display_size, display_size)
   rt.anchoredPosition = offset  // アイコン中心基準
```

**可変アイコンサイズへの対応**: スケールは実アイコンサイズとicon_rectサイズの比率で決まるため、アイコンが大きくても小さくてもエフェクトが自動追従する。

### 3.3 icon_rect 省略時

icon_rect を省略した場合、キャンバス全体がアイコン領域として扱われる:
- `icon_rect = { x: 0, y: 0, width: canvas, height: canvas }`
- スケール = アイコン短辺 / canvas
- オフセット = (0, 0)（中央配置）

### 3.4 JSON仕様

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  "fps": 30,
  "duration": 0.8,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | `"icon"` | `"icon"` を指定（省略可） |
| `icon_rect` | object | null | アイコン参照矩形（省略時: キャンバス全体 = アイコン） |
| `icon_rect.x` | float | — | 参照矩形の左上X（キャンバス座標） |
| `icon_rect.y` | float | — | 参照矩形の左上Y（キャンバス座標） |
| `icon_rect.width` | float | — | 参照矩形の幅 |
| `icon_rect.height` | float | — | 参照矩形の高さ |

### 3.5 描画先

BattleIconUI の子に配置（現在と同じ階層）。`SetupRectTransform()` のロジックが icon_rect ベースに変わる。

```
BattleIconUI
├── Icon (アイコン画像)
├── HPBar
├── EffectLayer (既存)
│   └── Effect_xxx
│       └── RawImage (icon_rect でスケール・オフセット計算)
└── ...
```

---

## 4. field モード — フィールドエフェクト

### 4.1 概要

特定のアイコンに依存しない、バトルフィールド全体にかかるエフェクト。ViewportArea直下に専用レイヤーを設け、そこに描画する。

### 4.2 描画先

ViewportArea の子として EffectLayer を複数配置し、`field_layer` で描画順を指定する。

```
AlwaysCanvas
└── EyeArea
    └── ViewportArea
        ├── ZoomBackContainer
        ├── FieldEffectBack     ← 背景エフェクト（天候等）
        ├── MiddleFixedContainer
        ├── ZoomFrontContainer  (敵アイコン)
        ├── FieldEffectMiddle   ← 中間エフェクト（全体攻撃等）
        ├── FrontFixedContainer (味方アイコン)
        └── FieldEffectFront    ← 最前面エフェクト（フラッシュ等）
```

| field_layer | 挿入位置 | 用途例 |
|------------|---------|-------|
| `back` | ZoomBackContainer の直後 | 天候、フィールド変化 |
| `middle` | ZoomFrontContainer の直後 | 全体攻撃演出 |
| `front` | FrontFixedContainer の直後 | 画面フラッシュ、暗転 |

### 4.3 座標系

キャンバスがViewportArea矩形にフィットする。アスペクト比は維持しない。

```
ViewportArea (横長)
┌──────────────────────────────────┐
│  エフェクトキャンバス (100×100)    │
│  → ViewportArea全体に引き延ばし   │
│  (50,50) = 画面中央               │
└──────────────────────────────────┘
```

### 4.4 JSON仕様

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "field_layer": "front",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | — | `"field"` を指定 |
| `field_layer` | string | `"middle"` | 描画レイヤー（`back` / `middle` / `front`） |

### 4.5 API

```csharp
// フィールドエフェクト再生
EffectPlayer player = EffectManager.PlayField("screen_flash");
EffectPlayer player = EffectManager.PlayField("screen_flash", loop: true);

// フィールドエフェクト停止
EffectManager.StopField("screen_flash");
EffectManager.StopAllField();
```

---

## 5. エフェクトJSON 新規フィールドまとめ

| フィールド | 適用モード | 型 | デフォルト | 説明 |
|-----------|-----------|-----|-----------|------|
| `target` | 共通 | string | `"icon"` | 配置モード（`"icon"` / `"field"`） |
| `icon_rect` | icon | object | null | アイコン参照矩形（省略時: キャンバス全体） |
| `icon_rect.x` | icon | float | — | 左上X（キャンバス座標） |
| `icon_rect.y` | icon | float | — | 左上Y（キャンバス座標） |
| `icon_rect.width` | icon | float | — | 幅 |
| `icon_rect.height` | icon | float | — | 高さ |
| `field_layer` | field | string | `"middle"` | 描画レイヤー（`back` / `middle` / `front`） |

---

## 6. エディタ: Effect Placement Editor（新規ウィンドウ）

### 6.1 なぜ新規ウィンドウか

現在のエディタツールの役割:

| ツール | 役割 | 対応形式 |
|--------|------|---------|
| **KFX Editor** | KFXエフェクトの中身を制作（レイヤー・キーフレーム編集） | KFXのみ |
| **Effect Previewer** | エフェクトの再生確認（読み取り専用） | 両形式 |

配置メタデータ（target / icon_rect / field_layer）はエフェクトの**中身とは独立した設定**であり、KFX・フレームベース**両形式に共通**。これを KFX Editor と Effect Previewer の両方に実装するのは冗長。

→ **1つの専用ウィンドウ「Effect Placement Editor」** を新設し、全エフェクトの配置設定を一元管理する。

### 6.2 ツール構成（変更後）

```
┌─────────────────────────────────────────────────────────────┐
│  エフェクト制作フロー                                         │
│                                                              │
│  ① エフェクトの中身を作る                                     │
│     ├── KFX形式 → KFX Editor で制作                          │
│     └── フレームベース → テキストエディタ / AI生成              │
│                                                              │
│  ② 配置を設定する（共通）                                     │
│     └── Effect Placement Editor   ← 新規ウィンドウ            │
│         ・任意のエフェクトJSONを選択                            │
│         ・target / icon_rect / field_layer を編集             │
│         ・プレビュー + icon_rect オーバーレイ表示               │
│         ・保存（配置メタデータのみJSON書き戻し）                 │
│                                                              │
│  ③ 再生確認                                                   │
│     └── Effect Previewer（既存・変更なし）                     │
│                                                              │
│  ※ ②は③に統合してもよい（後述）                               │
└─────────────────────────────────────────────────────────────┘
```

### 6.3 Effect Placement Editor の機能

**メニュー**: Window → Effects → Effect Placement Editor

```
┌─ Effect Placement Editor ────────────────────────────────┐
│                                                           │
│  [エフェクト選択 ▼]  [Reload]                             │
│                                                           │
│  ┌─ 配置設定 ────────────────────┐                       │
│  │ Target:  [icon ▼]             │                       │
│  │                               │                       │
│  │ ── icon モード ──              │                       │
│  │ icon_rect:                    │                       │
│  │   x: [70]  y: [30]           │                       │
│  │   w: [60]  h: [140]          │                       │
│  │ [キャンバス全体にリセット]      │                       │
│  │                               │                       │
│  │ ── field モード（target=field時）│                     │
│  │ Layer: [middle ▼]             │                       │
│  └───────────────────────────────┘                       │
│                                                           │
│  ┌─ プレビュー ──────────────────────────────────────┐   │
│  │                                                    │   │
│  │    ╭─ ─ ─ ─ ─ ─ ─ ─╮                             │   │
│  │    ┆                  ┆  ← icon_rect 破線表示      │   │
│  │    ┆   (アイコン想定)  ┆    ドラッグで移動・リサイズ  │   │
│  │    ┆                  ┆                            │   │
│  │    ╰─ ─ ─ ─ ─ ─ ─ ─╯                             │   │
│  │         エフェクト描画                               │   │
│  │                                                    │   │
│  │  [▶ Play] [⏸ Pause] [■ Stop]  Speed: [1.0x]       │   │
│  └────────────────────────────────────────────────────┘   │
│                                                           │
│  [Save]                                                   │
└───────────────────────────────────────────────────────────┘
```

### 6.4 主要機能

| 機能 | 説明 |
|------|------|
| **エフェクト選択** | `Resources/Effects/` 内の全JSONをドロップダウンで一覧。KFX/フレームベース問わず |
| **target 切替** | icon / field のドロップダウン。切替に応じて下の設定パネルが変わる |
| **icon_rect 数値編集** | x / y / width / height のフィールド（target=icon 時のみ表示） |
| **icon_rect オーバーレイ** | プレビュー上に icon_rect を破線矩形で表示 |
| **icon_rect ドラッグ** | マウスで icon_rect の位置・サイズを直接ドラッグ編集 |
| **field_layer 選択** | back / middle / front のドロップダウン（target=field 時のみ表示） |
| **プレビュー再生** | エフェクトを再生。field モード時は横長アスペクト比に自動切替 |
| **Save** | 配置メタデータ（target / icon_rect / field_layer）のみJSON書き戻し。エフェクトの中身は変更しない |

### 6.5 保存の仕組み

Save時はJSONファイルを読み込み、配置関連フィールドのみ上書きして書き戻す:

```
読み込んだJSON
├── name, canvas, fps, duration, se, layers/frames ... → そのまま保持
├── target → 上書き
├── icon_rect → 上書き（null の場合はキーごと削除）
└── field_layer → 上書き（target=field 時のみ）
```

エフェクトの中身（layers, frames, keyframes等）には一切触れない。

### 6.6 既存ツールへの変更

| ツール | 変更 |
|--------|------|
| **KFX Editor** | 変更なし。配置設定はEffect Placement Editorに任せる |
| **Effect Previewer** | 変更なし |

---

## 7. ランタイム変更点

### 7.1 EffectDefinition の拡張

```csharp
// EffectDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; } = "icon";

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; } = "middle";
```

```csharp
// 新クラス（EffectDefinition.cs 内）
[Serializable]
public class IconRectDefinition
{
    [JsonProperty("x")] public float X { get; set; }
    [JsonProperty("y")] public float Y { get; set; }
    [JsonProperty("width")] public float Width { get; set; }
    [JsonProperty("height")] public float Height { get; set; }
}
```

### 7.2 EffectLayer.SetupRectTransform() の変更

```csharp
private void SetupRectTransform(RectTransform rt, EffectDefinition def)
{
    // アイコンの実サイズ取得（BattleIconUIのIcon RectTransformから）
    Vector2 iconSize = GetIconActualSize();

    int canvas = def.Canvas;

    if (def.IconRect != null)
    {
        // icon_rect ベースのスケーリング
        var ir = def.IconRect;
        float scale = Mathf.Min(iconSize.x / ir.Width, iconSize.y / ir.Height);
        float displaySize = canvas * scale;

        float canvasCenter = canvas / 2f;
        float irCenterX = ir.X + ir.Width / 2f;
        float irCenterY = ir.Y + ir.Height / 2f;

        // キャンバスY下向き → RectTransformY上向き 変換
        float offsetX = (canvasCenter - irCenterX) * scale;
        float offsetY = (irCenterY - canvasCenter) * scale;

        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(displaySize, displaySize);
        rt.anchoredPosition = new Vector2(offsetX, offsetY);
    }
    else
    {
        // icon_rect 省略: アイコン短辺にフィット
        float shortSide = Mathf.Min(iconSize.x, iconSize.y);
        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(shortSide, shortSide);
        rt.anchoredPosition = Vector2.zero;
    }
}
```

### 7.3 EffectManager の変更

```csharp
// EffectManager.cs

// フィールドエフェクトレイヤー参照
[SerializeField] private EffectLayer _fieldEffectBack;
[SerializeField] private EffectLayer _fieldEffectMiddle;
[SerializeField] private EffectLayer _fieldEffectFront;

// 既存 Play() 内部でターゲット分岐
private EffectPlayer PlayInternal(string effectName, BattleIconUI battleIconUI, bool loop)
{
    var definition = LoadDefinition(effectName);
    if (definition == null) return null;

    if (definition.Target == "field")
    {
        return PlayFieldInternal(definition, loop);
    }
    else
    {
        return PlayOnIconInternal(definition, battleIconUI, loop);
    }
}

// フィールドエフェクト専用API
public static EffectPlayer PlayField(string effectName, bool loop = false) { ... }
public static void StopField(string effectName) { ... }
public static void StopAllField() { ... }

private EffectPlayer PlayFieldInternal(EffectDefinition def, bool loop)
{
    var layer = def.FieldLayer switch
    {
        "back"  => _fieldEffectBack,
        "front" => _fieldEffectFront,
        _       => _fieldEffectMiddle,
    };
    return layer?.PlayEffect(def, loop);
}
```

### 7.4 KfxDefinition / KfxCompiler の変更

```csharp
// KfxDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; }

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; }
```

```csharp
// KfxCompiler.cs — コンパイル時にパススルー
result.Target = kfx.Target ?? "icon";
result.IconRect = kfx.IconRect;
result.FieldLayer = kfx.FieldLayer ?? "middle";
```

---

## 8. 使用例

### 例1: シンプルなヒットエフェクト（icon_rect 省略）

```json
{
  "format": "kfx",
  "name": "simple_hit",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [
    {
      "id": "flash",
      "type": "circle",
      "blend": "additive",
      "keyframes": [
        { "time": 0.0, "x": 50, "y": 50, "radius": 5, "brush": {"color": "#FFFFFF"} },
        { "time": 0.15, "radius": 40, "opacity": 0.8 },
        { "time": 0.3, "radius": 50, "opacity": 0.0 }
      ]
    }
  ]
}
```

`target` 省略 → `"icon"`、`icon_rect` 省略 → キャンバス全体 = アイコン。アイコン短辺にフィットして中央に描画。

### 例2: アイコン頭上にエフェクト（icon_rect を下寄りに）

```json
{
  "format": "kfx",
  "name": "heal_sparkle",
  "target": "icon",
  "icon_rect": { "x": 20, "y": 60, "width": 60, "height": 90 },
  "canvas": 150,
  ...
}
```

150×150キャンバスの下部(20,60,60,90)がアイコン。キャンバス上部に描いたエフェクトがアイコンの頭上に出る。
icon_rectスケーリングにより、200x300のアイコンでも100x150のアイコンでも同じ見た目。

### 例3: アイコンからはみ出す大爆発

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  ...
}
```

200×200キャンバスの中央に爆発、icon_rect (60×140) がアイコンに合うようにスケールされるので、爆発はアイコンの外まで大きくはみ出す。

### 例4: 画面全体フラッシュ（field）

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "field_layer": "front",
  "canvas": 100,
  ...
}
```

ViewportArea最前面に画面全体をカバーする白フラッシュ。

### 例5: 背景の天候エフェクト（field）

```json
{
  "format": "kfx",
  "name": "dark_atmosphere",
  "target": "field",
  "field_layer": "back",
  "canvas": 100,
  ...
}
```

背景レイヤーに暗い霧。ループ再生。

---

## 9. 実装の影響範囲

### 変更が必要なファイル

| ファイル | 変更内容 |
|---------|---------|
| `Effects/Core/EffectDefinition.cs` | `Target`, `IconRect`, `FieldLayer` フィールド + `IconRectDefinition` クラス追加 |
| `Effects/Core/KfxDefinition.cs` | 同フィールド追加 |
| `Effects/Core/KfxCompiler.cs` | 新フィールドのパススルー |
| `Effects/Integration/EffectLayer.cs` | `SetupRectTransform()` を icon_rect 対応に変更。アイコン実サイズ取得メソッド追加 |
| `Effects/Integration/EffectManager.cs` | target 分岐、`PlayField()` / `StopField()` / `StopAllField()` API追加 |

### 新規ファイル

| ファイル | 役割 |
|---------|------|
| `Editor/Effects/EffectPlacementEditor.cs` | Effect Placement Editor ウィンドウ |

### シーン変更

| 対象 | 変更内容 |
|------|---------|
| ViewportArea | FieldEffectBack / FieldEffectMiddle / FieldEffectFront（EffectLayer付き空GameObject）を適切な位置に挿入 |

### 変更しないファイル

| ファイル | 理由 |
|---------|------|
| `Editor/Effects/KfxEditorWindow.cs` | 配置設定はEffect Placement Editorに集約 |
| `Editor/Effects/KfxEditorWindow.Drawing.cs` | 同上 |
| `Editor/Effects/EffectPreviewWindow.cs` | 同上 |
| `EYEAREA_UI/BattleIconUI.cs` | アンカーポイント不要（icon_rectで代替） |

---

## 10. 段階的実装の提案

| 段階 | 内容 | 依存 |
|------|------|------|
| **Phase 1** | EffectDefinition / KfxDefinition に新フィールド追加。KfxCompiler パススルー | なし |
| **Phase 2** | EffectLayer の icon_rect 対応（スケーリング・オフセット計算） | Phase 1 |
| **Phase 3** | field モード対応（ViewportArea に EffectLayer 配置 + EffectManager.PlayField() API） | Phase 1 |
| **Phase 4** | Effect Placement Editor ウィンドウ（エフェクト選択 + target/icon_rect/field_layer 編集 + プレビュー + icon_rect オーバーレイ + Save） | Phase 1, 2, 3 |
