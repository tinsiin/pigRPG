# エフェクト配置システム設計書

## 1. 背景と課題

### 現状

エフェクトシステムは現在、再生の仕組み（EffectPlayer / EffectRenderer / ShapeDrawer）とエディタツール（KFX Editor / Effect Previewer）のみ。**バトルシステムとの紐づけはまだない**（スキル発動→エフェクト再生のような導線は未実装）。

エフェクトの配置は `EffectLayer.SetupRectTransform()` で常にアイコン中心に正方形で固定される:

```csharp
// 現在の配置ロジック
float shortSide = Mathf.Min(parentWidth, parentHeight);
rt.anchorMin = new Vector2(0.5f, 0.5f);
rt.anchorMax = new Vector2(0.5f, 0.5f);
rt.anchoredPosition = Vector2.zero;       // 常に中央
rt.sizeDelta = new Vector2(shortSide, shortSide);  // 常に正方形
```

### 課題

| 課題 | 説明 |
|------|------|
| **サイズ可変に未対応** | 敵アイコンはスプライトのピクセルサイズそのまま（可変）。エフェクトは短辺フィットの正方形で固定 |
| **位置調整ができない** | アイコンの「頭上」「足元」等にエフェクトをずらして配置できない |
| **はみ出すエフェクトが困難** | アイコンより大きい爆発・オーラ等が短辺に閉じ込められる |
| **全体エフェクト不可** | バトルフィールド全体にかかるエフェクト（全体攻撃・天候等）の描画先がない |

### 要件

1. **アイコン相対エフェクト**: オーバーサイズキャンバスで柔軟にデザインし、可変アイコンサイズに自動対応
2. **フィールドエフェクト**: EyeArea全体を基底とした、アイコンに依存しないエフェクト
3. 両方を**1つのGUIウィンドウ**でデザインできること（KFX / フレームベース問わず）

### スコープ

**今回作るもの:**
- エフェクトの配置位置を定義するシステム（icon_rect / field）
- 配置をGUIで設定するエディタウィンドウ
- ランタイムの配置計算ロジック

**今回作らないもの:**
- バトルスキルとエフェクトの紐づけ（「この技を使ったらこのエフェクトが出る」等の導線）
- エフェクトの中身（形状・アニメーション）の制作は既存のKFX Editor / テキスト編集の領分

---

## 2. 設計概要

2つの配置モードを導入する。エフェクトJSONの `"target"` フィールドで切り替える。

```
エフェクトJSON
"target": "icon" / "field"

┌─────────────────────────┐  ┌─────────────────────────┐
│     icon モード           │  │     field モード          │
│                          │  │                          │
│  キャンバス内に icon_rect  │  │  キャンバスが              │
│  を定義し、そこが実際の    │  │  ViewportArea全体に       │
│  アイコンに合うように      │  │  マッピングされる          │
│  スケーリング・配置される  │  │                          │
│                          │  │  アイコンに依存しない      │
│  描画先: BattleIconUI     │  │  描画先: ViewportArea     │
└─────────────────────────┘  └─────────────────────────┘
```

---

## 3. icon モード — アイコン相対エフェクト

### 3.1 核心: icon_rect

エフェクトキャンバスの中に **「ここが実際のアイコンに対応する領域」を示す参照矩形** を定義する。ランタイムではこの矩形が実際のアイコンサイズに合うようにキャンバス全体がスケーリング・配置される。

```
エフェクトキャンバス (200 x 200)
┌─────────────────────────────────────┐
│                                     │
│      余剰領域（はみ出し演出用）       │
│                                     │
│    ┌───────────────────────┐        │
│    │                       │        │
│    │    icon_rect           │        │
│    │    (70, 30, 60, 140)  │        │
│    │    ← アイコン想定領域   │        │
│    │                       │        │
│    └───────────────────────┘        │
│                                     │
│      余剰領域                        │
│                                     │
└─────────────────────────────────────┘
```

### 3.2 2つの視点 — データとエディタ

icon_rect を理解するうえで重要なのは、**同じデータを2つの視点で捉えられる**こと。

#### データ視点（JSON / ランタイム）

「正方形キャンバスの中で、icon_rect の矩形がアイコンに対応する」

- icon_rect を**キャンバス下寄り**に置く → アイコンの**上方**にエフェクトが展開
- icon_rect を**小さく**する → アイコンに対してエフェクトが**大きく**はみ出す

#### エディタ視点（人間のデザイン操作）

「アイコンを固定の基準にして、エフェクトを配置する」

- エフェクトを**上に動かす** → 結果的にicon_rectはキャンバス内で**下に移動**
- エフェクトを**大きくする** → 結果的にicon_rectのキャンバスに対する**比率が小さくなる**

**これらは数学的に逆変換の関係** であり、データの形式は同じ。エディタは人間にとって直感的な「エフェクトを動かす」操作を提供し、内部的にicon_rect座標に変換して保存する。

```
  エディタ操作                              データへの変換
┌──────────────────┐                  ┌──────────────────┐
│                    │                  │                    │
│  エフェクト↑移動    │  ← 逆変換 →    │  icon_rect.y ↑増加  │
│  エフェクト←移動    │  ← 逆変換 →    │  icon_rect.x ↑増加  │
│  エフェクト拡大     │  ← 逆変換 →    │  icon_rect比率 縮小  │
│                    │                  │                    │
└──────────────────┘                  └──────────────────┘
```

### 3.3 スケーリングロジック

```
入力:
  icon_actual  = 実際のアイコン Icon RectTransform のサイズ (w, h)
  icon_rect    = JSON定義の参照矩形 { x, y, width, height }
  canvas_size  = エフェクトキャンバスサイズ

1. スケール計算
   scale = Min(icon_actual.w / icon_rect.width,
               icon_actual.h / icon_rect.height)

2. RawImage の表示サイズ
   display_size = canvas_size * scale

3. オフセット計算（icon_rect中心をアイコン中心に合わせる）
   canvas_center   = canvas_size / 2
   icon_rect_center = (icon_rect.x + icon_rect.width/2,
                        icon_rect.y + icon_rect.height/2)
   offset = (canvas_center - icon_rect_center) * scale
   ※ Y軸はキャンバス座標(下向き)→RectTransform(上向き)の変換が必要

4. 配置
   rt.sizeDelta = (display_size, display_size)
   rt.anchoredPosition = offset  // アイコン中心基準
```

**可変アイコンサイズへの対応**: スケールは実アイコンサイズとicon_rectサイズの比率で決まるため、アイコンが大きくても小さくてもエフェクトが自動追従する。

### 3.4 icon_rect 省略時

icon_rect を省略した場合、キャンバス全体がアイコン領域として扱われる:
- `icon_rect = { x: 0, y: 0, width: canvas, height: canvas }`
- スケール = アイコン短辺 / canvas
- オフセット = (0, 0)（中央配置）

### 3.5 JSON仕様

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  "fps": 30,
  "duration": 0.8,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | `"icon"` | `"icon"` を指定（省略可） |
| `icon_rect` | object | null | アイコン参照矩形（省略時: キャンバス全体 = アイコン） |
| `icon_rect.x` | float | — | 参照矩形の左上X（キャンバス座標） |
| `icon_rect.y` | float | — | 参照矩形の左上Y（キャンバス座標） |
| `icon_rect.width` | float | — | 参照矩形の幅 |
| `icon_rect.height` | float | — | 参照矩形の高さ |

### 3.6 描画先

BattleIconUI の子に配置（現在と同じ階層）。`SetupRectTransform()` のロジックが icon_rect ベースに変わる。

```
BattleIconUI
├── Icon (アイコン画像)
├── HPBar
├── EffectLayer (既存)
│   └── Effect_xxx
│       └── RawImage (icon_rect でスケール・オフセット計算)
└── ...
```

---

## 4. field モード — フィールドエフェクト

### 4.1 概要

特定のアイコンに依存しない、バトルフィールド全体にかかるエフェクト。ViewportArea直下に1つの専用レイヤーを設け、敵・味方アイコンの両方の上に描画する。

### 4.2 描画先

ViewportArea の子として FieldEffectLayer を FrontFixedContainer の直後に1つだけ配置する。

```
AlwaysCanvas
└── EyeArea
    └── ViewportArea
        ├── ZoomBackContainer      (背景、演出ズームされる)
        ├── MiddleFixedContainer   (ActionMark等、固定)
        ├── ZoomFrontContainer     (敵アイコン、演出ズームされる)
        ├── FrontFixedContainer    (味方アイコン、固定)
        ├── FieldEffectLayer       ← フィールドエフェクト（敵味方の上）
        ├── BSAmanager
        └── SchizoLog
```

**ズームとの関係:**
- **K-Zoom**: ViewportArea 親ごとスケールするため、FieldEffectLayer もズームされる
- **演出ズーム**: ZoomBack/ZoomFront のみ個別スケール。FieldEffectLayer は直接対象外だが、画面全体にかかるエフェクトなので問題ない

### 4.3 座標系

キャンバスがViewportArea矩形にフィットする。アスペクト比は維持しない。

```
ViewportArea (横長)
┌──────────────────────────────────┐
│  エフェクトキャンバス (100×100)    │
│  → ViewportArea全体に引き延ばし   │
│  (50,50) = 画面中央               │
└──────────────────────────────────┘
```

### 4.4 JSON仕様

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | — | `"field"` を指定 |

### 4.5 API

```csharp
// フィールドエフェクト再生
EffectPlayer player = EffectManager.PlayField("screen_flash");
EffectPlayer player = EffectManager.PlayField("screen_flash", loop: true);

// フィールドエフェクト停止
EffectManager.StopField("screen_flash");
EffectManager.StopAllField();
```

---

## 5. エフェクトJSON 新規フィールドまとめ

| フィールド | 適用モード | 型 | デフォルト | 説明 |
|-----------|-----------|-----|-----------|------|
| `target` | 共通 | string | `"icon"` | 配置モード（`"icon"` / `"field"`） |
| `icon_rect` | icon | object | null | アイコン参照矩形（省略時: キャンバス全体） |
| `icon_rect.x` | icon | float | — | 左上X（キャンバス座標） |
| `icon_rect.y` | icon | float | — | 左上Y（キャンバス座標） |
| `icon_rect.width` | icon | float | — | 幅 |
| `icon_rect.height` | icon | float | — | 高さ |

---

## 6. エディタ: Effect Placement Editor

### 6.1 設計思想

**「アイコンを固定基準にして、エフェクトの位置・サイズを操作する」** がエディタの基本コンセプト。

ユーザーにとって自然な操作:
- 「エフェクトを頭上に配置したい」→ エフェクトを上に動かす
- 「エフェクトを大きくはみ出させたい」→ エフェクトを拡大する

内部的には、この操作がicon_rect座標に逆変換されてJSONに保存される（Section 3.2 参照）。

### 6.2 なぜ新規ウィンドウか

現在のエディタツールの役割:

| ツール | 役割 | 対応形式 |
|--------|------|---------|
| **KFX Editor** | KFXエフェクトの中身を制作（レイヤー・キーフレーム編集） | KFXのみ |
| **Effect Previewer** | エフェクトの再生確認（読み取り専用） | 両形式 |

配置メタデータ（target / icon_rect）はエフェクトの**中身とは独立した設定**であり、KFX・フレームベース**両形式に共通**。

→ **1つの専用ウィンドウ「Effect Placement Editor」** を新設し、全エフェクトの配置設定を一元管理する。

### 6.3 ツール構成

```
┌─────────────────────────────────────────────────────────────┐
│  エフェクト制作フロー                                         │
│                                                              │
│  ① エフェクトの中身を作る                                     │
│     ├── KFX形式 → KFX Editor で制作                          │
│     └── フレームベース → テキストエディタ / AI生成              │
│                                                              │
│  ② 配置を設定する（共通）                                     │
│     └── Effect Placement Editor                              │
│         ・任意のエフェクトJSONを選択                            │
│         ・target / エフェクト位置・サイズ を編集                │
│         ・プレビュー + 実機プレビュー表示                       │
│         ・保存（配置メタデータのみJSON書き戻し）                 │
│                                                              │
│  ③ 再生確認                                                   │
│     └── Effect Previewer（既存・変更なし）                     │
└─────────────────────────────────────────────────────────────┘
```

### 6.4 エディタ画面構成

**メニュー**: Window → Effects → Effect Placement Editor

エディタは3つの主要エリアで構成される:

#### A. キャンバスプレビュー（左側）

エフェクトの正方形キャンバスを表示し、その中で**アイコン（灰色矩形）を中央固定の基準**として、**エフェクトの位置・サイズ（緑色枠）をドラッグ操作**する。

```
┌─ キャンバスプレビュー ─────────────────────┐
│                                            │
│   ┌─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┐       │
│   ┆  緑色枠 = エフェクトキャンバス   ┆       │
│   ┆                               ┆       │
│   ┆      ┌──────────────┐        ┆       │
│   ┆      │ 灰色 = アイコン │        ┆       │
│   ┆      │ （中央固定）    │        ┆       │
│   ┆      └──────────────┘        ┆       │
│   ┆                               ┆       │
│   └─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┘       │
│                                            │
│  ドラッグ: 緑色枠を移動 = エフェクト位置変更  │
│  辺ドラッグ: 緑色枠のサイズ変更              │
└────────────────────────────────────────────┘
```

**操作と内部変換の対応:**

| エディタ上の操作 | 見た目の変化 | icon_rect への変換 |
|-----------------|-------------|-------------------|
| 緑色枠を**上**に移動 | エフェクトがアイコンの上方に移動 | icon_rect.y が**増加**（キャンバス内で下方に） |
| 緑色枠を**左**に移動 | エフェクトがアイコンの左方に移動 | icon_rect.x が**増加**（キャンバス内で右方に） |
| 緑色枠を**拡大** | エフェクトがアイコンに対して大きくなる | icon_rect の幅/高さの**キャンバスに対する比率が縮小** |
| 緑色枠を**中央にリセット** | エフェクト中心 = アイコン中心 | icon_rect がキャンバス中央に配置 |

#### B. 実機プレビュー（右側）

実際のアイコンサイズ（味方固定 / 敵可変）でエフェクトを再生表示。icon_rect によるスケーリング・オフセットが適用された最終的な見た目を確認できる。

```
┌─ 実機プレビュー ──────────────┐
│                                │
│    ┌────────────────┐         │
│    │  アイコン        │         │
│    │  ┌────────────┐│         │
│    │  │エフェクト     ││         │
│    │  │(スケール適用) ││         │
│    │  └────────────┘│         │
│    └────────────────┘         │
│                                │
│  [▶] [⏸] [■]  Speed: [1.0x]  │
│  [|◀] [◀] [▶] [▶|]           │
│  Frame: 12/45  Time: 0.40s    │
└────────────────────────────────┘
```

#### C. 設定パネル（上部）

```
┌─ 設定 ───────────────────────────────────────────┐
│  [エフェクト選択 ▼]  [Reload]                      │
│                                                    │
│  Target: [icon ▼]                                  │
│                                                    │
│  ── icon モード ──                                  │
│  アイコンプリセット: [味方(169x257) ▼]               │
│  アイコン参照比率: [0.4]                             │
│                                                    │
│  icon_rect: x=[14.7] y=[29.1] w=[71.3] h=[67.5]   │
│  [キャンバス全体にリセット]  [Save]  [Revert]        │
└────────────────────────────────────────────────────┘
```

### 6.5 主要機能

| 機能 | 説明 |
|------|------|
| **エフェクト選択** | `Resources/Effects/` 内の全JSONをドロップダウンで一覧。KFX/フレームベース問わず |
| **target 切替** | icon / field のドロップダウン。切替に応じて下の設定パネルが変わる |
| **エフェクト位置ドラッグ** | キャンバスプレビュー上で緑色枠をドラッグ → エフェクト位置を直感的に操作（内部でicon_rectに逆変換） |
| **エフェクトサイズ変更** | 緑色枠の辺をドラッグ → エフェクトのアイコンに対する相対サイズを変更 |
| **icon_rect 数値編集** | x / y / width / height のフィールドで直接編集も可能（target=icon 時のみ表示） |
| **アイコンプリセット** | 実機プレビューで使用するモックアイコンサイズ（味方固定 / 各種敵サイズ） |
| **実機プレビュー再生** | エフェクトをicon_rectスケーリング適用で再生。最終的な見た目を確認 |
| **フレームステップ** | 1フレームずつ進む/戻る、先頭/末尾ジャンプ |
| **Save** | 配置メタデータ（target / icon_rect）のみJSON書き戻し。エフェクトの中身は変更しない |

### 6.6 キャンバスプレビューの座標変換

キャンバスプレビューでは、**アイコン（灰色矩形）を中央に固定**し、**エフェクトキャンバス（緑色枠）を相対的に配置**する。

ユーザーが緑色枠をドラッグした際、以下の変換でicon_rect座標を算出する:

```
エディタ空間:
  icon_center = プレビュー中央（固定）
  effect_rect = 緑色枠の矩形（ユーザーがドラッグで操作）

icon_rect への変換:
  canvas = エフェクトキャンバスサイズ

  緑色枠内でのアイコンの相対位置 = icon_center - effect_rect.topLeft

  icon_rect.x = (icon_center.x - effect_rect.left) / effect_rect.width * canvas
  icon_rect.y = (icon_center.y - effect_rect.top) / effect_rect.height * canvas
  icon_rect.width  = icon_display_width / effect_rect.width * canvas
  icon_rect.height = icon_display_height / effect_rect.height * canvas
```

**逆方向（icon_rect → 緑色枠の表示位置）:**

```
icon_rect → エディタ表示:
  effect_scale = icon_display_size / icon_rect_size
  effect_display_size = canvas * effect_scale
  effect_offset = icon_center - (icon_rect_center_in_canvas * effect_scale)
```

### 6.7 保存の仕組み

Save時はJSONファイルを読み込み、配置関連フィールドのみ上書きして書き戻す:

```
読み込んだJSON
├── name, canvas, fps, duration, se, layers/frames ... → そのまま保持
├── target → 上書き
└── icon_rect → 上書き（null の場合はキーごと削除）
```

エフェクトの中身（layers, frames, keyframes等）には一切触れない。

### 6.8 既存ツールへの変更

| ツール | 変更 |
|--------|------|
| **KFX Editor** | 変更なし。配置設定はEffect Placement Editorに任せる |
| **Effect Previewer** | 変更なし |

---

## 7. ランタイム変更点

### 7.1 EffectDefinition の拡張

```csharp
// EffectDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; } = "icon";

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; } = "middle";
```

```csharp
// 新クラス（EffectDefinition.cs 内）
[Serializable]
public class IconRectDefinition
{
    [JsonProperty("x")] public float X { get; set; }
    [JsonProperty("y")] public float Y { get; set; }
    [JsonProperty("width")] public float Width { get; set; }
    [JsonProperty("height")] public float Height { get; set; }
}
```

### 7.2 EffectLayer.SetupRectTransform() の変更

```csharp
private void SetupRectTransform(RectTransform rt, EffectDefinition def)
{
    // アイコンの実サイズ取得（BattleIconUIのIcon RectTransformから）
    Vector2 iconSize = GetIconActualSize();

    int canvas = def.Canvas;

    if (def.IconRect != null)
    {
        // icon_rect ベースのスケーリング
        var ir = def.IconRect;
        float scale = Mathf.Min(iconSize.x / ir.Width, iconSize.y / ir.Height);
        float displaySize = canvas * scale;

        float canvasCenter = canvas / 2f;
        float irCenterX = ir.X + ir.Width / 2f;
        float irCenterY = ir.Y + ir.Height / 2f;

        // キャンバスY下向き → RectTransformY上向き 変換
        float offsetX = (canvasCenter - irCenterX) * scale;
        float offsetY = (irCenterY - canvasCenter) * scale;

        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(displaySize, displaySize);
        rt.anchoredPosition = new Vector2(offsetX, offsetY);
    }
    else
    {
        // icon_rect 省略: アイコン短辺にフィット
        float shortSide = Mathf.Min(iconSize.x, iconSize.y);
        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(shortSide, shortSide);
        rt.anchoredPosition = Vector2.zero;
    }
}
```

### 7.3 EffectManager の変更

```csharp
// EffectManager.cs

// フィールドエフェクトレイヤー参照
[SerializeField] private EffectLayer _fieldEffectBack;
[SerializeField] private EffectLayer _fieldEffectMiddle;
[SerializeField] private EffectLayer _fieldEffectFront;

// 既存 Play() 内部でターゲット分岐
private EffectPlayer PlayInternal(string effectName, BattleIconUI battleIconUI, bool loop)
{
    var definition = LoadDefinition(effectName);
    if (definition == null) return null;

    if (definition.Target == "field")
    {
        return PlayFieldInternal(definition, loop);
    }
    else
    {
        return PlayOnIconInternal(definition, battleIconUI, loop);
    }
}

// フィールドエフェクト専用API
public static EffectPlayer PlayField(string effectName, bool loop = false) { ... }
public static void StopField(string effectName) { ... }
public static void StopAllField() { ... }

private EffectPlayer PlayFieldInternal(EffectDefinition def, bool loop)
{
    var layer = def.FieldLayer switch
    {
        "back"  => _fieldEffectBack,
        "front" => _fieldEffectFront,
        _       => _fieldEffectMiddle,
    };
    return layer?.PlayEffect(def, loop);
}
```

### 7.4 KfxDefinition / KfxCompiler の変更

```csharp
// KfxDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; }

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; }
```

```csharp
// KfxCompiler.cs — コンパイル時にパススルー
result.Target = kfx.Target ?? "icon";
result.IconRect = kfx.IconRect;
result.FieldLayer = kfx.FieldLayer ?? "middle";
```

---

## 8. 使用例

### 例1: シンプルなヒットエフェクト（icon_rect 省略）

```json
{
  "format": "kfx",
  "name": "simple_hit",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [
    {
      "id": "flash",
      "type": "circle",
      "blend": "additive",
      "keyframes": [
        { "time": 0.0, "x": 50, "y": 50, "radius": 5, "brush": {"color": "#FFFFFF"} },
        { "time": 0.15, "radius": 40, "opacity": 0.8 },
        { "time": 0.3, "radius": 50, "opacity": 0.0 }
      ]
    }
  ]
}
```

`target` 省略 → `"icon"`、`icon_rect` 省略 → キャンバス全体 = アイコン。アイコン短辺にフィットして中央に描画。

### 例2: アイコン頭上にエフェクト

**エディタでの操作**: エフェクトを上方向にドラッグ

**結果のJSON** (icon_rect がキャンバス下寄りに):

```json
{
  "format": "kfx",
  "name": "heal_sparkle",
  "target": "icon",
  "icon_rect": { "x": 20, "y": 60, "width": 60, "height": 90 },
  "canvas": 150,
  ...
}
```

150×150キャンバスの下部(20,60,60,90)がアイコン対応領域。エフェクトのキャンバス上部に描いた演出がアイコンの頭上に出る。icon_rectスケーリングにより、200x300のアイコンでも100x150のアイコンでも同じ見た目。

### 例3: アイコンからはみ出す大爆発

**エディタでの操作**: エフェクトを大きく拡大（緑色枠をアイコンより大きく広げる）

**結果のJSON** (icon_rect がキャンバスに対して小さい):

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  ...
}
```

200×200キャンバスの中央に爆発、icon_rect (60×140) がアイコンに合うようにスケールされるので、爆発はアイコンの外まで大きくはみ出す。

### 例4: 画面全体フラッシュ（field）

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "field_layer": "front",
  "canvas": 100,
  ...
}
```

ViewportArea最前面に画面全体をカバーする白フラッシュ。

### 例5: 背景の天候エフェクト（field）

```json
{
  "format": "kfx",
  "name": "dark_atmosphere",
  "target": "field",
  "field_layer": "back",
  "canvas": 100,
  ...
}
```

背景レイヤーに暗い霧。ループ再生。

---

## 9. 実装の影響範囲

### 変更が必要なファイル

| ファイル | 変更内容 |
|---------|---------|
| `Effects/Core/EffectDefinition.cs` | `Target`, `IconRect`, `FieldLayer` フィールド + `IconRectDefinition` クラス追加 |
| `Effects/Core/KfxDefinition.cs` | 同フィールド追加 |
| `Effects/Core/KfxCompiler.cs` | 新フィールドのパススルー |
| `Effects/Integration/EffectLayer.cs` | `SetupRectTransform()` を icon_rect 対応に変更。アイコン実サイズ取得メソッド追加 |
| `Effects/Integration/EffectManager.cs` | target 分岐、`PlayField()` / `StopField()` / `StopAllField()` API追加 |

### 新規ファイル

| ファイル | 役割 |
|---------|------|
| `Editor/Effects/EffectPlacementEditor.cs` | Effect Placement Editor ウィンドウ |

### シーン変更

| 対象 | 変更内容 |
|------|---------|
| ViewportArea | FieldEffectLayer（EffectLayer付き空GameObject）を FrontFixedContainer の直後に挿入 |

### 変更しないファイル

| ファイル | 理由 |
|---------|------|
| `Editor/Effects/KfxEditorWindow.cs` | 配置設定はEffect Placement Editorに集約 |
| `Editor/Effects/KfxEditorWindow.Drawing.cs` | 同上 |
| `Editor/Effects/EffectPreviewWindow.cs` | 同上 |
| `EYEAREA_UI/BattleIconUI.cs` | アンカーポイント不要（icon_rectで代替） |

---

## 10. 段階的実装の提案

| 段階 | 内容 | 依存 |
|------|------|------|
| **Phase 1** | EffectDefinition / KfxDefinition に新フィールド追加。KfxCompiler パススルー | なし |
| **Phase 2** | EffectLayer の icon_rect 対応（スケーリング・オフセット計算） | Phase 1 |
| **Phase 3** | field モード対応（ViewportArea に EffectLayer 配置 + EffectManager.PlayField() API） | Phase 1 |
| **Phase 4** | Effect Placement Editor ウィンドウ（エフェクト選択 + エフェクト位置/サイズ編集 + 実機プレビュー + icon_rect逆変換 + Save） | Phase 1, 2, 3 |
