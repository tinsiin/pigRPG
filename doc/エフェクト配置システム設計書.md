# エフェクト配置システム設計書

## 1. 背景と課題

### 現状

エフェクトシステムは現在、再生の仕組み（EffectPlayer / EffectRenderer / ShapeDrawer）とエディタツール（KFX Editor / Effect Previewer）のみ。**バトルシステムとの紐づけはまだない**（スキル発動→エフェクト再生のような導線は未実装）。

エフェクトの配置は `EffectLayer.SetupRectTransform()` で常にアイコン中心に正方形で固定される:

```csharp
// 現在の配置ロジック
float shortSide = Mathf.Min(parentWidth, parentHeight);
rt.anchorMin = new Vector2(0.5f, 0.5f);
rt.anchorMax = new Vector2(0.5f, 0.5f);
rt.anchoredPosition = Vector2.zero;       // 常に中央
rt.sizeDelta = new Vector2(shortSide, shortSide);  // 常に正方形
```

### 課題

| 課題 | 説明 |
|------|------|
| **サイズ可変に未対応** | 敵アイコンはスプライトのピクセルサイズそのまま（可変）。エフェクトは短辺フィットの正方形で固定 |
| **位置調整ができない** | アイコンの「頭上」「足元」等にエフェクトをずらして配置できない |
| **はみ出すエフェクトが困難** | アイコンより大きい爆発・オーラ等が短辺に閉じ込められる |
| **全体エフェクト不可** | バトルフィールド全体にかかるエフェクト（全体攻撃・天候等）の描画先がない |

### 要件

1. **アイコン相対エフェクト**: オーバーサイズキャンバスで柔軟にデザインし、可変アイコンサイズに自動対応
2. **フィールドエフェクト**: EyeArea全体を基底とした、アイコンに依存しないエフェクト
3. 両方を**1つのGUIウィンドウ**でデザインできること（KFX / フレームベース問わず）

### スコープ

**今回作るもの:**
- エフェクトの配置位置を定義するシステム（icon_rect / field）
- 配置をGUIで設定するエディタウィンドウ
- ランタイムの配置計算ロジック

**今回作らないもの:**
- バトルスキルとエフェクトの紐づけ（「この技を使ったらこのエフェクトが出る」等の導線）
- エフェクトの中身（形状・アニメーション）の制作は既存のKFX Editor / テキスト編集の領分

---

## 2. 設計概要

2つの配置モードを導入する。エフェクトJSONの `"target"` フィールドで切り替える。

```
エフェクトJSON
"target": "icon" / "field"

┌─────────────────────────┐  ┌─────────────────────────┐
│     icon モード           │  │     field モード          │
│                          │  │                          │
│  キャンバス内に icon_rect  │  │  キャンバスが              │
│  を定義し、そこが実際の    │  │  ViewportArea全体に       │
│  アイコンに合うように      │  │  マッピングされる          │
│  スケーリング・配置される  │  │                          │
│                          │  │  アイコンに依存しない      │
│  描画先: BattleIconUI     │  │  描画先: ViewportArea     │
└─────────────────────────┘  └─────────────────────────┘
```

---

## 3. icon モード — アイコン相対エフェクト

### 3.1 核心: icon_rect

エフェクトキャンバスの中に **「ここが実際のアイコンに対応する領域」を示す参照矩形** を定義する。ランタイムではこの矩形が実際のアイコンサイズに合うようにキャンバス全体がスケーリング・配置される。

```
エフェクトキャンバス (200 x 200)
┌─────────────────────────────────────┐
│                                     │
│      余剰領域（はみ出し演出用）       │
│                                     │
│    ┌───────────────────────┐        │
│    │                       │        │
│    │    icon_rect           │        │
│    │    (70, 30, 60, 140)  │        │
│    │    ← アイコン想定領域   │        │
│    │                       │        │
│    └───────────────────────┘        │
│                                     │
│      余剰領域                        │
│                                     │
└─────────────────────────────────────┘
```

### 3.2 2つの視点 — データとエディタ

icon_rect を理解するうえで重要なのは、**同じデータを2つの視点で捉えられる**こと。

#### データ視点（JSON / ランタイム）

「正方形キャンバスの中で、icon_rect の矩形がアイコンに対応する」

- icon_rect を**キャンバス下寄り**に置く → アイコンの**上方**にエフェクトが展開
- icon_rect を**小さく**する → アイコンに対してエフェクトが**大きく**はみ出す

#### エディタ視点（人間のデザイン操作）

「アイコンを固定の基準にして、エフェクトを配置する」

- エフェクトを**上に動かす** → 結果的にicon_rectはキャンバス内で**下に移動**
- エフェクトを**大きくする** → 結果的にicon_rectのキャンバスに対する**比率が小さくなる**

**これらは数学的に逆変換の関係** であり、データの形式は同じ。エディタは人間にとって直感的な「エフェクトを動かす」操作を提供し、内部的にicon_rect座標に変換して保存する。

```
  エディタ操作                              データへの変換
┌──────────────────┐                  ┌──────────────────┐
│                    │                  │                    │
│  エフェクト↑移動    │  ← 逆変換 →    │  icon_rect.y ↑増加  │
│  エフェクト←移動    │  ← 逆変換 →    │  icon_rect.x ↑増加  │
│  エフェクト拡大     │  ← 逆変換 →    │  icon_rect比率 縮小  │
│                    │                  │                    │
└──────────────────┘                  └──────────────────┘
```

### 3.3 スケーリングロジック

```
入力:
  icon_actual  = 実際のアイコン Icon RectTransform のサイズ (w, h)
  icon_rect    = JSON定義の参照矩形 { x, y, width, height }
  canvas_size  = エフェクトキャンバスサイズ

1. スケール計算
   scale = Min(icon_actual.w / icon_rect.width,
               icon_actual.h / icon_rect.height)

2. RawImage の表示サイズ
   display_size = canvas_size * scale

3. オフセット計算（icon_rect中心をアイコン中心に合わせる）
   canvas_center   = canvas_size / 2
   icon_rect_center = (icon_rect.x + icon_rect.width/2,
                        icon_rect.y + icon_rect.height/2)
   offset = (canvas_center - icon_rect_center) * scale
   ※ Y軸はキャンバス座標(下向き)→RectTransform(上向き)の変換が必要

4. 配置
   rt.sizeDelta = (display_size, display_size)
   rt.anchoredPosition = offset  // アイコン中心基準
```

**可変アイコンサイズへの対応**: スケールは実アイコンサイズとicon_rectサイズの比率で決まるため、アイコンが大きくても小さくてもエフェクトが自動追従する。

### 3.4 icon_rect 省略時

icon_rect を省略した場合、キャンバス全体がアイコン領域として扱われる:
- `icon_rect = { x: 0, y: 0, width: canvas, height: canvas }`
- スケール = アイコン短辺 / canvas
- オフセット = (0, 0)（中央配置）

### 3.5 JSON仕様

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  "fps": 30,
  "duration": 0.8,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | `"icon"` | `"icon"` を指定（省略可） |
| `icon_rect` | object | null | アイコン参照矩形（省略時: キャンバス全体 = アイコン） |
| `icon_rect.x` | float | — | 参照矩形の左上X（キャンバス座標） |
| `icon_rect.y` | float | — | 参照矩形の左上Y（キャンバス座標） |
| `icon_rect.width` | float | — | 参照矩形の幅 |
| `icon_rect.height` | float | — | 参照矩形の高さ |

### 3.6 描画先

BattleIconUI の子に配置（現在と同じ階層）。`SetupRectTransform()` のロジックが icon_rect ベースに変わる。

```
BattleIconUI
├── Icon (アイコン画像)
├── HPBar
├── EffectLayer (既存)
│   └── Effect_xxx
│       └── RawImage (icon_rect でスケール・オフセット計算)
└── ...
```

---

## 4. field モード — フィールドエフェクト

### 4.1 概要

特定のアイコンに依存しない、バトルフィールド全体にかかるエフェクト。ViewportArea直下に1つの専用レイヤーを設け、敵・味方アイコンの両方の上に描画する。

### 4.2 描画先

ViewportArea の子として FieldEffectLayer を FrontFixedContainer の直後に1つだけ配置する。

```
AlwaysCanvas
└── EyeArea
    └── ViewportArea
        ├── ZoomBackContainer      (背景、演出ズームされる)
        ├── MiddleFixedContainer   (ActionMark等、固定)
        ├── ZoomFrontContainer     (敵アイコン、演出ズームされる)
        ├── FrontFixedContainer    (味方アイコン、固定)
        ├── FieldEffectLayer       ← フィールドエフェクト（敵味方の上）
        ├── BSAmanager
        └── SchizoLog
```

**ズームとの関係:**
- **K-Zoom**: ViewportArea 親ごとスケールするため、FieldEffectLayer もズームされる
- **演出ズーム**: ZoomBack/ZoomFront のみ個別スケール。FieldEffectLayer は直接対象外だが、画面全体にかかるエフェクトなので問題ない

### 4.3 座標系

キャンバスがViewportArea矩形にフィットする。アスペクト比は維持しない。

```
ViewportArea (横長)
┌──────────────────────────────────┐
│  エフェクトキャンバス (100×100)    │
│  → ViewportArea全体に引き延ばし   │
│  (50,50) = 画面中央               │
└──────────────────────────────────┘
```

### 4.4 JSON仕様

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [ ... ]
}
```

| フィールド | 型 | デフォルト | 説明 |
|-----------|-----|-----------|------|
| `target` | string | — | `"field"` を指定 |

### 4.5 API

```csharp
// フィールドエフェクト再生
EffectPlayer player = EffectManager.PlayField("screen_flash");
EffectPlayer player = EffectManager.PlayField("screen_flash", loop: true);

// フィールドエフェクト停止
EffectManager.StopField("screen_flash");
EffectManager.StopAllField();
```

---

## 5. エフェクトJSON 新規フィールドまとめ

| フィールド | 適用モード | 型 | デフォルト | 説明 |
|-----------|-----------|-----|-----------|------|
| `target` | 共通 | string | `"icon"` | 配置モード（`"icon"` / `"field"`） |
| `icon_rect` | icon | object | null | アイコン参照矩形（省略時: キャンバス全体） |
| `icon_rect.x` | icon | float | — | 左上X（キャンバス座標） |
| `icon_rect.y` | icon | float | — | 左上Y（キャンバス座標） |
| `icon_rect.width` | icon | float | — | 幅 |
| `icon_rect.height` | icon | float | — | 高さ |

---

## 6. エディタ: Effect Placement Editor

### 6.1 設計思想

**「アイコンを固定基準にして、エフェクトの位置・サイズを操作する」** がエディタの基本コンセプト。

ユーザーにとって自然な操作:
- 「エフェクトを頭上に配置したい」→ エフェクトを上に動かす
- 「エフェクトを大きくはみ出させたい」→ エフェクトを拡大する

内部的には、この操作がicon_rect座標に逆変換されてJSONに保存される（Section 3.2 参照）。

### 6.2 なぜ新規ウィンドウか

現在のエディタツールの役割:

| ツール | 役割 | 対応形式 |
|--------|------|---------|
| **KFX Editor** | KFXエフェクトの中身を制作（レイヤー・キーフレーム編集） | KFXのみ |
| **Effect Previewer** | エフェクトの再生確認（読み取り専用） | 両形式 |

配置メタデータ（target / icon_rect）はエフェクトの**中身とは独立した設定**であり、KFX・フレームベース**両形式に共通**。

→ **1つの専用ウィンドウ「Effect Placement Editor」** を新設し、全エフェクトの配置設定を一元管理する。

### 6.3 ツール構成

```
┌─────────────────────────────────────────────────────────────┐
│  エフェクト制作フロー                                         │
│                                                              │
│  ① エフェクトの中身を作る                                     │
│     ├── KFX形式 → KFX Editor で制作                          │
│     └── フレームベース → テキストエディタ / AI生成              │
│                                                              │
│  ② 配置を設定する（共通）                                     │
│     └── Effect Placement Editor                              │
│         ・任意のエフェクトJSONを選択                            │
│         ・target / エフェクト位置・サイズ を編集                │
│         ・プレビュー + 実機プレビュー表示                       │
│         ・保存（配置メタデータのみJSON書き戻し）                 │
│                                                              │
│  ③ 再生確認                                                   │
│     └── Effect Previewer（既存・変更なし）                     │
└─────────────────────────────────────────────────────────────┘
```

### 6.4 エディタ画面構成

**メニュー**: Window → Effects → Effect Placement Editor

エディタは3つの主要エリアで構成される:

#### A. キャンバスプレビュー（左側）

エフェクトの正方形キャンバスを表示し、その中で**アイコン（灰色矩形）を中央固定の基準**として、**エフェクトの位置・サイズ（緑色枠）をドラッグ操作**する。

```
┌─ キャンバスプレビュー ─────────────────────┐
│                                            │
│   ┌─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┐       │
│   ┆  緑色枠 = エフェクトキャンバス   ┆       │
│   ┆                               ┆       │
│   ┆      ┌──────────────┐        ┆       │
│   ┆      │ 灰色 = アイコン │        ┆       │
│   ┆      │ （中央固定）    │        ┆       │
│   ┆      └──────────────┘        ┆       │
│   ┆                               ┆       │
│   └─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┘       │
│                                            │
│  ドラッグ: 緑色枠を移動 = エフェクト位置変更  │
│  辺ドラッグ: 緑色枠のサイズ変更              │
└────────────────────────────────────────────┘
```

**操作と内部変換の対応:**

| エディタ上の操作 | 見た目の変化 | icon_rect への変換 |
|-----------------|-------------|-------------------|
| 緑色枠を**上**に移動 | エフェクトがアイコンの上方に移動 | icon_rect.y が**増加**（キャンバス内で下方に） |
| 緑色枠を**左**に移動 | エフェクトがアイコンの左方に移動 | icon_rect.x が**増加**（キャンバス内で右方に） |
| 緑色枠を**拡大** | エフェクトがアイコンに対して大きくなる | icon_rect の幅/高さの**キャンバスに対する比率が縮小** |
| 緑色枠を**中央にリセット** | エフェクト中心 = アイコン中心 | icon_rect がキャンバス中央に配置 |

#### B. 実機プレビュー（右側）

実際のアイコンサイズ（味方固定 / 敵可変）でエフェクトを再生表示。icon_rect によるスケーリング・オフセットが適用された最終的な見た目を確認できる。

```
┌─ 実機プレビュー ──────────────┐
│                                │
│    ┌────────────────┐         │
│    │  アイコン        │         │
│    │  ┌────────────┐│         │
│    │  │エフェクト     ││         │
│    │  │(スケール適用) ││         │
│    │  └────────────┘│         │
│    └────────────────┘         │
│                                │
│  [▶] [⏸] [■]  Speed: [1.0x]  │
│  [|◀] [◀] [▶] [▶|]           │
│  Frame: 12/45  Time: 0.40s    │
└────────────────────────────────┘
```

#### C. 設定パネル（上部）

```
┌─ 設定 ───────────────────────────────────────────┐
│  [エフェクト選択 ▼]  [Reload]                      │
│                                                    │
│  Target: [icon ▼]                                  │
│                                                    │
│  ── icon モード ──                                  │
│  アイコンプリセット: [味方(169x257) ▼]               │
│  アイコン参照比率: [0.4]                             │
│                                                    │
│  icon_rect: x=[14.7] y=[29.1] w=[71.3] h=[67.5]   │
│  [キャンバス全体にリセット]  [Save]  [Revert]        │
└────────────────────────────────────────────────────┘
```

### 6.5 主要機能

| 機能 | 説明 |
|------|------|
| **エフェクト選択** | `Resources/Effects/` 内の全JSONをドロップダウンで一覧。KFX/フレームベース問わず |
| **target 切替** | icon / field のドロップダウン。切替に応じて下の設定パネルが変わる |
| **エフェクト位置ドラッグ** | キャンバスプレビュー上で緑色枠をドラッグ → エフェクト位置を直感的に操作（内部でicon_rectに逆変換） |
| **エフェクトサイズ変更** | 緑色枠の辺をドラッグ → エフェクトのアイコンに対する相対サイズを変更 |
| **icon_rect 数値編集** | x / y / width / height のフィールドで直接編集も可能（target=icon 時のみ表示） |
| **アイコンプリセット** | 実機プレビューで使用するモックアイコンサイズ（味方固定 / 各種敵サイズ） |
| **実機プレビュー再生** | エフェクトをicon_rectスケーリング適用で再生。最終的な見た目を確認 |
| **フレームステップ** | 1フレームずつ進む/戻る、先頭/末尾ジャンプ |
| **Save** | 配置メタデータ（target / icon_rect）のみJSON書き戻し。エフェクトの中身は変更しない |

### 6.6 キャンバスプレビューの座標変換

キャンバスプレビューでは、**アイコン（灰色矩形）を中央に固定**し、**エフェクトキャンバス（緑色枠）を相対的に配置**する。

ユーザーが緑色枠をドラッグした際、以下の変換でicon_rect座標を算出する:

```
エディタ空間:
  icon_center = プレビュー中央（固定）
  effect_rect = 緑色枠の矩形（ユーザーがドラッグで操作）

icon_rect への変換:
  canvas = エフェクトキャンバスサイズ

  緑色枠内でのアイコンの相対位置 = icon_center - effect_rect.topLeft

  icon_rect.x = (icon_center.x - effect_rect.left) / effect_rect.width * canvas
  icon_rect.y = (icon_center.y - effect_rect.top) / effect_rect.height * canvas
  icon_rect.width  = icon_display_width / effect_rect.width * canvas
  icon_rect.height = icon_display_height / effect_rect.height * canvas
```

**逆方向（icon_rect → 緑色枠の表示位置）:**

```
icon_rect → エディタ表示:
  effect_scale = icon_display_size / icon_rect_size
  effect_display_size = canvas * effect_scale
  effect_offset = icon_center - (icon_rect_center_in_canvas * effect_scale)
```

### 6.7 保存の仕組み

Save時はJSONファイルを読み込み、配置関連フィールドのみ上書きして書き戻す:

```
読み込んだJSON
├── name, canvas, fps, duration, se, layers/frames ... → そのまま保持
├── target → 上書き
└── icon_rect → 上書き（null の場合はキーごと削除）
```

エフェクトの中身（layers, frames, keyframes等）には一切触れない。

### 6.8 既存ツールへの変更

| ツール | 変更 |
|--------|------|
| **KFX Editor** | 変更なし。配置設定はEffect Placement Editorに任せる |
| **Effect Previewer** | 変更なし |

---

## 7. ランタイム変更点

### 7.1 EffectDefinition の拡張

```csharp
// EffectDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; } = "icon";

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; } = "middle";
```

```csharp
// 新クラス（EffectDefinition.cs 内）
[Serializable]
public class IconRectDefinition
{
    [JsonProperty("x")] public float X { get; set; }
    [JsonProperty("y")] public float Y { get; set; }
    [JsonProperty("width")] public float Width { get; set; }
    [JsonProperty("height")] public float Height { get; set; }
}
```

### 7.2 EffectLayer.SetupRectTransform() の変更

```csharp
private void SetupRectTransform(RectTransform rt, EffectDefinition def)
{
    // アイコンの実サイズ取得（BattleIconUIのIcon RectTransformから）
    Vector2 iconSize = GetIconActualSize();

    int canvas = def.Canvas;

    if (def.IconRect != null)
    {
        // icon_rect ベースのスケーリング
        var ir = def.IconRect;
        float scale = Mathf.Min(iconSize.x / ir.Width, iconSize.y / ir.Height);
        float displaySize = canvas * scale;

        float canvasCenter = canvas / 2f;
        float irCenterX = ir.X + ir.Width / 2f;
        float irCenterY = ir.Y + ir.Height / 2f;

        // キャンバスY下向き → RectTransformY上向き 変換
        float offsetX = (canvasCenter - irCenterX) * scale;
        float offsetY = (irCenterY - canvasCenter) * scale;

        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(displaySize, displaySize);
        rt.anchoredPosition = new Vector2(offsetX, offsetY);
    }
    else
    {
        // icon_rect 省略: アイコン短辺にフィット
        float shortSide = Mathf.Min(iconSize.x, iconSize.y);
        rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
        rt.pivot = new Vector2(0.5f, 0.5f);
        rt.sizeDelta = new Vector2(shortSide, shortSide);
        rt.anchoredPosition = Vector2.zero;
    }
}
```

### 7.3 EffectManager の変更

```csharp
// EffectManager.cs

// フィールドエフェクトレイヤー参照
[SerializeField] private EffectLayer _fieldEffectBack;
[SerializeField] private EffectLayer _fieldEffectMiddle;
[SerializeField] private EffectLayer _fieldEffectFront;

// 既存 Play() 内部でターゲット分岐
private EffectPlayer PlayInternal(string effectName, BattleIconUI battleIconUI, bool loop)
{
    var definition = LoadDefinition(effectName);
    if (definition == null) return null;

    if (definition.Target == "field")
    {
        return PlayFieldInternal(definition, loop);
    }
    else
    {
        return PlayOnIconInternal(definition, battleIconUI, loop);
    }
}

// フィールドエフェクト専用API
public static EffectPlayer PlayField(string effectName, bool loop = false) { ... }
public static void StopField(string effectName) { ... }
public static void StopAllField() { ... }

private EffectPlayer PlayFieldInternal(EffectDefinition def, bool loop)
{
    var layer = def.FieldLayer switch
    {
        "back"  => _fieldEffectBack,
        "front" => _fieldEffectFront,
        _       => _fieldEffectMiddle,
    };
    return layer?.PlayEffect(def, loop);
}
```

### 7.4 KfxDefinition / KfxCompiler の変更

```csharp
// KfxDefinition.cs に追加
[JsonProperty("target")]
public string Target { get; set; }

[JsonProperty("icon_rect")]
public IconRectDefinition IconRect { get; set; }

[JsonProperty("field_layer")]
public string FieldLayer { get; set; }
```

```csharp
// KfxCompiler.cs — コンパイル時にパススルー
result.Target = kfx.Target ?? "icon";
result.IconRect = kfx.IconRect;
result.FieldLayer = kfx.FieldLayer ?? "middle";
```

---

## 8. 使用例

### 例1: シンプルなヒットエフェクト（icon_rect 省略）

```json
{
  "format": "kfx",
  "name": "simple_hit",
  "canvas": 100,
  "fps": 30,
  "duration": 0.3,
  "layers": [
    {
      "id": "flash",
      "type": "circle",
      "blend": "additive",
      "keyframes": [
        { "time": 0.0, "x": 50, "y": 50, "radius": 5, "brush": {"color": "#FFFFFF"} },
        { "time": 0.15, "radius": 40, "opacity": 0.8 },
        { "time": 0.3, "radius": 50, "opacity": 0.0 }
      ]
    }
  ]
}
```

`target` 省略 → `"icon"`、`icon_rect` 省略 → キャンバス全体 = アイコン。アイコン短辺にフィットして中央に描画。

### 例2: アイコン頭上にエフェクト

**エディタでの操作**: エフェクトを上方向にドラッグ

**結果のJSON** (icon_rect がキャンバス下寄りに):

```json
{
  "format": "kfx",
  "name": "heal_sparkle",
  "target": "icon",
  "icon_rect": { "x": 20, "y": 60, "width": 60, "height": 90 },
  "canvas": 150,
  ...
}
```

150×150キャンバスの下部(20,60,60,90)がアイコン対応領域。エフェクトのキャンバス上部に描いた演出がアイコンの頭上に出る。icon_rectスケーリングにより、200x300のアイコンでも100x150のアイコンでも同じ見た目。

### 例3: アイコンからはみ出す大爆発

**エディタでの操作**: エフェクトを大きく拡大（緑色枠をアイコンより大きく広げる）

**結果のJSON** (icon_rect がキャンバスに対して小さい):

```json
{
  "format": "kfx",
  "name": "big_explosion",
  "target": "icon",
  "icon_rect": { "x": 70, "y": 30, "width": 60, "height": 140 },
  "canvas": 200,
  ...
}
```

200×200キャンバスの中央に爆発、icon_rect (60×140) がアイコンに合うようにスケールされるので、爆発はアイコンの外まで大きくはみ出す。

### 例4: 画面全体フラッシュ（field）

```json
{
  "format": "kfx",
  "name": "screen_flash",
  "target": "field",
  "field_layer": "front",
  "canvas": 100,
  ...
}
```

ViewportArea最前面に画面全体をカバーする白フラッシュ。

### 例5: 背景の天候エフェクト（field）

```json
{
  "format": "kfx",
  "name": "dark_atmosphere",
  "target": "field",
  "field_layer": "back",
  "canvas": 100,
  ...
}
```

背景レイヤーに暗い霧。ループ再生。

---

## 9. 実装の影響範囲

### 変更が必要なファイル

| ファイル | 変更内容 |
|---------|---------|
| `Effects/Core/EffectDefinition.cs` | `Target`, `IconRect`, `FieldLayer` フィールド + `IconRectDefinition` クラス追加 |
| `Effects/Core/KfxDefinition.cs` | 同フィールド追加 |
| `Effects/Core/KfxCompiler.cs` | 新フィールドのパススルー |
| `Effects/Integration/EffectLayer.cs` | `SetupRectTransform()` を icon_rect 対応に変更。アイコン実サイズ取得メソッド追加 |
| `Effects/Integration/EffectManager.cs` | target 分岐、`PlayField()` / `StopField()` / `StopAllField()` API追加 |

### 新規ファイル

| ファイル | 役割 |
|---------|------|
| `Editor/Effects/EffectPlacementEditor.cs` | Effect Placement Editor ウィンドウ |

### シーン変更

| 対象 | 変更内容 |
|------|---------|
| ViewportArea | FieldEffectLayer（EffectLayer付き空GameObject）を FrontFixedContainer の直後に挿入 |

### 変更しないファイル

| ファイル | 理由 |
|---------|------|
| `Editor/Effects/KfxEditorWindow.cs` | 配置設定はEffect Placement Editorに集約 |
| `Editor/Effects/KfxEditorWindow.Drawing.cs` | 同上 |
| `Editor/Effects/EffectPreviewWindow.cs` | 同上 |
| `EYEAREA_UI/BattleIconUI.cs` | アンカーポイント不要（icon_rectで代替） |

---

## 10. 段階的実装の提案

| 段階 | 内容 | 依存 |
|------|------|------|
| **Phase 1** | EffectDefinition / KfxDefinition に新フィールド追加。KfxCompiler パススルー | なし |
| **Phase 2** | EffectLayer の icon_rect 対応（スケーリング・オフセット計算） | Phase 1 |
| **Phase 3** | field モード対応（ViewportArea に EffectLayer 配置 + EffectManager.PlayField() API） | Phase 1 |
| **Phase 4** | Effect Placement Editor ウィンドウ（エフェクト選択 + エフェクト位置/サイズ編集 + 実機プレビュー + icon_rect逆変換 + Save） | Phase 1, 2, 3 |

---

## 11. キャンバスプレビュー逆転実装計画

### 11.1 現状の問題

現在のキャンバスプレビューは**表現対象が逆**:

| 要素 | 現在の意味 | 正しい意味 |
|------|-----------|-----------|
| 緑色ドラッグ枠 | icon_rect（アイコン領域） | **エフェクトキャンバスの位置・サイズ** |
| 灰色中央固定矩形 | 視覚的参照（操作なし） | **アイコン（固定基準点）** |
| プレビュー背景 | エフェクトキャンバス全体 | 作業領域（ニュートラル） |

UIの見た目（緑枠 + 灰色矩形 + ドラッグ操作 + 実機プレビュー）は現在のまま。**中身（何を表すか）だけを入れ替える。**

### 11.2 逆転後のモデル

```
キャンバスプレビュー（逆転後）
┌─ 作業領域 ─────────────────────────────────┐
│                                              │
│   ┌─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐               │
│   ┆  緑色枠 = エフェクト     ┆               │
│   ┆  （正方形、ドラッグ可能） ┆               │
│   ┆                         ┆               │
│   ┆    ┌────────────┐      ┆               │
│   ┆    │灰色 = アイコン│      ┆               │
│   ┆    │（中央固定）   │      ┆               │
│   ┆    └────────────┘      ┆               │
│   ┆                         ┆               │
│   └─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘               │
│                                              │
│  緑色枠の中にエフェクトテクスチャを描画         │
│  灰色矩形はアイコンのアスペクト比を反映         │
└──────────────────────────────────────────────┘
```

**操作**:
- 緑色枠をドラッグ → エフェクトの位置を移動（直感的に上に動かすと頭上にエフェクトが来る）
- 緑色枠の四隅をドラッグ → エフェクトのサイズを変更（**正方形制約を維持**）
- 灰色矩形は常に作業領域中央に固定

### 11.3 正方形制約とアスペクト比

#### エフェクトキャンバスは常に正方形

エフェクト定義の `canvas` は `canvas × canvas` の正方形。従って緑色枠は**常に正方形**。四隅のリサイズは均等スケール（アスペクト比変更不可）。

#### アイコンは可変アスペクト比

灰色矩形のアスペクト比はモックアイコンプリセットに追従:

| プリセット | サイズ | アスペクト比 |
|-----------|--------|------------|
| 味方 | 170×257 | 約 2:3（縦長） |
| 小敵 | 100×100 | 1:1 |
| 中敵 | 200×200 | 1:1 |
| 大敵 | 400×300 | 4:3（横長） |

灰色矩形の表示サイズは `_iconRefRatio` スライダーで調整:

```
iconMaxDim = previewSize × _iconRefRatio
mockAspect = mockSize.x / mockSize.y

if (mockAspect >= 1):    // 横長 or 正方形
    iconDispW = iconMaxDim
    iconDispH = iconMaxDim / mockAspect
else:                     // 縦長
    iconDispH = iconMaxDim
    iconDispW = iconMaxDim × mockAspect
```

#### icon_rect のアスペクト比はアイコンに追従

icon_rect は「エフェクトキャンバス（正方形）の中でアイコンが占める領域」なので、icon_rect のアスペクト比は**自動的にアイコンのアスペクト比と一致**する。ユーザーが独立して icon_rect のアスペクト比を変更する操作は存在しない。

```
icon_rect.width / icon_rect.height = アイコン実幅 / アイコン実高さ
```

これは現在のicon_rect自由編集より制約が強いが、ランタイムの `Min(scaleX, scaleY)` 計算上、アスペクト比が一致しない icon_rect は片方の軸に無駄な余白を生むだけなので、自然な制約。

### 11.4 座標変換の詳細

#### 表記定義

```
previewSize     = プレビュー作業領域のサイズ（px）
iconCenter      = (previewSize/2, previewSize/2) — 作業領域の中央（固定）
iconDispW/H     = アイコン表示サイズ（px）
canvas          = エフェクトキャンバスサイズ（JSON定義値、例: 100, 200）
irX/Y/W/H       = icon_rect 値（キャンバス座標）
gx/gy/gSize     = 緑色枠の画面位置・サイズ（px）
```

#### 順方向: icon_rect → 緑色枠の表示位置

icon_rect をロード後、プレビュー上での緑色枠の位置・サイズを計算:

```
1. スケール計算（ランタイムと同じ式）
   scale = Min(iconDispW / irW, iconDispH / irH)

2. 緑色枠サイズ（正方形）
   gSize = canvas × scale

3. エフェクト中心のアイコン中心からのオフセット
   irCenterX = irX + irW / 2
   irCenterY = irY + irH / 2
   canvasCenter = canvas / 2

   effOffX = (canvasCenter - irCenterX) × scale
   effOffY = (canvasCenter - irCenterY) × scale

4. 緑色枠の位置
   gCenterX = previewSize/2 + effOffX
   gCenterY = previewSize/2 + effOffY
   gx = gCenterX - gSize/2
   gy = gCenterY - gSize/2
```

#### 逆方向: 緑色枠ドラッグ → icon_rect 更新

ユーザーが緑色枠を移動・リサイズした後、icon_rect を逆算:

```
1. スケール逆算
   scale = gSize / canvas

2. icon_rect サイズ（アイコンの表示サイズから決定）
   irW = iconDispW / scale
   irH = iconDispH / scale

3. エフェクト中心のオフセットからicon_rect中心を逆算
   gCenterX = gx + gSize/2
   gCenterY = gy + gSize/2

   effOffX = gCenterX - previewSize/2
   effOffY = gCenterY - previewSize/2

   irCenterX = canvasCenter - effOffX / scale
   irCenterY = canvasCenter - effOffY / scale

4. icon_rect 左上座標
   irX = irCenterX - irW/2
   irY = irCenterY - irH/2
```

### 11.5 ドラッグ操作の変更

#### 移動（Move）

現在: `_iconRectX/Y` を直接加算
変更後: 緑色枠の画面位置を加算 → 逆変換で `_iconRectX/Y` を更新

```
ドラッグ delta (画面px)
→ gx += delta.x, gy += delta.y
→ 逆変換で irX, irY を更新
```

**移動のクランプ条件**: icon_rect がキャンバス範囲 `[0, canvas]` 内に収まること。

```
irX >= 0  かつ  irX + irW <= canvas
irY >= 0  かつ  irY + irH <= canvas
```

#### リサイズ（四隅ハンドル）

現在: 各辺を独立に移動（自由変形）
変更後: **均等スケール**（正方形制約を維持）

```
四隅ハンドルのいずれかをドラッグ:
  ドラッグ量から新しい gSize を算出（正方形維持）
  リサイズ方向に応じてアンカーポイント（対角の隅）を固定
  → 逆変換で irW, irH, irX, irY を更新
```

**リサイズの最小サイズ制約**:

緑色枠（エフェクト）はアイコンを包含する必要がある:
```
gSize >= Max(iconDispW, iconDispH)
```

これを超えて小さくすると `irW > canvas` または `irH > canvas` になり、icon_rect がキャンバス外にはみ出す。

### 11.6 テクスチャ描画の変更

#### 現在

エフェクトテクスチャをプレビュー背景全体に `StretchToFill` で描画。

#### 変更後

エフェクトテクスチャを**緑色枠の内部**に描画:

```csharp
// 緑色枠の矩形にクリッピングしてテクスチャを描画
if (_previewTexture != null)
    GUI.DrawTexture(greenRect, _previewTexture, ScaleMode.StretchToFill);
```

これにより、エフェクトの描画範囲が緑色枠と一致し、「緑枠 = エフェクト」が視覚的にも明確になる。

### 11.7 実機プレビューの変更

**変更なし。** 実機プレビューは元からアイコン中央配置 + icon_rectスケーリングの最終結果を表示しており、正しい動作。

### 11.8 ラベル・HelpBox の変更

| 要素 | 現在 | 変更後 |
|------|------|--------|
| HelpBox | "緑の矩形（icon_rect）をドラッグで移動..." | "緑の矩形（エフェクト）をドラッグで移動、四隅で拡大/縮小。灰色=アイコン基準。" |
| 灰色矩形ラベル | "アイコン参照" | "アイコン" |
| 緑色枠ラベル | "icon_rect (x, y, w, h)" | "エフェクト" |
| スライダーラベル | "アイコン参照サイズ" | "アイコン表示サイズ" |

### 11.9 プリセットボタンの変更

現在のプリセットボタン（「全体」「中央50%」等）はicon_rectを直接設定する。逆転後は「エフェクトの配置」を直接設定する意味になる:

| ボタン | 現在の動作 | 逆転後の意味 |
|--------|-----------|-------------|
| 全体 | icon_rect = (0, 0, canvas, canvas) | エフェクト = アイコンにぴったり重なる（はみ出しなし） |
| 中央50% | icon_rect = 中央50%の矩形 | エフェクトがアイコンの2倍の大きさ |
| 中央75% | icon_rect = 中央75%の矩形 | エフェクトがアイコンの約1.33倍 |
| 中央寄せ | icon_rect の中心をキャンバス中心に移動 | エフェクトの中心をアイコンの中心に合わせる |

これらのボタンは「icon_rect値を設定」するという内部動作は同じ。ラベルだけ逆転後の意味に合わせる:
- "全体" → "フィット"（エフェクト = アイコンサイズ）
- "中央50%" → "2倍はみ出し"
- "中央75%" → "1.3倍はみ出し"
- "中央寄せ" → "中央寄せ"（そのまま）

### 11.10 状態変数の方針

**`_iconRectX/Y/W/H` はそのまま保持する。**

理由:
- JSON保存値と直接対応しており、変換エラーの余地がない
- 数値入力フィールドはicon_rect値をそのまま表示・編集できる（上級ユーザー向け）
- 逆変換は表示時（順方向）とドラッグ時（逆方向）のみ発生

```
JSON ←→ _iconRectX/Y/W/H ←→ 順方向/逆方向変換 ←→ 緑色枠画面位置
                 ↕
         数値入力フィールド（直接編集）
```

### 11.11 変更対象のメソッド一覧

| メソッド | 変更内容 |
|---------|---------|
| `DrawCanvasPreview()` | 灰色矩形=アイコン（モックアスペクト比適用）、緑色枠=エフェクト（正方形、icon_rectから逆算位置）、テクスチャを緑枠内に描画 |
| `HandleDrag()` | 緑色枠のドラッグ → 逆変換でicon_rect更新。ヒットテスト対象を緑色枠に変更 |
| `ApplyDrag()` | 移動: 画面座標→逆変換。リサイズ: 均等スケール＋正方形制約→逆変換 |
| `DrawPlacementControls()` | ラベル変更、プリセットボタンのラベル変更 |
| — | `DrawResultPreview()` は変更なし |
| — | `SavePlacementData()` は変更なし |
| — | `LoadEffect()` / `LoadPlacement()` は変更なし |

### 11.12 エッジケースと制約

| ケース | 処理 |
|--------|------|
| 緑色枠がアイコンより小さい | 最小サイズ制約でクランプ（gSize >= Max(iconDispW, iconDispH)） |
| icon_rect がキャンバス外に出る | irX, irY をクランプ（0 ≤ irX, 0 ≤ irY, irX+irW ≤ canvas, irY+irH ≤ canvas） |
| icon_rect省略時（全体） | 緑色枠がアイコンとぴったり重なる状態で表示 |
| モックプリセット変更時 | 灰色矩形のアスペクト比が変わる → 緑色枠の表示サイズも再計算 |
| icon_rect のアスペクト比がアイコンと不一致（既存JSONの手動編集時） | Min(scaleX, scaleY) でフィット。ドラッグ操作するとアイコンのアスペクト比に修正される |
