# ゆりかごシステム仕様書

## 概要

ゆりかご（cradle）は、TLOAスキル専用の動的スキルレベル計算システム。

通常のスキルはレベルが使用回数で固定的に決まる。TLOAスキルも基礎レベルは同じだが、戦闘中の威力計算時に**ゆりかごレベル**が別途計算され、そちらが使われる。ゆりかごレベルは攻撃のたびに再計算され、攻撃者・被害者の強さ、精神属性、パーティ構成、スキルへの適性によって毎回揺れる。

**TLOAスキルだけにゆりかごが適用される理由**: TLOAは「気持ちの問題」に由来するスキル体系であり、使い手の精神状態・環境・相手との関係性によって威力が安定しない。この不安定さをシステムとして表現したものがゆりかご。

---

## スキルレベルの基礎

### レベル算出

```
スキルレベル = 永続使用回数 ÷ レベルアップ除数（切り捨て）
```

| スキル種別 | レベルアップ除数 | 定数名 |
|-----------|---------------|--------|
| TLOAスキル | 120回 | `TLOA_LEVEL_DIVIDER` |
| 非TLOAスキル | 50回 | `NOT_TLOA_LEVEL_DIVIDER` |

TLOAは成長が遅い（120回で1レベル vs 50回で1レベル）。

### SkillLevelData

スキルはレベルごとのデータを `FixedSkillLevelData`（有限リスト）として持つ。最低1つは必須。

```
FixedSkillLevelData: List<SkillLevelData>
  [0] = レベル0のデータ（初期状態）
  [1] = レベル1のデータ
  ...
  [N] = レベルNのデータ（有限リストの最後）
```

| フィールド | 型 | 必須 | 説明 |
|-----------|-----|------|------|
| `TenDayValues` | `TenDayAbilityDictionary` | 必須 | スキルの印象構造（十日能力値） |
| `SkillPower` | `float` | 必須 | スキルの基礎威力 |
| `OptionMentalDamageRatio` | `float` | -1で無効 | 精神攻撃率の上書き |
| `OptionPowerSpread` | `float[]` | nullで無効 | 分散割合の上書き |
| `OptionSkillHitPer` | `int` | -1で無効 | 命中補正の上書き |
| `OptionA_MoveSet` | `List<MoveSet>` | nullで無効 | ムーブセットAの上書き |
| `OptionB_MoveSet` | `List<MoveSet>` | nullで無効 | ムーブセットBの上書き |

### 有限リストを超えた場合（無限単位）

レベルが有限リストの範囲を超えた場合、最終レベルのデータを基礎値とし、超過分に無限単位を乗算して加算する。

```
超過レベル数 = 現在レベル - (有限リスト数 - 1)

SkillPower = 有限最終のSkillPower + _infiniteSkillPowerUnit × 超過レベル数
TenDayValues = 有限最終のTenDayValues + _infiniteSkillTenDaysUnit × 超過レベル数
```

---

## ゆりかご計算フロー

`CalcCradleSkillLevel(BaseStates underAtker, BaseStates actor)` で計算される。

- `actor` = 攻撃者
- `underAtker` = 被害者
- TLOAスキルでなければ即 `return`（何もしない）

### ステップ1: ルート位置（吊り下げ位置）

ゆりかごの中心位置。ここを基準に上下に揺れる。

```
① 強さ比率
   TendayAdvantage = actor.TenDayValuesSum(true) ÷ underAtker.TenDayValuesSum(false)

   → 攻撃者の十日能力合計（スキル補正あり） ÷ 被害者の十日能力合計（スキル補正なし）
   → 1.0超 = 攻撃者が強い、1.0未満 = 攻撃者が弱い

② 実効ライバハル
   EffectiveRivahal = actor.Rivahal ÷ max(1.0, TendayAdvantage)

   → 自分が強いほど実効ライバハルが減る（強者はライバハル頼りにならない）
   → 自分が弱くてもクランプで水増しされない（max(1, ...)で防止）

③ ランダム除数の上限
   skillLevelRandomDivisorMax = max(1.0, EffectiveRivahal ÷ 2)

④ ルート位置
   root = EffectiveRivahal + _nowSkillLevel ÷ Random(1.0 ~ skillLevelRandomDivisorMax)

   → ライバハルが土台（大きい）
   → スキルレベルはランダムで圧縮される（ライバハルが高いほど除数が大きくなり、スキルレベルの貢献が小さくなる）
```

**数値例**: ライバハル80、強さ比率1.25、スキルレベル5の場合
- EffectiveRivahal = 80 / 1.25 = 64
- ランダム除数上限 = 64 / 2 = 32
- ルート = 64 + 5/Random(1~32) → 64.15 ~ 69

### ステップ2: 調子の範囲（MoodRange）

ゆりかごが上に揺れるか、下に揺れるか、動かないか。`-1`, `0`, `+1` の3値。

```
① 精神補正値の取得
   ratio = 0.7（70%適用）
   value = GetOffensiveSpiritualModifier(actor, underAtker).GetValue(ratio)

   → 攻撃者と被害者の精神属性の相性を70%スケールで取得

② 基本調子の決定（GetEstablishSpiritualMoodRange）
   value ≤ 95 × ratio (= 66.5) → -1（不調）
   value ≤ 100 × ratio (= 70.0) → 0（普通）
   value > 100 × ratio           → +1（好調）

③ パーティ属性との相性で±1補正（ModifyMoodByAttributeCompatibility）
   攻撃者の精神属性 × パーティ属性の組み合わせテーブルで上下
   結果は -1 ~ +1 にクランプ
```

**パーティ属性相性テーブル**:

| 精神属性 \ パーティ | 花樹 | 馬鹿共 | メレーンズ | 聖戦 | オドラデクス |
|---|---|---|---|---|---|
| リーミナルホワイトタイル | -1 | 0 | 0 | 0 | +1 |
| キンダーガーデン | -1 | +1 | 0 | 0 | 0 |
| 自己犠牲 | +1 | 0 | 0 | +1 | 0 |
| シークイエスト | 0 | -1 | 0 | +1 | +1 |
| デビル | +1 | +1 | 0 | 0 | -1 |
| ドレミス | +1 | 0 | 0 | +1 | 0 |
| 支柱 | 0 | 0 | 0 | 0 | 0 |
| ゴッドティア | 0 | +1 | 0 | 0 | 0 |
| ベールドライヴァル | 0 | +1 | 0 | +1 | -1 |
| サイコパス | +1 | 0 | +1 | 0 | 0 |

精神属性が `none` の場合は変化なし。

### ステップ3: 使いこなし度（MoodRangeRate = 振れ幅の大きさ）

調子が良い/悪い時にどれだけ大きく揺れるか。

```
① スキルの印象構造に一致する攻撃者の十日能力を合計
   AtkerTenDaySumMatchingSkill = Σ actor.TenDayValues(true)[key]
     ※ keyはスキルの印象構造の各十日能力キー

② 使いこなし度の基準値
   MoodRangeRate = AtkerTenDaySumMatchingSkill ÷ スキルの印象構造総量(TenDayValuesSum)

③ ランダムで下限を設定
   MoodRangeRate = max(MoodRangeRate - 2, Random(0 ~ 2))

   → 使いこなし度が高い（3.0以上）人は下限が保証される（3.0-2=1.0以上）
   → 使いこなし度が低い人はランダム次第（0~2の乱数に負ける）
```

### ステップ4: 最終合成

```
_cradleSkillLevel = (int)(root + MoodRange × MoodRangeRate)
```

- 調子 `+1` × 使いこなし度 `2.0` → ルート + 2
- 調子 `-1` × 使いこなし度 `2.0` → ルート - 2
- 調子 `0` → 使いこなし度に関係なくルートそのまま

---

## ゆりかごの影響範囲

### IsCradle が影響するもの（`_cradleSkillLevel` を参照）

| 項目 | 使用箇所 | IsCradleの渡し方 |
|------|---------|-----------------|
| **SkillPower** | `_skillPower(IsCradle)` → `SkillPowerCalc()` | `skill.IsTLOA` |
| **TenDayValues（印象構造）** | `TenDayValues(IsCradle)` | `skill.IsTLOA` |

### IsCradle が影響しないもの（常に `_nowSkillLevel` を参照）

| 項目 | 理由 |
|------|------|
| **SkillHitPer（命中補正）** | プロパティが `_nowSkillLevel` を直接参照。IsCradle引数なし |
| **PowerSpread（分散割合）** | 同上 |
| **MentalDamageRatio（精神攻撃率）** | 同上 |
| **MoveSet** | キャッシュ化されており、レベル変動の影響を受けない設計 |

つまり**ゆりかごで揺れるのはスキル威力と印象構造（成長用）だけ**。命中率・分散・精神攻撃率は使用回数ベースの安定したレベルに従う。

### HIT分成長への影響

```csharp
// BaseStates.ReactionSkill.cs:965
attacker.TenDayGrowthListByHIT.Add(
    (growRate * clampedRatio, skill.TenDayValues(skill.IsTLOA, actor: attacker))
);
```

TLOAスキルの場合、HIT時の十日能力成長に使われる印象構造もゆりかごレベルのものが使われる。つまり**同じスキルでもゆりかごの揺れ次第で成長する十日能力の量が変わる**。

### 精神補正率

`ComputeSkillPowers()` にて:

| スキル種別 | 精神補正適用率 |
|-----------|-------------|
| 通常スキル | 20% |
| TLOAスキル | 40% |
| 刃物武器装備時 | 0%（1.0固定） |

TLOAは精神補正が40%と高いため、精神属性の相性がゆりかごだけでなくダメージ計算にも色濃く影響する。

---

## 計算タイミングとライフサイクル

### 計算タイミング

| タイミング | 呼び出し元 | 引数 |
|-----------|-----------|------|
| スキル実行開始時（対象ごと） | `OnAttackerOneSkillActStart()` → `CalcCradleSkillLevel(underAtker, this)` | 被害者, 攻撃者 |
| 戦闘外スキル使用時 | `ApplySkillCoreOutOfBattle()` → `CalcCradleSkillLevel(attacker, attacker)` | 攻撃者, 攻撃者 |

**重要**: 連続攻撃で複数の敵を殴る場合、**敵ごとに再計算される**。相手が変わればゆりかごレベルも変わる。

### リセット

| タイミング | 処理 |
|-----------|------|
| 戦闘終了時 | `OnBattleEnd()` → `_cradleSkillLevel = -1` |
| スキル死亡時 | リセット**されない** |

`-1` はエラー状態を示す。戦闘中に `CalcCradleSkillLevel` が呼ばれずに `_cradleSkillLevel` が参照されると、`FixedSkillLevelData[-1]` でインデックス例外になる。これは「ゆりかご計算なしにゆりかごレベルを参照するバグ」を検出するための意図的な設計。

---

## 敵スキルとの関係

- 敵（NormalEnemy）のスキルにも同じゆりかごロジックが適用される
- `_nowSkillLevel` は `_recordDoCount` ベースであり、敵も使用回数でレベルが上がる
- 設計メモには「敵の初期スキルレベル指定」の構想があるが、`_nowSkillLevel` のoverrideは現在ない
- 敵にもライバハル・精神属性・パーティ属性が存在するため、ゆりかご計算は敵味方同一

---

## AllySkill の override

```csharp
// AllySkill.cs:55
protected override float _skillPower(bool IsCradle, BaseStates actor = null)
{
    return base._skillPower(IsCradle, actor) + CurrentHPFixedAdditionSkillPower(actor);
}
```

味方スキルは基礎のゆりかご計算結果に**思い入れスキルのHP固定加算**が追加される。ゆりかごの仕組み自体は変わらない。

---

## 既知の問題点（要修正）

### 致命的バグ

| # | 問題 | 原因 | 再現条件 |
|---|------|------|----------|
| 1 | **負のゆりかごレベル → IndexOutOfRangeException** | `_cradleSkillLevel` にクランプなし | 低ライバハル + 不調 + 高い使いこなし度 |
| 2 | **TenDayValuesSum=0 のゼロ除算** | `underAtker.TenDayValuesSum(false)` が0の場合 | 十日能力が空の敵 |
| 8 | **戦闘開始直後 + 低レベルTLOA → 確実にクラッシュ** | BM開始時にRivahal=0にリセット → root=0+skillLevel。skillLevel=0なら root=0。不調で負に転落 | 使用回数120回未満のTLOAスキルを初ターンに使用 |

### 設計上の問題

| # | 問題 | 影響 | 重大度 |
|---|------|------|--------|
| 3 | **スキルレベルの貢献が事実上ゼロ** | `root ≈ EffectiveRivahal + skillLv/Random(1~Rivahal/2)`。ライバハルが50以上だとスキルレベルの寄与は誤差。120回使って1レベル上げても体感できない | 高 |
| 4 | **調子の中立バンドが狭すぎ** | 精神補正値66.5〜70.0の3.5ポイント幅しか「普通」にならない。実質-1か+1の二択で、三段階設計が機能していない | 中 |
| 5 | **使いこなし度の死んだ領域** | `max(rate-2, Random(0~2))` により、使いこなし度0〜4は全てランダムに支配される。印象構造を少し揃えても無意味 | 中 |
| 6 | **強くなるほどTLOAが弱くなる** | `EffectiveRivahal = Rivahal / max(1, TendayAdvantage)`。十日能力が高いほど実効ライバハルが下がり、ゆりかごの土台が縮む。成長がTLOAを弱くする逆転現象 | 高 |
| 7 | **常に無限ブランチに入る** | ゆりかごレベル ≈ ライバハル（50〜200+）だが、FixedSkillLevelDataは3〜5個程度。有限レベルデータの設計が全く活きない | 中 |
| ~~9~~ | ~~**後手有利（セカンドムーバーアドバンテージ）**~~ | ~~ライバハルは被害者に蓄積するが、ゆりかごは攻撃者のライバハルを使う。先にTLOAを撃つ側はライバハル0で弱く、殴られた側が強くなる~~ | ~~高~~ |
| 10 | **ライバハル青天井** | ライバハルに上限がなく、長期戦でTLOAを撃ち合うとゆりかごレベルが際限なく膨張。`_infiniteSkillPowerUnit × 数百` の異常な補正が発生 | 高 |

#### #9 後手有利 → 仕様として許容

検討の結果、後手有利はテーマに合致した意図的な個性として許容する。

**テーマ的根拠**: TLOAは精神的な超能力。食らった側は相手の内面に強制的に触れる（単純接触効果の超能力版）。撃った側は自分の内面を一方的に見せただけで、相手の内面には触れていない。したがって被害者だけにライバハルが蓄積するのは正しい。

**ゲームプレイ上の成立条件**: TLOAスキルには複雑な効果があり、「後手有利だが効果的には先手で出したい」というジレンマが戦術的な判断を生む。もしこのジレンマが機能しない場合（全てのTLOAが温存最適になる場合）は、ライバハル側ではなくスキル効果側で調整する。

### ライバハル固有の問題

| # | 問題 | 影響 | 重大度 |
|---|------|------|--------|
| ~~11~~ | ~~**多種スキルがライバハルを不均衡に稼ぐ**~~ | ~~`RivahalDream`は十日能力を個別に割って合算する。印象構造の種類数が多いスキルは、合計能力値が同じでもライバハル加算量が種類数に比例して増大する（1種vs5種で5倍差）~~ | ~~中~~ |
| ~~12~~ | ~~**減衰がない（青天井の根本原因）**~~ | ~~TLOA HITごとに同量のライバハルが加算される。10回殴られても1回目と同じ加算量。収束も飽和もなく、長期戦で際限なく膨張する。問題#10の根本原因~~ | ~~高~~ |
| ~~13~~ | ~~**全TLOAで共有**~~ | ~~火のTLOAで殴られても氷のTLOAで殴られても同一の`float Rivahal`に加算。弱いTLOAでペチペチ殴られてライバハルを稼ぎ、全く無関係な強力TLOAの土台にできる~~ | ~~中~~ |
| ~~14~~ | ~~**被害者の精神属性がライバハル蓄積に無関係**~~ | ~~誤分析。`GetSkillVsCharaSpiritualModifier`は`this`(被害者)の`MyImpression`をルックアップキーに使用しており、被害者の精神属性は考慮されている。第2引数`Atker`はスキル属性の変換にのみ使用~~ | ~~誤報~~ |

#### #11 → 解決方針: 総量方式に変更

個別除算方式(`Σ attacker[i]/skill[i]`)を総量方式(`Σ attacker[matching keys] / Σ skill values`)に変更する。種類数への依存がなくなり、同じ合計能力値のスキルは同じライバハル加算量になる。メモ（豚のライバハル.md）も修正済み。コード変更は`RivahalDream`の内部ループ。

#### #12 → 解決方針: 馴化（じゅんか）式の導入

現在の線形蓄積 `Rivahal += raw` を、自己飽和する馴化式に変更する。

```
Rivahal += raw × raw / (raw + Rivahal × K)
```

- `raw` = 現在の`RivahalDream`が計算する生の加算量（#11の総量方式に変更後）
- `K` = 馴化速度の調整定数（デフォルト1.0）

**仕組み**: 分母に現在のRivahalが入ることで、蓄積量が多いほど新しい刺激の割合が小さくなる。

| Rivahal | raw=5の実際加算 | 割合 |
|---------|---------------|------|
| 0 | 5.0 | 100% |
| 5 | 2.5 | 50% |
| 20 | 1.0 | 20% |
| 100 | 0.24 | 5% |

**強い攻撃は飽和を突き破る**: raw=50なら Rivahal=100でも実際加算=16.7（33%）。弱いTLOAのペチペチは効かなくなるが、圧倒的なTLOAにはまだ驚ける。

**テーマ的根拠**: 馴化（habituation）。繰り返し曝露された刺激への反応が鈍化する心理現象。初めて食らうTLOAは衝撃的だが、何度も食らえば慣れる。ただし質的に異なる強さの刺激は突き抜ける。

**調整**: K値1つで馴化速度を制御。K小=鈍感（長く伸びる）、K大=敏感（すぐ飽和）。

この導入により#10（ライバハル青天井）も自動的に解決する。

#### #13 → #12 に帰結: 単体では問題なし

全TLOAで共有プールであること自体はテーマとして成立する。「どのTLOAであれ、精神的超能力を食らえばTLOAという現象への理解が深まる」。この共有が問題に**見える**のは#12（減衰なし）が原因。減衰/飽和を実装すれば、弱いTLOAでの蓄積稼ぎは自然に飽和して悪用不能になる。

---

## 再設計案（カトレア案）

### 設計思想の転換

旧設計はライバハル（戦闘中に0から蓄積する値）をゆりかごの**土台**にしていた。これが#1〜#8の問題の根本原因。

新設計は**スキルレベルを土台**にし、ライバハルを**揺れの増幅係数**に降格する。

### 新しい計算式

```
ゆりかごレベル = max(0, スキルレベル + 揺れ)

揺れ = 調子 × 使いこなし × 戦闘増幅
```

### 各パーツ

#### 1. 土台: スキルレベル

```
base = _nowSkillLevel
```

変更なし。使用回数120回で1レベル。ゆりかごはこの値を中心に揺れる。

#### 2. 調子（旧: 調子の範囲 H/M/L）

旧設計の離散三段階(-1/0/+1)を**連続値(-1.0〜+1.0)**に変更。

```
spiritualValue = GetOffensiveSpiritualModifier(actor, underAtker).GetValue(0.7)
center = 70  // = 100 × 0.7

mood = clamp((spiritualValue - center) / 3.5, -1.0, +1.0)

// パーティ属性補正（旧: ±1段階 → 新: ±0.3）
partyBonus = AttributeCompatibilityTable[actor.MyImpression, partyProperty]  // -0.3/0/+0.3
mood = clamp(mood + partyBonus, -1.0, +1.0)
```

パーティ属性相性テーブルは旧設計と同じ組み合わせを使用し、値を±0.3にスケール。

#### 3. 使いこなし（旧: 上下レート）

```
mastery = Σ actor.TenDayValues[matching keys] / skill.TenDayValuesSum
```

旧設計と同じ概念。ただし `max(rate - 2, Random(0~2))` の死んだ領域を**削除**。素直に比例。

- mastery < 1.0: スキル要求に足りない → 揺れが小さい
- mastery = 1.0: ちょうど → 揺れが等倍
- mastery > 1.0: 要求を超えている → 揺れが大きい

#### 4. 戦闘増幅（旧: 補正のライバハル部分）

```
rivahalFactor = actor.Rivahal / (actor.Rivahal + K)  // 0〜1に漸近
battleAmp = 1 + rivahalFactor × R
```

- **K** = 馴化定数（調整ノブ）
- **R** = 最大増幅量（例: R=2 → 増幅は最大×3.0）

| ライバハル | K=30 | 戦闘増幅(R=2) |
|-----------|------|-------------|
| 0（戦闘開始） | 0 | ×1.0 |
| 30 | 0.50 | ×2.0 |
| 90 | 0.75 | ×2.5 |
| →∞ | →1.0 | →×3.0（上限） |

ライバハルの役割が**土台 → 増幅**に変わったことで:
- 戦闘開始時: 増幅×1.0、揺れは小さいが**クラッシュしない**
- 戦闘中盤: 増幅×2.0前後、TLOAの応酬で揺れが大きくなる
- 長期戦: 増幅→×3.0に漸近、**青天井にならない**

#### 5. 削除: TendayAdvantage（強さ比較）

旧設計の `EffectiveRivahal = Rivahal / max(1, TendayAdvantage)` を完全に削除。

理由:
- 強さ比較はライバハルの**蓄積側**（RivahalDream）で既に反映されている
- ゆりかご側でさらに比較するのは二重課税
- 削除により `underAtker.TenDayValuesSum(false)` のゼロ除算リスクも消滅

### 旧概念との対応

| メモの用語 | メモの説明 | 旧コード | 新設計 | 変更点 |
|---|---|---|---|---|
| 調子の範囲(H/M/L) | 精神補正→H/M/L、パーティ属性で±1段階 | `-1/0/+1` 離散 | `-1.0〜+1.0` 連続 | 出力がなめらかに |
| 上下レート | 印象構造対応の十日能力 ÷ 印象構造総量 | `max(rate-2, Random)` | `rate` そのまま | 死んだ領域を削除 |
| 補正(ルート位置) | ライバハル÷強さ + スキルLv÷乱数 | `EffectiveRivahal + _nowSkillLevel/Random` | `_nowSkillLevel` | スキルLvが土台に昇格 |
| ライバハル | ルート位置の主成分 | `root ≒ Rivahal` | 揺れの増幅(×1〜×3) | 土台→増幅に降格 |
| 強さ(十日能力比較) | ライバハルを抑える除数 | `Rivahal/max(1,Adv)` | **削除** | RivahalDreamで反映済み |

### 問題解決マッピング

| # | 問題 | 解決方法 |
|---|------|---------|
| 1 | 負のレベル | `max(0, ...)` でクランプ |
| 2 | ゼロ除算 | TendayAdvantage自体を削除 |
| 3 | スキルLv無意味 | スキルLvが土台（主役に） |
| 4 | 調子が二択 | 連続値(-1〜+1) |
| 5 | 使いこなしの死に域 | `max(rate-2,Random)` を削除 |
| 6 | 強くなると弱くなる | TendayAdvantageを削除 |
| 7 | 常に無限ブランチ | ゆりかごLv ≒ スキルLv ± 数レベル |
| 8 | 戦闘開始クラッシュ | 土台=スキルLv、増幅=1.0 |

### 設計Q&A（議論の記録）

#### Q. ライバハルと使いこなしは同じ計算式なのに、なぜ2つあるの？

どちらも「攻撃者の対応十日能力 ÷ スキルの印象構造総量」という同じ式を使う。しかし**向きが違う**。

| | ライバハル（RivahalDream） | 使いこなし（cradle mastery） |
|---|---|---|
| **誰のおかげ？** | 相手のTLOAを食らったから | 自分の十日能力が合っているから |
| **結果が向かう先** | **相手**のRivahalに加算 | **自分**の揺れ幅に影響 |
| **いつからある？** | 戦闘中に蓄積（BM開始時0） | 戦闘前から存在（十日能力に依存） |
| **戦闘終了時** | 消える（0にリセット） | 残る |
| **性質** | 外的刺激の蓄積 | 内的素質 |

同じ「スキルとの相性」を測っているが、ライバハルでは「攻撃者の使いこなし度が高いほど、被害者がより認める」という外部への影響として使われ、使いこなしでは「自分がこのスキルに向いているほど、調子に大きく振り回される」という内部の振幅として使われる。

同じ物差しが2つの場面で意味を持つのは自然。重複ではなく、**同じ真実の別の現れ**。

#### Q. 使いこなしが高いと不調時にも大きく下がるの？

はい。掛け算だから。

```
揺れ = 調子 × 使いこなし × 戦闘増幅
```

使いこなしが高い人 = スキルと深く繋がっている人。

- 好調時: 共鳴して**大きく跳ねる**（+調子 × 高い使いこなし = 大きなプラス）
- 不調時: 不協和が**大きく響く**（-調子 × 高い使いこなし = 大きなマイナス）

使いこなしが低い人 = スキルとの繋がりが薄い人。

- 好調でも不調でもそこまで影響を受けない

**上手い人ほどムラが出る**。これがTLOAの「気持ちの問題」。

調子がちょうど0（普通）のとき: 使いこなし度がどんなに高くても揺れはゼロ。ゆりかごレベル = スキルレベルそのまま。

#### Q. 旧設計の `max(rate-2, Random(0~2))` は何だったの？

旧設計では使いこなし度がそのままレベルシフト量だった。「レベルが3も動くのはシビアだから2を引いてキャップしよう」という意図。

しかし実装としては:
- 使いこなし度0〜2: `rate-2`が負 → `Random(0~2)`に置き換わる → **使いこなし度が無意味**
- 使いこなし度2〜4: `rate-2`が0〜2 → `Random(0~2)`にまだ負ける → **まだ不安定**
- 使いこなし度4以上: やっとランダムに安定して勝つ

「キャップしたかった」のに「使いこなし度4未満を全部ランダムに置き換える死んだ領域」になっていた。

新設計ではこれが不要な理由: 旧設計のルート位置がライバハル（50〜200）だったから「揺れが数レベルでも影響が大きい」問題があった。新設計のルートはスキルレベル（0〜5程度）なので、±2〜3の揺れはむしろ**望ましい**動き。キャップ自体が不要になった。

### 調整ノブ

| パラメータ | 影響 | 推奨初期値 |
|-----------|------|-----------|
| 精神補正ratio | 精神属性の影響度 | 0.7 |
| 調子のspread | 調子の感度（小さい=敏感） | 3.5 |
| パーティ補正の大きさ | パーティ属性の影響度 | ±0.3 |
| K（馴化定数） | ライバハル増幅の立ち上がり速度 | 30 |
| R（最大増幅量） | ライバハルによる最大揺れ倍率 | 2 |
| F（フリーハンド係数） | フリーハンド時の負の調子→正の変換率 | 0.75 |

---

## 未実装・構想

### フリーハンドでのゆりかご優位 — 設計確定

**原典**: `武器システム.md:28` — 「TLOAのゆりかごで優位」

#### 概要

フリーハンド（無装備状態）でTLOAスキルを使うと、ゆりかご計算の「調子」が**感情変換**される。不調（負の調子）がTLOAの燃料に変換され、不調時でもゆりかごレベルが下がりにくくなる。

#### テーマ

武器を持つ人は、感情が乱れても武器という「型」に頼れる。フリーハンドは感情がむき出し。むき出しだからこそ、怒りも悲しみも**全てがTLOAの燃料になる**。

- 武器あり: 好調→強い、不調→弱い
- フリーハンド: 好調→強い、**不調→それでも強い**

#### 計算式

```
通常:
  揺れ = 調子 × 使いこなし × 戦闘増幅

フリーハンド:
  感情強度 = lerp(調子, |調子|, F)
  揺れ = 感情強度 × 使いこなし × 戦闘増幅
```

`F` = フリーハンド係数（0〜1の調整パラメータ）

`lerp(調子, |調子|, F)` は「負の感情をどれだけ正の燃料に変換するか」を制御する。

| 調子 | 通常 | F=0.5 | F=0.75 | F=1.0 |
|------|------|-------|--------|-------|
| +1.0（最高） | +1.0 | +1.0 | +1.0 | +1.0 |
| +0.5（やや好調） | +0.5 | +0.5 | +0.5 | +0.5 |
| 0（普通） | 0 | 0 | 0 | 0 |
| -0.5（やや不調） | -0.5 | 0 | **+0.25** | **+0.5** |
| -1.0（最悪） | -1.0 | 0 | **+0.5** | **+1.0** |

- F=0.5: 不調が帳消しされて0になる（安定型）
- F=0.75: 不調が正に転換される（推奨）
- F=1.0: 不調が好調と同じ強さになる（極端）

#### ゲームプレイ上の効果

- **TLOAビルド向けのトレードオフ**: フリーハンドは物理的に最弱の「武器」だが、TLOAスキルのゆりかごが安定して高くなる。物理攻撃力を犠牲にTLOAに特化する選択肢
- **逆境に強い**: 精神属性の相性が悪い相手（通常なら不調でTLOAが弱くなる）に対して、フリーハンドは逆にその不調を燃料にできる。物語的に「この怒りを全部TLOAにぶつける」
- **調子0が最弱点**: フリーハンドの唯一の弱点は「普通の調子」。感情の起伏がないとき、燃料も増幅もない。武器持ちと変わらない

#### 調整パラメータ

| パラメータ | 影響 | 推奨初期値 |
|-----------|------|-----------|
| F（フリーハンド係数） | 負の調子→正の変換率 | 0.75 |

武器システム仕様書の未実装一覧にも反映すること。

### 敵の初期スキルレベル指定

設計メモ（スキルレベル.md:36-39）に構想あり。NormalEnemyで初期スキルレベルを指定できる処理。同じスキルでも敵ごとにレベル差をつけて強さの差異を出す用途。未実装。

---

## 実装箇所一覧

### ゆりかご計算

| ファイル | 行 | 内容 |
|---------|-----|------|
| `BaseSkill.SkillLevel.cs` | 21-25 | レベルアップ定数（TLOA=120, 非TLOA=50） |
| `BaseSkill.SkillLevel.cs` | 35-48 | `_nowSkillLevel` プロパティ |
| `BaseSkill.SkillLevel.cs` | 54-65 | `FixedSkillLevelData`, 無限単位フィールド |
| `BaseSkill.SkillLevel.cs` | 76 | `_cradleSkillLevel` フィールド |
| `BaseSkill.SkillLevel.cs` | 81-119 | `CalcCradleSkillLevel()` 本体 |
| `BaseSkill.SkillLevel.cs` | 126-141 | `GetEstablishSpiritualMoodRange()` |
| `BaseSkill.SkillLevel.cs` | 145-220 | `ModifyMoodByAttributeCompatibility()` |
| `BaseSkill.SkillLevel.cs` | 234-296 | `SkillLevelData` クラス |

### ゆりかごレベルの使用箇所

| ファイル | 行 | 内容 |
|---------|-----|------|
| `BaseSkill.SkillPowe.cs` | 17-49 | `_skillPower(IsCradle)` — ゆりかごレベルでSkillPower算出 |
| `BaseSkill.SkillPowe.cs` | 53,57 | `GetSkillPower`, `GetSkillPowerForMental` |
| `BaseSkill.SkillPowe.cs` | 75,84 | `SkillPowerCalc`, `SkillPowerForMentalCalc` |
| `BaseSkill.TenDays.cs` | 16-47 | `TenDayValues(IsCradle)` — ゆりかごレベルで印象構造取得 |
| `AllySkill.cs` | 55-59 | `_skillPower` override（HP固定加算追加） |

### 呼び出し・伝播

| ファイル | 行 | 内容 |
|---------|-----|------|
| `BaseStates.CallBack.cs` | 89 | `OnAttackerOneSkillActStart` → `CalcCradleSkillLevel` |
| `BaseStates.ReactionSkill.cs` | 30 | `ComputeSkillPowers` → `SkillPowerCalc(skill.IsTLOA)` |
| `BaseStates.ReactionSkill.cs` | 965 | HIT分成長 → `TenDayValues(skill.IsTLOA)` |
| `BaseStates.ReactionSkill.cs` | 1265 | 戦闘外スキル → `CalcCradleSkillLevel(attacker, attacker)` |

### リセット

| ファイル | 行 | 内容 |
|---------|-----|------|
| `BaseSkill.CallBack.cs` | 44 | `OnBattleEnd` → `_cradleSkillLevel = -1` |

### ゆりかごが影響しないオプション値

| ファイル | 行 | 内容 |
|---------|-----|------|
| `BaseSkill.SkillHit.cs` | 22-51 | `SkillHitPer` — `_nowSkillLevel` 直接参照 |
| `BaseSkill.PowerSpread.cs` | — | 分散割合 — `_nowSkillLevel` 直接参照 |
| `BaseSkill.MentalDamageRatio.cs` | — | 精神攻撃率 — `_nowSkillLevel` 直接参照 |

---

## 設計メモソース

| ファイル | 内容 |
|---------|------|
| `スキルレベル.md` | ゆりかごシステムの設計構想、ルート位置・調子・上下レートの設計根拠 |
| `TLOAスキル.md` | TLOAスキルの全体仕様（ゆりかご化け、威力減衰、とどめ制限） |
| `武器システム.md` | フリーハンドでのゆりかご優位の原典（1行のみ） |
| `四大ステのステータスアップ.md` | HIT分成長でのゆりかご考慮 |

---

## データフロー図（カトレア案・実装済み）

```
[スキル実行開始]
  │
  ▼ OnAttackerOneSkillActStart(underAtker)
[CalcCradleSkillLevel]  ── BaseSkill.SkillLevel.cs
  │
  ├── 1. 調子（連続値 -1.0 ~ +1.0）
  │     精神補正値(ratio=0.7) → (value - center) / spread → clamp(-1, 1)
  │     + パーティ属性相性補正（±0.3）→ mood
  │
  ├── 2. 使いこなし
  │     Σ actor.BaseTenDayValues[スキルのキー] / TenDayValuesSum → mastery
  │     （素の十日能力。武器ボーナスなし）
  │
  ├── 3. 戦闘増幅
  │     Rivahal / (Rivahal + K=30) × R=2 + 1 → battleAmp
  │     （漸近的。Rivahal=30で×2、Rivahal=∞で×3）
  │
  ├── 4. フリーハンド感情転換（フリーハンド装備時のみ）
  │     emotionIntensity = lerp(mood, |mood|, F=0.75)
  │     （不調でもTLOAの燃料に変換）
  │
  └── 5. 最終合成
        swing = emotionIntensity × mastery × battleAmp
        _cradleSkillLevel = max(0, _nowSkillLevel + swing)
  │
  ▼ ComputeSkillPowers(IsCradle = skill.IsTLOA)
[SkillPowerCalc]
  ├── FixedSkillLevelData[_cradleSkillLevel].SkillPower × パッシブ乗算
  ├── × 精神補正(TLOA=40%)
  └── × 分散割合
  │
  ▼ HIT時
[TenDayGrowthListByHIT]
  └── TenDayValues(IsCradle = skill.IsTLOA) → ゆりかごレベルの印象構造で成長

[ライバハル蓄積]  ── BaseStates.StatesNumber.cs:RivahalDream
  ├── 総量方式: Σ attacker[スキルのキー] / Σ skill[values] → baseValue
  ├── × 精神補正(100%) → raw
  └── 馴化式: raw² / (raw + Rivahal × K=1.0) → 蓄積加算
      （Rivahalが多いほど新しい刺激の効きが減る）
```
