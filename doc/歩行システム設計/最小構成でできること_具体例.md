# 最小構成でできること 具体例

**最小構成**:
```
NodeSO
├─ nodeId, tags
├─ onEnter/onExit (基本Effect)
├─ encounters (baseRate + entries)
├─ ambientTalks (Step/Random/Flag)
└─ exits (conditions + toNodeId)
```

---

## 1. 基本の歩行と分岐

### できること
**一本道の進行**
```
森の入口 → 森の中 → 森の奥 → 出口
```

**分岐のある進行**
```
街の入口 → 広場
              ├─ 右の路地（条件: フラグ"key_A"）
              ├─ 左の路地（条件: フラグ"key_B"）
              └─ 正面の門（条件なし、デフォルト）
```

### 具体例
```csharp
// Node: 広場
exits = [
    { toNodeId: "right_alley", conditions: [HasFlag("key_A")] },
    { toNodeId: "left_alley", conditions: [HasFlag("key_B")] },
    { toNodeId: "main_gate", conditions: [] }  // 常に有効
]
```

**動作**: 
- `key_A`があれば右の路地に進める
- `key_B`があれば左の路地に進める
- 何もなければ正面の門に進む

---

## 2. フラグ管理

### できること
**イベント完了フラグ**
```
Node: クエスト受注所
onEnter: [SetFlag("quest_accepted")]
onExit: [SetFlag("left_quest_area")]
```

**分岐条件**
```
Node: 城門
exits = [
    { toNodeId: "castle_inside", conditions: [HasFlag("royal_pass")] },
    { toNodeId: "guard_stops_you", conditions: [Not(HasFlag("royal_pass"))] }
]
```

### 具体例シナリオ
```
1. 「酒場」でクエスト受注 → SetFlag("quest_accepted")
2. 「森」で敵を倒す → SetFlag("quest_complete")
3. 「酒場」に戻る → HasFlag("quest_complete") で報酬会話発火
4. 報酬受け取り → SetFlag("reward_received")
```

---

## 3. ランダムエンカウント

### できること
**基本的な敵遭遇**
```csharp
// Node: 危険な森
encounters = {
    baseRate: 0.25,  // 25%の確率で毎歩遭遇判定
    entries: [
        { encounter: "wolf", weight: 10 },
        { encounter: "bear", weight: 5 },
        { encounter: "bandit", weight: 3 }
    ]
}
```

**動作**:
- 毎歩25%の確率で遭遇判定
- 遭遇したら重みに応じて敵を選択
  - 狼: 10/18 ≒ 56%
  - 熊: 5/18 ≒ 28%
  - 盗賊: 3/18 ≒ 17%

### 条件付き出現
```csharp
entries: [
    { 
        encounter: "night_wolf", 
        weight: 15,
        conditions: [HasFlag("is_night")]  // 夜だけ出現
    },
    { 
        encounter: "day_deer", 
        weight: 10,
        conditions: [Not(HasFlag("is_night"))]  // 昼だけ出現
    }
]
```

### エリアごとの遭遇率変化
```
安全な街道: baseRate = 0.10 (10%)
普通の森: baseRate = 0.25 (25%)
危険な洞窟: baseRate = 0.40 (40%)
ボス前: baseRate = 0.00 (0%) ← 遭遇なし
```

---

## 4. 会話イベント

### できること

#### 4.1 歩数で発火する会話
```csharp
// Node: 長い廊下
ambientTalks: [
    {
        type: Step,
        stepMin: 5,
        dialogue: "仲間_不安な発言",
        once: true
    },
    {
        type: Step,
        stepMin: 10,
        dialogue: "仲間_励まし",
        once: true
    }
]
```

**動作**:
- 5歩目: 「ねえ、なんか嫌な予感がする...」
- 10歩目: 「大丈夫、一緒に乗り越えよう」

#### 4.2 ランダムで発火する会話
```csharp
ambientTalks: [
    {
        type: Random,
        p: 0.15,  // 毎歩15%の確率
        dialogue: "仲間_雑談",
        once: false,  // 何度でも
        cooldownSteps: 5  // 5歩はクールダウン
    }
]
```

**動作**:
- 歩くたびに15%の確率で雑談が発生
- 一度発生したら5歩はクールダウン

#### 4.3 フラグで発火する会話
```csharp
ambientTalks: [
    {
        type: Flag,
        flagKey: "found_clue",
        dialogue: "仲間_手がかり発見リアクション",
        once: true
    }
]
```

**動作**:
- 手がかりを見つけた（`found_clue`フラグ）後、次に歩いたときに会話発火

---

## 5. 進入/退出時の自動処理

### できること

#### 5.1 エリア進入時の自動フラグ設定
```csharp
// Node: 危険地帯
onEnter: [
    SetFlag("in_danger_zone"),
    SetFlag("visited_danger_zone")
]
```

#### 5.2 エリア退出時の自動処理
```csharp
// Node: ボス部屋
onExit: [
    UnsetFlag("in_boss_room"),
    SetFlag("boss_defeated")
]
```

#### 5.3 タグ管理
```csharp
// Node: 下水道エリア
onEnter: [
    AddTag("sewer_area"),
    AddTag("smelly_place")
]
onExit: [
    RemoveTag("sewer_area")
]
```

**用途**: タグで「今どんなエリアにいるか」を管理し、他のシステム（BGM、遭遇テーブル等）で参照

---

## 6. 複合的なシナリオ例

### シナリオ1: 鍵を探すクエスト

```
[街の広場]
├─ onEnter: なし
├─ exits:
│   ├─ 「地下牢」(条件: HasFlag("accepted_rescue_quest"))
│   └─ 「街の外」(条件なし)
└─ ambientTalks:
    └─ Step=0, dialogue="クエスト受注会話", once=true
        → SetFlag("accepted_rescue_quest")

↓ 地下牢へ

[地下牢]
├─ onEnter: SetFlag("in_dungeon")
├─ encounters:
│   └─ baseRate=0.3, entries=[ゴブリン, スケルトン]
├─ ambientTalks:
│   └─ Step=3, dialogue="鍵を発見", once=true
│       → SetFlag("found_key")
└─ exits:
    ├─ 「奥の牢屋」(条件: HasFlag("found_key"))
    └─ 「街の広場」(条件なし)

↓ 奥の牢屋へ

[奥の牢屋]
├─ onEnter: なし
├─ ambientTalks:
│   └─ Step=0, dialogue="囚人を救出", once=true
│       → SetFlag("rescued_prisoner")
└─ exits:
    └─ 「街の広場」(条件なし)

↓ 街の広場へ戻る

[街の広場]
└─ ambientTalks:
    └─ Flag="rescued_prisoner", dialogue="報酬会話", once=true
        → SetFlag("quest_complete")
```

**プレイヤー体験**:
1. 広場に着く → クエスト受注会話が自動発生 → 地下牢への道が開く
2. 地下牢に入る → ランダムエンカウント発生
3. 3歩進む → 「鍵を発見！」会話 → 奥への道が開く
4. 奥の牢屋に入る → 救出イベント
5. 広場に戻る → 報酬会話が自動発生

---

### シナリオ2: 夜と昼で変化する街

```
[街のメインストリート_昼]
├─ onEnter: UnsetFlag("is_night")
├─ encounters:
│   └─ baseRate=0.05  // 昼は平和
│       entries:
│         └─ 商人との遭遇, weight=10
├─ ambientTalks:
│   └─ Random, p=0.2, dialogue="昼の市場の賑わい"
└─ exits:
    ├─ 「宿屋」
    ├─ 「夜_就寝イベント」(条件: HasFlag("can_sleep"))
    └─ 「街の外」

↓ 宿屋で就寝

[夜_就寝イベント]
├─ onEnter: 
│   ├─ SetFlag("is_night")
│   └─ UnsetFlag("can_sleep")
└─ exits:
    └─ 「街のメインストリート_夜」

[街のメインストリート_夜]
├─ onEnter: SetFlag("in_night_area")
├─ encounters:
│   └─ baseRate=0.30  // 夜は危険
│       entries:
│         ├─ 盗賊, weight=8, conditions=[HasFlag("is_night")]
│         └─ 夜警, weight=5, conditions=[HasFlag("is_night")]
├─ ambientTalks:
│   └─ Random, p=0.1, dialogue="夜の不気味な雰囲気"
└─ exits:
    ├─ 「宿屋」
    ├─ 「朝_起床イベント」(条件: HasFlag("can_wake_up"))
    └─ 「街の外」
```

**プレイヤー体験**:
- 昼: 平和で商人と遭遇、市場の賑わい会話
- 就寝 → フラグ変更
- 夜: 遭遇率3倍、盗賊や夜警と遭遇、不気味な会話

---

### シナリオ3: 敵撃破数カウント（フラグの応用）

```
[訓練場エントランス]
├─ onEnter: 
│   ├─ SetFlag("training_start")
│   └─ SetFlag("enemies_defeated_0")  // カウント初期化
└─ exits:
    └─ 「訓練エリア」

[訓練エリア]
├─ encounters:
│   └─ baseRate=0.5  // 高頻度
│       entries:
│         └─ 訓練用ダミー, weight=10
│             → 撃破時に次のフラグに更新（戦闘システム側で）
│             enemies_defeated_0 → enemies_defeated_1
│             enemies_defeated_1 → enemies_defeated_2
│             ...
│             enemies_defeated_4 → enemies_defeated_5
└─ exits:
    ├─ 「訓練完了」(条件: HasFlag("enemies_defeated_5"))
    └─ 「訓練場エントランス」

[訓練完了]
├─ onEnter: SetFlag("training_complete")
└─ ambientTalks:
    └─ Step=0, dialogue="訓練完了おめでとう", once=true
```

**プレイヤー体験**:
1. 訓練エリアで敵を倒すたびにフラグが更新
2. 5体倒すと「訓練完了」への出口が開く
3. 完了エリアで祝福会話

---

## 6.5. 拡張要素でできること（TrackConfig/SpawnSource）

**注**: これらは最小構成には含まれませんが、Phase 3以降で追加できる機能です。最初からフィールドを用意しておけば、段階的に有効化できます。

---

### TrackConfigでできること

#### 概要
**TrackConfig**: ノード内部に「進行トラック（歩数）」を追加し、固定位置にイベント門を配置できる機能。

#### 6.5.1 固定位置のイベント門

**できること**: 「○歩目に必ず門が出現」

```csharp
// Node: 長い廊下
trackConfig = {
    length: 100,      // 全長100歩
    stepDelta: 1,     // 1歩ずつ進む
    gates: [
        {
            gateId: "boss_warning",
            position: 50,  // 50歩目で出現
            dialogue: "先に強敵の気配がする...",
            passConditions: [HasFlag("ready_for_boss")]
        },
        {
            gateId: "boss_gate",
            position: 90,  // 90歩目で出現
            dialogue: "ボスが立ちはだかる",
            passConditions: [HasFlag("boss_key")],
            onFail: Jump("need_key_hint")  // 鍵がないとヒントへ
        }
    ]
}
```

**プレイヤー体験**:
1. 廊下を歩く（通常の遭遇・会話）
2. 50歩目: 警告門が出現 → フラグがあればそのまま通過、なければヒント
3. 90歩目: ボス門が出現 → 鍵がないと進めない
4. 100歩: 出口に到達

**最小構成との違い**:
- ❌ 最小構成: 歩数会話（ambientTalks Step）で近似
- ✅ TrackConfig: 固定位置 + 通過条件 + 失敗時処理

---

#### 6.5.2 進捗ベースの出口制御

**できること**: 「○歩進まないと出口が開かない」

```csharp
// Node: 訓練エリア
trackConfig = {
    length: 50,
    stayPolicy: FixedSteps(50)  // 最低50歩
}
exits: [
    { toNodeId: "exit", conditions: [] }
]
```

**プレイヤー体験**:
- 訓練エリアで50歩歩くまで出口が開かない
- 50歩後に自動的に出口が有効になる

**最小構成との違い**:
- ❌ 最小構成: 出口の条件でフラグ管理（手動）
- ✅ TrackConfig: 自動で歩数管理

---

#### 6.5.3 複数門の配置

**できること**: 1つのノードに複数のイベント門を配置

```csharp
// Node: ダンジョン
trackConfig = {
    length: 200,
    gates: [
        { position: 30, dialogue: "宝箱発見", onPass: SetFlag("found_chest_1") },
        { position: 60, dialogue: "罠", onPass: SetFlag("triggered_trap") },
        { position: 100, dialogue: "中ボス", conditions: [HasFlag("mid_boss_key")] },
        { position: 150, dialogue: "休憩ポイント", onPass: Heal(50) },
        { position: 190, dialogue: "最終ボス門", conditions: [HasFlag("final_key")] }
    ]
}
```

**プレイヤー体験**:
- ダンジョンを進むと、決まった位置でイベントが発生
- 進行感のある構成が可能

---

#### 6.5.4 巻き戻し（Rewind）

**できること**: 門で失敗したら進捗を巻き戻す

```csharp
// Node: 難関ダンジョン
trackConfig = {
    length: 100,
    gates: [
        {
            position: 80,
            dialogue: "強力な結界",
            passConditions: [HasFlag("dispel_magic")],
            onFail: {
                rewind: true,        // 失敗時に巻き戻す
                rewindTo: 0,         // 0歩目に戻る
                hint: "魔法を解除する方法を探そう"
            }
        }
    ]
}
```

**プレイヤー体験**:
- 80歩目の門で失敗 → 自動的に入口に戻される
- ヒントが表示される

**最小構成との違い**:
- ❌ 最小構成: セーブ/ロードで手動対応
- ✅ TrackConfig: 自動巻き戻し

---

### SpawnSourceでできること

#### 概要
**SpawnSource**: 遭遇候補を複数のソース（ローカル、共有プール、タグクエリ）から合流させる機能。

#### 6.5.5 共有プールからの遭遇

**できること**: 複数のノードで同じ遭遇テーブルを共有

```csharp
// 共有プール定義
EncounterPoolSO "forest_common" {
    entries: [
        { encounter: "wolf", weight: 10 },
        { encounter: "deer", weight: 8 },
        { encounter: "boar", weight: 5 }
    ]
}

// Node: 森エリアA
encounters = {
    baseRate: 0.25,
    spawnSources: [
        { 
            type: PoolRef, 
            poolId: "forest_common",
            weightScale: 1.0  // 通常の重み
        },
        {
            type: LocalEntries,
            entries: [
                { encounter: "forest_boss_A", weight: 2 }  // エリア固有
            ]
        }
    ]
}

// Node: 森エリアB
encounters = {
    baseRate: 0.25,
    spawnSources: [
        { 
            type: PoolRef, 
            poolId: "forest_common",
            weightScale: 1.0
        },
        {
            type: LocalEntries,
            entries: [
                { encounter: "forest_boss_B", weight: 2 }  // エリア固有
            ]
        }
    ]
}
```

**プレイヤー体験**:
- 森エリアA/Bどちらでも共通の敵（wolf, deer, boar）が出現
- 各エリア固有のボスも出現
- プール変更で全エリアの遭遇を一括更新可能

**最小構成との違い**:
- ❌ 最小構成: 各ノードで個別に定義（重複が多い）
- ✅ SpawnSource: 共有プールで一元管理

---

#### 6.5.6 タグクエリによる動的合流

**できること**: タグで敵を検索して自動的に候補に追加

```csharp
// 敵定義
EncounterSO "wolf" { tags: ["forest", "hostile", "common"] }
EncounterSO "deer" { tags: ["forest", "neutral", "common"] }
EncounterSO "night_wolf" { tags: ["forest", "hostile", "night"] }

// Node: 森エリア（昼）
encounters = {
    baseRate: 0.25,
    spawnSources: [
        {
            type: TagQuery,
            tags: ["forest", "common"],  // forest AND common
            conditions: [Not(HasFlag("is_night"))]
        }
    ]
}
// → wolf, deerが自動で候補になる

// Node: 森エリア（夜）
encounters = {
    baseRate: 0.30,
    spawnSources: [
        {
            type: TagQuery,
            tags: ["forest", "night"],  // forest AND night
            conditions: [HasFlag("is_night")]
        }
    ]
}
// → night_wolfが自動で候補になる
```

**プレイヤー体験**:
- 昼: 通常の森の敵が出現
- 夜: 夜限定の敵が出現
- 新しい敵を追加すると、タグに応じて自動的に候補に入る

**最小構成との違い**:
- ❌ 最小構成: 各ノードで個別に指定
- ✅ SpawnSource: タグで自動合流、拡張が容易

---

#### 6.5.7 複数ソースの合流と重み調整

**できること**: ローカル + プール + タグクエリを組み合わせ

```csharp
// Node: 複雑なエリア
encounters = {
    baseRate: 0.25,
    spawnSources: [
        // 1. ローカルの必須敵
        {
            type: LocalEntries,
            entries: [
                { encounter: "area_boss", weight: 3 }
            ]
        },
        // 2. 共有プール（重み半減）
        {
            type: PoolRef,
            poolId: "dungeon_common",
            weightScale: 0.5  // 重みを半分に
        },
        // 3. タグクエリ（条件付き）
        {
            type: TagQuery,
            tags: ["dungeon", "elite"],
            conditions: [HasFlag("hard_mode")],
            weightScale: 2.0  // 重みを2倍に
        }
    ]
}
```

**最終候補**: 
- area_boss: 重み3
- dungeon_commonの敵: 重み×0.5
- hard_mode中のelite敵: 重み×2.0

**プレイヤー体験**:
- 複雑な遭遇構成を柔軟に管理
- 難易度調整が容易

---

### TrackConfig/SpawnSourceのまとめ

#### TrackConfigでできること
1. ✅ **固定位置のイベント門**（○歩目に必ず出現）
2. ✅ **進捗ベースの出口制御**（○歩歩かないと出られない）
3. ✅ **複数門の配置**（1ノードに複数イベント）
4. ✅ **巻き戻し**（門失敗時に自動で戻る）
5. ✅ **通過条件と失敗処理**（鍵がないと進めない等）

#### SpawnSourceでできること
1. ✅ **共有プール**（複数ノードで遭遇テーブル共有）
2. ✅ **タグクエリ**（タグで敵を検索して自動合流）
3. ✅ **複数ソース合流**（ローカル+プール+タグ）
4. ✅ **重み調整**（ソースごとに倍率変更）
5. ✅ **一元管理**（プール変更で全体に反映）

#### 最小構成との違い
| 機能 | 最小構成 | TrackConfig/SpawnSource |
|------|---------|------------------------|
| 固定位置イベント | 歩数会話で近似 | 門として実装 |
| 進捗管理 | フラグで手動 | 自動で管理 |
| 遭遇管理 | 各ノードで個別 | 共有プールで一元管理 |
| 拡張性 | 低い | 高い |
| 保守性 | 低い（重複多） | 高い（一元管理） |

---

## 7. できないこと（拡張要素が必要）

### ❌ 天気・時間帯の自動変化
- **理由**: Overlay（Night, 天候等）を削除
- **代替**: フラグで手動管理（例: `SetFlag("is_night")`）

### ❌ 固定位置のイベント門
- **理由**: TrackConfig、GateMarkerを削除
- **代替**: 歩数会話（ambientTalks Step）で近似

### ❌ 状態の巻き戻し
- **理由**: Anchor/Rewindを削除
- **代替**: セーブ/ロードで対応

### ❌ 動的な重み変化
- **理由**: WeightMod/CurveByCounterを削除
- **代替**: 固定重みのみ

### ❌ 連発抑止の自動管理
- **理由**: varietyBiasを削除
- **代替**: cooldownStepsで最低限対応可能

---

## 8. 実装の簡潔さ

### 最小構成のNodeSO（約50行）
```csharp
[CreateAssetMenu(menuName="Walk/Node")]
public class NodeSO : ScriptableObject {
    public string nodeId;
    public string[] tags;
    
    public EffectSO[] onEnter;
    public EffectSO[] onExit;
    
    public EncounterTableSO encounters;
    public AmbientTalkTrigger[] ambientTalks;
    public ExitCandidate[] exits;
}
```

### 実装工数比較
```
完全版（全要素）: 4-6週間
最小構成: 1-2週間  ← 半分以下
```

---

## 9. まとめ: 最小構成でできること

### ✅ できること
1. **一本道・分岐の進行**
   - 条件付き分岐（フラグ、アイテム等）
   
2. **ランダムエンカウント**
   - エリアごとの遭遇率設定
   - 敵の重み付き抽選
   - 条件付き出現（フラグ依存）
   
3. **会話イベント**
   - 歩数で発火
   - ランダムで発火
   - フラグで発火
   - 一度きり/繰り返し/クールダウン
   
4. **フラグ管理**
   - 進行状態の記録
   - 条件分岐の判定
   - クエスト進行管理
   
5. **エリア進入/退出処理**
   - 自動フラグ設定
   - タグ管理
   
6. **複合シナリオ**
   - クエストシステム
   - 昼夜切り替え（フラグベース）
   - カウントベースの進行

### 🎮 ゲームとして成立するか？
**完全に成立します。**

- RPGの基本ループ: ✅ 完備
- ストーリー分岐: ✅ 可能
- クエストシステム: ✅ 実装可能
- エリア間遷移: ✅ スムーズ

### 📊 削減した要素の影響
- **天気・時間**: フラグで代用可能（`is_night`, `is_raining`等）
- **固定イベント門**: 歩数会話で代用可能
- **複雑な重み制御**: 固定重みで十分
- **連発抑止**: cooldownで最低限対応

---

## 結論

**最小構成でも、RPGとして完全に機能するゲームループが実現できます。**

```
歩く → 遭遇 → 戦闘 → 会話 → フラグ更新 → 分岐
```

この基本ループに必要なすべての要素が揃っており、複雑なシナリオも構築可能です。拡張要素は「便利機能」であり、無くてもゲームは完成します。
