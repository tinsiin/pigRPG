# ゼロトタイプ歩行システム仕様書

本書は実装の詳細仕様を記録する。設計意図については「ゼロトタイプ歩行システム設計書」を参照。

---

## イベント門と出口の位置計算（ハードル並び設計）

### 概要

イベント門と出口は「ハードルの並び」として設計されている。各障壁は前の障壁を越えた先に配置され、設定値がそのまま「越えるべき距離」となる。

### 位置の解釈

| 要素 | 設定値の意味 | 実際の出現位置 |
|------|-------------|---------------|
| イベント門 | 開始地点からの絶対位置 | `TrackProgress >= 設定値` |
| 出口 | 最後の門からの相対距離 | `TrackProgress >= 最大門位置 + 設定値` |

### 計算式

```
出口の実際位置 = max(全門の解決位置) + 出口の設定歩数
```

門がない場合は `max = 0` となり、出口の設定値がそのまま絶対位置となる。

### 具体例

**設定:**
- 門1: 30歩
- 門2: 50歩
- 出口: 100歩

**実際の動作:**
1. 開始（TrackProgress=0）
2. 30歩で門1出現
3. 50歩で門2出現
4. 門2通過後「あと100歩」と表示
5. 150歩（= max(30,50) + 100）で出口出現

### 設計意図

- 門と出口を独立して設定可能（兼ね合いを考える必要がない）
- 「門を100歩に、出口を50歩に」と設定すれば、門通過後50歩で出口が出る
- 直感的な数値設定が可能

### 関連コード

- `GateResolver.GetMaxResolvedPosition()` - 最大門位置の取得
- `ExitSpawnRule.ShouldSpawn()` - 出口出現判定
- `ProgressCalculator.CalculateExitPosition()` - 出口位置計算

---

## WalkStep 処理順序（現在の仕様）

### 概要

`AreaController.WalkStep()` が1歩ごとに実行する処理の順序を定義する。

### 処理順序

```
WalkStep()
│
├── 1. ノード同期チェック
│       └── Anchor rewind後にノードが変わっていないか確認
│
├── 2. リフレッシュ処理（巻き戻し後）
│       └── RequestRefreshWithoutStep が true の場合、カウンタを進めずにUI更新のみ
│
├── 3. ノード入場イベント
│       └── hasEnteredCurrentNode が false の場合、OnEnterEvent を発火
│       └── 初回入場時のみ実行
│
├── 4. カウンタ進行
│       ├── Counters.Advance(1) - GlobalSteps, NodeSteps, TrackProgress を+1
│       └── UpdateTrackProgress() - TrackConfig に基づく追加進行
│
├── 5. クールダウン進行
│       ├── sideObjectSelector.AdvanceStep() - サイドオブジェクトのクールダウン
│       └── context.AdvanceEncounterOverlays() - エンカウントオーバーレイ
│
├── 6. サイドオブジェクト抽選
│       └── RollPair() でその歩の左右オブジェクトを決定
│
├── 7. 中央オブジェクト取得
│       └── CentralEvent と CentralVisual を取得
│
├── 8. アプローチオブジェクト表示
│       └── ShowApproachObjects() で左右・中央を画面に表示
│
├── 9. ゲートチェック
│       └── CheckGates() でゲート出現・通過・失敗を処理
│       └── ゲート処理が発生した場合は return（後続処理スキップ）
│
├── 10. エンカウント判定
│       └── encounterResolver.Resolve() で敵遭遇を判定
│       └── 遭遇した場合は RunEncounter() で戦闘実行
│       └── 戦闘結果イベント（OnWin/OnLose/OnEscape）を発火
│
├── 11. 強制イベントチェック
│       └── CheckForcedEvents() で歩数/確率トリガーを判定
│       └── 発火した場合は return（後続処理スキップ）
│
├── 12. アプローチ処理
│       └── HandleApproach() でユーザーの選択を待機
│       └── 左/右/中央/スキップ の選択に応じてイベント発火
│
├── 13. リワインドチェック
│       └── イベントで RewindToAnchorEffect が発火した場合は return
│
└── 14. 出口チェック
        └── ExitSpawn.ShouldSpawn() で出口出現を判定
        └── 出口選択 → ノード遷移 → OnExitEvent 発火
```

### 各処理の詳細

| # | 処理 | 発火するイベント | 中断条件 |
|---|------|----------------|---------|
| 3 | ノード入場 | OnEnterEvent | - |
| 9 | ゲートチェック | GateEvent (OnAppear/OnPass/OnFail) | ゲート処理発生時 |
| 10 | エンカウント | OnWin/OnLose/OnEscape | - |
| 11 | 強制イベント | ForcedEventTrigger.Dialogue | イベント発火時 |
| 12 | アプローチ | SideObject.Event / CentralEvent | - |
| 14 | 出口 | OnExitEvent | 出口選択時 |

### 中断（return）の影響

| 中断ポイント | スキップされる処理 |
|-------------|------------------|
| ゲート処理後 | エンカウント、強制イベント、アプローチ、出口 |
| 強制イベント後 | アプローチ、出口 |
| リワインド後 | 出口 |

### 関連コード

- `AreaController.WalkStep()` - メイン処理ループ
- `AreaController.CheckGates()` - ゲート処理
- `AreaController.CheckForcedEvents()` - 強制イベント処理
- `AreaController.HandleApproach()` - アプローチ処理

---

## EventStepシステム（拡張可能イベント機構）

### 概要

EventStepシステムは、全てのイベントポイントから統一的にゲームシステム（会話、戦闘、Effect等）を起動可能にする拡張可能な基盤。

### アーキテクチャ

```
EventDefinitionSO
├── steps: IEventStep[] ([SerializeReference])
│   ├── MessageStep        → 旧EventStep互換（メッセージ+選択肢）
│   ├── NovelDialogueStep  → ノベルパート会話（DialogueSO参照）
│   ├── BattleStep         → 戦闘起動（EncounterSO参照）
│   ├── EmitEventStep      → 別EventDefinitionSO呼び出し
│   └── EffectStep         → Effect適用のみ
└── terminalEffects: EffectSO[]
```

### IEventStepインターフェース

```csharp
public interface IEventStep
{
    UniTask<EffectSO[]> ExecuteAsync(EventContext context);
}
```

各Stepは実行後にEffectSO配列を返し、EventRunnerが最後にまとめて適用する。

### EventContext（依存注入）

```csharp
public sealed class EventContext
{
    public GameContext GameContext { get; set; }
    public IEventUI EventUI { get; set; }
    public INovelEventUI NovelUI { get; set; }
    public IDialogueRunner DialogueRunner { get; set; }
    public IBattleRunner BattleRunner { get; set; }
    public IEventRunner EventRunner { get; set; }
    public RectTransform CentralObjectRT { get; set; }
    public List<EffectSO> CollectedEffects { get; }
}
```

### Step型一覧

| Step型 | 用途 | 主なフィールド |
|--------|------|---------------|
| MessageStep | メッセージ表示+選択肢 | message, choices, effects |
| NovelDialogueStep | ノベルパート会話 | dialogueData, displayMode, zoomOnApproach, allowBacktrack |
| BattleStep | 戦闘起動 | encounter, overrideOutcomeEffects, onWin/onLose/onEscape |
| EmitEventStep | 別EventDefinition呼び出し | eventRef |
| EffectStep | Effect適用のみ | effects |

### 実行フロー

```
EventHost.TriggerWithContext(EventDefinitionSO, EventContext)
    ↓
EventRunner.RunAsync(definition, context)
    ↓
foreach step in definition.steps:
    effects += await step.ExecuteAsync(context)
    ↓
EffectApplier.ApplyAll(effects + terminalEffects)
```

### イベントポイント一覧

全てEventDefinitionSOを使用し、任意のStep型を組み合わせ可能:

| イベントポイント | 説明 |
|-----------------|------|
| NodeSO.OnEnter | ノード入場時 |
| NodeSO.OnExit | ノード退場時 |
| NodeSO.CentralEvent | 中央オブジェクトアプローチ時 |
| GateMarker.OnAppear/OnPass/OnFail | ゲート出現・通過・失敗時 |
| SideObject.Event | サイドオブジェクト選択時 |
| ForcedEventTrigger.eventDefinition | 強制イベント発火時 |
| EncounterSO.OnWin/OnLose/OnEscape | 戦闘結果時 |

### 関連コード

- `Assets/Script/Walk/EventKernel/IEventStep.cs` - インターフェース定義
- `Assets/Script/Walk/EventKernel/EventDefinitionSO.cs` - SO定義
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - 実行エンジン
- `Assets/Script/Walk/EventKernel/EventHost.cs` - 発火ホスト
- `Assets/Script/Walk/EventKernel/Steps/` - 各Step実装

### 詳細設計

詳細は [EventStep統合実装計画.md](./EventStep統合実装計画.md) を参照。

---

## EventQueue共通規格（イベント選択の仕組み）

### 概要

歩行システムの各「容器」（サイドオブジェクト、中央オブジェクト、ゲート等）が**どのイベントを発火するか**を選択するための共通規格。

**重要な区別:**
- **イベント** = `EventDefinitionSO` + `IEventStep[]`（前述のEventStepシステム）
- **EventQueue** = 容器が複数のイベント候補から1つを選ぶ仕組み

EventQueueはイベント自体を変更するものではない。容器側の「イベント選択ロジック」を統一する規格。

### なぜ必要か

従来は各容器が単一の`EventDefinitionSO`しか持てなかった:

```csharp
// 旧: 1つのイベントしか設定できない
public EventDefinitionSO eventDefinition;
```

これでは以下ができなかった:
- 初回だけ別のイベントを発火する
- フラグによってイベントを切り替える
- 一度見たイベントをスキップして次へ進む

### EventQueueEntry

各容器は `EventQueueEntry[]` 配列を持つ:

```csharp
[Serializable]
public sealed class EventQueueEntry
{
    string entryId;              // 状態管理用の識別子
    EventDefinitionSO eventDefinition;  // 発火するイベント
    ConditionSO[] conditions;    // 発火条件
    bool consumeOnTrigger;       // true=1回限り、false=何度でも
    int cooldownSteps;           // 再発火までの歩数（0=即可）
    int maxTriggerCount;         // 最大発火回数（0=無制限）
}
```

### 発火ロジック

配列を上から順に評価し、最初に条件を満たすエントリを発火:

```
foreach entry in entries:
    if 消費済み → スキップ
    if 最大回数到達 → スキップ
    if クールダウン中 → スキップ
    if 条件不一致 → スキップ
    → このエントリを発火して終了

全てスキップ → 発火なし
```

### 使用例

```yaml
CentralObjectSO: 商人NPC
  events:
    - entryId: "first_meet"
      eventDefinition: FirstMeetDialogue
      consumeOnTrigger: true   # 1回限り

    - entryId: "quest_complete"
      eventDefinition: QuestCompleteDialogue
      conditions: [HasFlag("quest_item")]
      consumeOnTrigger: true

    - entryId: "default"
      eventDefinition: ShopDialogue
      consumeOnTrigger: false  # 何度でも
```

動作:
1. 初回 → `first_meet` 発火（消費）
2. クエストアイテム持参時 → `quest_complete` 発火（消費）
3. それ以外 → `default` 発火（毎回）

### 新しい容器を作る場合

歩行システムに新しいイベント容器（SO）を追加する場合、以下を実装する:

**1. フィールド定義**
```csharp
[SerializeField] private EventQueueEntry[] events;
public EventQueueEntry[] Events => events;
```

**2. 発火処理**
```csharp
// AreaController内
var eventDef = eventQueueResolver.ResolveNext(
    container.Events,           // EventQueueEntry[]
    hostKey,                    // 状態管理用のキー
    context,                    // GameContext
    context.EventEntryStateManager
);
if (eventDef != null)
{
    await TriggerEvent(eventDef);
}
```

**3. hostKey命名規則**

状態は `{hostKey}:{entryId}` で管理される。hostKeyは以下の形式:

| 容器の種類 | hostKey形式 | 例 |
|-----------|------------|-----|
| 中央オブジェクト | `central:{id}` | `central:npc_merchant` |
| サイドオブジェクト | `side:{id}` | `side:treasure_chest` |
| ゲート | `gate:{id}` | `gate:boss_gate` |
| ノード入退場 | `node:{nodeId}:{timing}` | `node:forest:enter` |
| エンカウント結果 | `encounter:{id}:{outcome}` | `encounter:goblin:win` |
| 強制イベント | `forced:{nodeId}:{triggerId}` | `forced:forest:story_01` |

**注意**: hostKeyにノードIDを含めない場合（中央/サイド/ゲート等）、同じ容器は**ノード間で状態を共有**する。別状態にしたい場合は別の容器SOを作成する。

### 適用済み容器一覧

| 容器 | フィールド |
|------|-----------|
| CentralObjectSO | `events` |
| SideObjectSO | `events` |
| GateMarker | `gateEvents` |
| NodeSO | `onEnterEvents`, `onExitEvents` |
| EncounterSO | `onWinEvents`, `onLoseEvents`, `onEscapeEvents` |

### 状態の永続化

`EventEntryStateManager`が全容器の発火状態を統合管理し、`WalkProgressData`経由でセーブ/ロードされる。

### 関連コード

- `Assets/Script/Walk/EventQueue/EventQueueEntry.cs` - エントリ定義
- `Assets/Script/Walk/EventQueue/EventQueueResolver.cs` - 発火判定
- `Assets/Script/Walk/EventQueue/EventEntryStateManager.cs` - 状態管理
- `Assets/Script/Walk/EventQueue/EventQueueEntryState.cs` - 状態データ

### 詳細設計

詳細は [EventQueue共通規格設計.md](./EventQueue共通規格設計.md) を参照。

---

## 戦闘敗北/逃走時のRewind仕様

### 概要

戦闘敗北（Defeat）または逃走（Escape）時の歩数巻き戻し（Rewind）は、**ランダムエンカウントのみ自動適用**。その他のイベント経由戦闘では明示的にEffectで指定する。

### Rewind適用ルール

| 戦闘経路 | 自動Rewind | 明示的指定 |
|---------|-----------|-----------|
| ランダムエンカウント | ✅ 10歩巻き戻し | - |
| BattleStep | ❌ なし | onLose/onEscapeにEffect追加で可能 |
| リアクション戦闘 | ❌ なし | EncounterSO.OnLose/OnEscapeで可能 |

### 設計意図

- **ランダムエンカウント**: システム組み込みのペナルティとして自動Rewind。プレイヤーの進行ペースを調整する役割
- **イベント戦闘**: シナリオ上の意図が様々（ボス戦、強制敗北イベント等）なので、デザイナーが明示的に制御

### 実装箇所

**ランダムエンカウント（自動）:**
```csharp
// AreaController.HandleEncounterOutcome()
if (outcome == BattleOutcome.Defeat || outcome == BattleOutcome.Escape)
{
    context.Counters.Rewind(RewindStepsOnFail);  // 10歩
    sideObjectSelector.ClearPending();
    // サイドオブジェクト再抽選...
}
```

**イベント戦闘（明示的）:**
```yaml
# BattleStepでの例
- BattleStep:
    encounter: "BossEncounter"
    overrideOutcomeEffects: true
    onLose:
      - RewindCountersEffect(10)  # 明示的に指定
      - Jump("RecoveryNode")
```

### 関連コード

- `AreaController.HandleEncounterOutcome()` - ランダムエンカウントのRewind処理
- `AreaController.RewindStepsOnFail` - Rewind歩数定数（10）
- `BattleStep.onLose/onEscape` - イベント戦闘の結果Effect
