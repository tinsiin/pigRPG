# ゼロトタイプ歩行システム仕様書

本書は実装の詳細仕様を記録する。設計意図については「ゼロトタイプ歩行システム設計書」を参照。

---

## イベント門と出口の位置計算（ハードル並び設計）

### 概要

イベント門と出口は「ハードルの並び」として設計されている。各障壁は前の障壁を越えた先に配置され、設定値がそのまま「越えるべき距離」となる。

### 位置の解釈

| 要素 | 設定値の意味 | 実際の出現位置 |
|------|-------------|---------------|
| イベント門 | 開始地点からの絶対位置 | `TrackProgress >= 設定値` |
| 出口 | 最後の門からの相対距離 | `TrackProgress >= 最大門位置 + 設定値` |

### 計算式

```
出口の実際位置 = max(全門の解決位置) + 出口の設定歩数
```

門がない場合は `max = 0` となり、出口の設定値がそのまま絶対位置となる。

### 具体例

**設定:**
- 門1: 30歩
- 門2: 50歩
- 出口: 100歩

**実際の動作:**
1. 開始（TrackProgress=0）
2. 30歩で門1出現
3. 50歩で門2出現
4. 門2通過後「あと100歩」と表示
5. 150歩（= max(30,50) + 100）で出口出現

### 設計意図

- 門と出口を独立して設定可能（兼ね合いを考える必要がない）
- 「門を100歩に、出口を50歩に」と設定すれば、門通過後50歩で出口が出る
- 直感的な数値設定が可能

### 関連コード

- `GateResolver.GetMaxResolvedPosition()` - 最大門位置の取得
- `ExitSpawnRule.ShouldSpawn()` - 出口出現判定
- `ProgressCalculator.CalculateExitPosition()` - 出口位置計算

---

## WalkStep 処理順序（現在の仕様）

### 概要

`AreaController.WalkStep()` が1歩ごとに実行する処理の順序を定義する。

### 処理順序

```
WalkStep()
│
├── 1. ノード同期チェック
│       └── Anchor rewind後にノードが変わっていないか確認
│
├── 2. リフレッシュ処理（巻き戻し後）
│       └── RequestRefreshWithoutStep が true の場合、カウンタを進めずにUI更新のみ
│
├── 3. ノード入場イベント
│       └── hasEnteredCurrentNode が false の場合、OnEnterEvent を発火
│       └── 初回入場時のみ実行
│
├── 4. カウンタ進行
│       ├── Counters.Advance(1) - GlobalSteps, NodeSteps, TrackProgress を+1
│       └── UpdateTrackProgress() - TrackConfig に基づく追加進行
│
├── 5. クールダウン進行
│       ├── sideObjectSelector.AdvanceStep() - サイドオブジェクトのクールダウン
│       └── context.AdvanceEncounterOverlays() - エンカウントオーバーレイ
│
├── 6. サイドオブジェクト抽選
│       └── RollPair() でその歩の左右オブジェクトを決定
│
├── 7. 中央オブジェクト取得
│       └── CentralEvent と CentralVisual を取得
│
├── 8. アプローチオブジェクト表示
│       └── ShowApproachObjects() で左右・中央を画面に表示
│
├── 9. ゲートチェック
│       └── CheckGates() でゲート出現・通過・失敗を処理
│       └── ゲート処理が発生した場合は return（後続処理スキップ）
│
├── 10. エンカウント判定
│       └── encounterResolver.Resolve() で敵遭遇を判定
│       └── 遭遇した場合は RunEncounter() で戦闘実行
│       └── 戦闘結果イベント（OnWin/OnLose/OnEscape）を発火
│
├── 11. 強制イベントチェック
│       └── CheckForcedEvents() で歩数/確率トリガーを判定
│       └── 発火した場合は return（後続処理スキップ）
│
├── 12. アプローチ処理
│       └── HandleApproach() でユーザーの選択を待機
│       └── 左/右/中央/スキップ の選択に応じてイベント発火
│
├── 13. リワインドチェック
│       └── イベントで RewindToAnchorEffect が発火した場合は return
│
└── 14. 出口チェック
        └── ExitSpawn.ShouldSpawn() で出口出現を判定
        └── 出口選択 → ノード遷移 → OnExitEvent 発火
```

### 各処理の詳細

| # | 処理 | 発火するイベント | 中断条件 |
|---|------|----------------|---------|
| 3 | ノード入場 | OnEnterEvent | - |
| 9 | ゲートチェック | GateEvent (OnAppear/OnPass/OnFail) | ゲート処理発生時 |
| 10 | エンカウント | OnWin/OnLose/OnEscape | - |
| 11 | 強制イベント | ForcedEventTrigger.Dialogue | イベント発火時 |
| 12 | アプローチ | SideObject.Event / CentralEvent | - |
| 14 | 出口 | OnExitEvent | 出口選択時 |

### 中断（return）の影響

| 中断ポイント | スキップされる処理 |
|-------------|------------------|
| ゲート処理後 | エンカウント、強制イベント、アプローチ、出口 |
| 強制イベント後 | アプローチ、出口 |
| リワインド後 | 出口 |

### 関連コード

- `AreaController.WalkStep()` - メイン処理ループ
- `AreaController.CheckGates()` - ゲート処理
- `AreaController.CheckForcedEvents()` - 強制イベント処理
- `AreaController.HandleApproach()` - アプローチ処理

---

## EventStepシステム（拡張可能イベント機構）

### 概要

EventStepシステムは、全てのイベントポイントから統一的にゲームシステム（会話、戦闘、Effect等）を起動可能にする拡張可能な基盤。

### アーキテクチャ

```
EventDefinitionSO
├── steps: IEventStep[] ([SerializeReference])
│   ├── MessageStep        → 旧EventStep互換（メッセージ+選択肢）
│   ├── NovelDialogueStep  → ノベルパート会話（DialogueSO参照）
│   ├── BattleStep         → 戦闘起動（EncounterSO参照）
│   ├── EmitEventStep      → 別EventDefinitionSO呼び出し
│   └── EffectStep         → Effect適用のみ
└── terminalEffects: EffectSO[]
```

### IEventStepインターフェース

```csharp
public interface IEventStep
{
    UniTask<EffectSO[]> ExecuteAsync(EventContext context);
}
```

各Stepは実行後にEffectSO配列を返し、EventRunnerが最後にまとめて適用する。

### EventContext（依存注入）

```csharp
public sealed class EventContext
{
    public GameContext GameContext { get; set; }
    public IEventUI EventUI { get; set; }
    public INovelEventUI NovelUI { get; set; }
    public IDialogueRunner DialogueRunner { get; set; }
    public IBattleRunner BattleRunner { get; set; }
    public IEventRunner EventRunner { get; set; }
    public RectTransform CentralObjectRT { get; set; }
    public List<EffectSO> CollectedEffects { get; }
}
```

### Step型一覧

| Step型 | 用途 | 主なフィールド |
|--------|------|---------------|
| MessageStep | メッセージ表示+選択肢 | message, choices, effects |
| NovelDialogueStep | ノベルパート会話 | dialogueData, displayMode, zoomOnApproach, allowBacktrack |
| BattleStep | 戦闘起動 | encounter, overrideOutcomeEffects, onWin/onLose/onEscape |
| EmitEventStep | 別EventDefinition呼び出し | eventRef |
| EffectStep | Effect適用のみ | effects |

### 実行フロー

```
EventHost.TriggerWithContext(EventDefinitionSO, EventContext)
    ↓
EventRunner.RunAsync(definition, context)
    ↓
foreach step in definition.steps:
    effects += await step.ExecuteAsync(context)
    ↓
EffectApplier.ApplyAll(effects + terminalEffects)
```

### イベントポイント一覧

全てEventDefinitionSOを使用し、任意のStep型を組み合わせ可能:

| イベントポイント | 説明 |
|-----------------|------|
| NodeSO.OnEnter | ノード入場時 |
| NodeSO.OnExit | ノード退場時 |
| NodeSO.CentralEvent | 中央オブジェクトアプローチ時 |
| GateMarker.OnAppear/OnPass/OnFail | ゲート出現・通過・失敗時 |
| SideObject.Event | サイドオブジェクト選択時 |
| ForcedEventTrigger.eventDefinition | 強制イベント発火時 |
| EncounterSO.OnWin/OnLose/OnEscape | 戦闘結果時 |

### 関連コード

- `Assets/Script/Walk/EventKernel/IEventStep.cs` - インターフェース定義
- `Assets/Script/Walk/EventKernel/EventDefinitionSO.cs` - SO定義
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - 実行エンジン
- `Assets/Script/Walk/EventKernel/EventHost.cs` - 発火ホスト
- `Assets/Script/Walk/EventKernel/Steps/` - 各Step実装

### 詳細設計

詳細は [EventStep統合実装計画.md](./EventStep統合実装計画.md) を参照。

---

## 戦闘敗北/逃走時のRewind仕様

### 概要

戦闘敗北（Defeat）または逃走（Escape）時の歩数巻き戻し（Rewind）は、**ランダムエンカウントのみ自動適用**。その他のイベント経由戦闘では明示的にEffectで指定する。

### Rewind適用ルール

| 戦闘経路 | 自動Rewind | 明示的指定 |
|---------|-----------|-----------|
| ランダムエンカウント | ✅ 10歩巻き戻し | - |
| BattleStep | ❌ なし | onLose/onEscapeにEffect追加で可能 |
| リアクション戦闘 | ❌ なし | EncounterSO.OnLose/OnEscapeで可能 |

### 設計意図

- **ランダムエンカウント**: システム組み込みのペナルティとして自動Rewind。プレイヤーの進行ペースを調整する役割
- **イベント戦闘**: シナリオ上の意図が様々（ボス戦、強制敗北イベント等）なので、デザイナーが明示的に制御

### 実装箇所

**ランダムエンカウント（自動）:**
```csharp
// AreaController.HandleEncounterOutcome()
if (outcome == BattleOutcome.Defeat || outcome == BattleOutcome.Escape)
{
    context.Counters.Rewind(RewindStepsOnFail);  // 10歩
    sideObjectSelector.ClearPending();
    // サイドオブジェクト再抽選...
}
```

**イベント戦闘（明示的）:**
```yaml
# BattleStepでの例
- BattleStep:
    encounter: "BossEncounter"
    overrideOutcomeEffects: true
    onLose:
      - RewindCountersEffect(10)  # 明示的に指定
      - Jump("RecoveryNode")
```

### 関連コード

- `AreaController.HandleEncounterOutcome()` - ランダムエンカウントのRewind処理
- `AreaController.RewindStepsOnFail` - Rewind歩数定数（10）
- `BattleStep.onLose/onEscape` - イベント戦闘の結果Effect
