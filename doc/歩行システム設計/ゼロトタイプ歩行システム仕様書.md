# ゼロトタイプ歩行システム仕様書

本書は実装の詳細仕様を記録する。設計意図については「ゼロトタイプ歩行システム設計書」を参照。

---

## イベント門と出口の位置計算（ハードル並び設計）

### 概要

イベント門と出口は「ハードルの並び」として設計されている。各障壁は前の障壁を越えた先に配置され、設定値がそのまま「越えるべき距離」となる。

### 位置の解釈

| 要素 | 設定値の意味 | 実際の出現位置 |
|------|-------------|---------------|
| イベント門 | 開始地点からの絶対位置 | `TrackProgress >= 設定値` |
| 出口 | 最後の門からの相対距離 | `TrackProgress >= 最大門位置 + 設定値` |

### 計算式

```
出口の実際位置 = max(全門の解決位置) + 出口の設定歩数
```

門がない場合は `max = 0` となり、出口の設定値がそのまま絶対位置となる。

### 具体例

**設定:**
- 門1: 30歩
- 門2: 50歩
- 出口: 100歩

**実際の動作:**
1. 開始（TrackProgress=0）
2. 30歩で門1出現
3. 50歩で門2出現
4. 門2通過後「あと100歩」と表示
5. 150歩（= max(30,50) + 100）で出口出現

### 設計意図

- 門と出口を独立して設定可能（兼ね合いを考える必要がない）
- 「門を100歩に、出口を50歩に」と設定すれば、門通過後50歩で出口が出る
- 直感的な数値設定が可能

### 関連コード

- `GateResolver.GetMaxResolvedPosition()` - 最大門位置の取得
- `ExitSpawnRule.ShouldSpawn()` - 出口出現判定
- `ProgressCalculator.CalculateExitPosition()` - 出口位置計算

---

## WalkStep 処理順序（現在の仕様）

### 概要

`AreaController.WalkStep()` が1歩ごとに実行する処理の順序を定義する。

### 処理順序

```
WalkStep()
│
├── 1. ノード同期チェック
│       └── Anchor rewind後にノードが変わっていないか確認
│
├── 2. リフレッシュ処理（巻き戻し後）
│       └── RequestRefreshWithoutStep が true の場合、カウンタを進めずにUI更新のみ
│
├── 3. ノード入場イベント
│       └── hasEnteredCurrentNode が false の場合、OnEnterEvent を発火
│       └── 初回入場時のみ実行
│
├── 4. カウンタ進行
│       ├── Counters.Advance(1) - GlobalSteps, NodeSteps, TrackProgress を+1
│       └── UpdateTrackProgress() - TrackConfig に基づく追加進行
│
├── 5. クールダウン進行
│       ├── sideObjectSelector.AdvanceStep() - サイドオブジェクトのクールダウン
│       └── context.AdvanceEncounterOverlays() - エンカウントオーバーレイ
│
├── 6. サイドオブジェクト抽選
│       └── RollPair() でその歩の左右オブジェクトを決定
│
├── 7. 中央オブジェクト取得
│       └── CentralEvent と CentralVisual を取得
│
├── 8. アプローチオブジェクト表示
│       └── ShowApproachObjects() で左右・中央を画面に表示
│
├── 9. ゲートチェック
│       └── CheckGates() でゲート出現・通過・失敗を処理
│       └── ゲート処理が発生した場合は return（後続処理スキップ）
│
├── 10. エンカウント判定
│       └── encounterResolver.Resolve() で敵遭遇を判定
│       └── 遭遇した場合は RunEncounter() で戦闘実行
│       └── 戦闘結果イベント（OnWin/OnLose/OnEscape）を発火
│
├── 11. 強制イベントチェック
│       └── CheckForcedEvents() で歩数/確率トリガーを判定
│       └── 発火した場合は return（後続処理スキップ）
│
├── 12. アプローチ処理
│       └── HandleApproach() でユーザーの選択を待機
│       └── 左/右/中央/スキップ の選択に応じてイベント発火
│
├── 13. リワインドチェック
│       └── イベントで RewindToAnchorEffect が発火した場合は return
│
└── 14. 出口チェック
        └── ExitSpawn.ShouldSpawn() で出口出現を判定
        └── 出口選択 → ノード遷移 → OnExitEvent 発火
```

### 各処理の詳細

| # | 処理 | 発火するイベント | 中断条件 |
|---|------|----------------|---------|
| 3 | ノード入場 | OnEnterEvent | - |
| 9 | ゲートチェック | GateEvent (OnAppear/OnPass/OnFail) | ゲート処理発生時 |
| 10 | エンカウント | OnWin/OnLose/OnEscape | - |
| 11 | 強制イベント | ForcedEventTrigger.Dialogue | イベント発火時 |
| 12 | アプローチ | SideObject.Event / CentralEvent | - |
| 14 | 出口 | OnExitEvent | 出口選択時 |

### 中断（return）の影響

| 中断ポイント | スキップされる処理 |
|-------------|------------------|
| ゲート処理後 | エンカウント、強制イベント、アプローチ、出口 |
| 強制イベント後 | アプローチ、出口 |
| リワインド後 | 出口 |

### 関連コード

- `AreaController.WalkStep()` - メイン処理ループ
- `AreaController.CheckGates()` - ゲート処理
- `AreaController.CheckForcedEvents()` - 強制イベント処理
- `AreaController.HandleApproach()` - アプローチ処理

---

## EventStepシステム（拡張可能イベント機構）

### 概要

EventStepシステムは、全てのイベントポイントから統一的にゲームシステム（会話、戦闘、Effect等）を起動可能にする拡張可能な基盤。

### アーキテクチャ

```
EventDefinitionSO
├── steps: IEventStep[] ([SerializeReference])
│   ├── MessageStep        → 旧EventStep互換（メッセージ+選択肢）
│   ├── NovelDialogueStep  → ノベルパート会話（DialogueSO参照）
│   ├── BattleStep         → 戦闘起動（EncounterSO参照）
│   ├── EmitEventStep      → 別EventDefinitionSO呼び出し
│   └── EffectStep         → Effect適用のみ
└── terminalEffects: EffectSO[]
```

### IEventStepインターフェース

```csharp
public interface IEventStep
{
    UniTask<EffectSO[]> ExecuteAsync(EventContext context);
}
```

各Stepは実行後にEffectSO配列を返し、EventRunnerが最後にまとめて適用する。

### EventContext（依存注入）

```csharp
public sealed class EventContext
{
    public GameContext GameContext { get; set; }
    public IEventUI EventUI { get; set; }
    public INovelEventUI NovelUI { get; set; }
    public IDialogueRunner DialogueRunner { get; set; }
    public IBattleRunner BattleRunner { get; set; }
    public IEventRunner EventRunner { get; set; }
    public RectTransform CentralObjectRT { get; set; }
    public List<EffectSO> CollectedEffects { get; }
}
```

### Step型一覧

| Step型 | 用途 | 主なフィールド |
|--------|------|---------------|
| MessageStep | メッセージ表示+選択肢 | message, choices, effects |
| NovelDialogueStep | ノベルパート会話 | dialogueData, displayMode, zoomOnApproach, allowBacktrack |
| BattleStep | 戦闘起動 | encounter, overrideOutcomeEffects, onWin/onLose/onEscape |
| EmitEventStep | 別EventDefinition呼び出し | eventRef |
| EffectStep | Effect適用のみ | effects |

### 実行フロー

```
EventHost.TriggerWithContext(EventDefinitionSO, EventContext)
    ↓
EventRunner.RunAsync(definition, context)
    ↓
foreach step in definition.steps:
    effects += await step.ExecuteAsync(context)
    ↓
EffectApplier.ApplyAll(effects + terminalEffects)
```

### イベントポイント一覧

全てEventDefinitionSOを使用し、任意のStep型を組み合わせ可能:

| イベントポイント | 説明 |
|-----------------|------|
| NodeSO.OnEnter | ノード入場時 |
| NodeSO.OnExit | ノード退場時 |
| NodeSO.CentralEvent | 中央オブジェクトアプローチ時 |
| GateMarker.OnAppear/OnPass/OnFail | ゲート出現・通過・失敗時 |
| SideObject.Event | サイドオブジェクト選択時 |
| ForcedEventTrigger.eventDefinition | 強制イベント発火時 |
| EncounterSO.OnWin/OnLose/OnEscape | 戦闘結果時 |

### 関連コード

- `Assets/Script/Walk/EventKernel/IEventStep.cs` - インターフェース定義
- `Assets/Script/Walk/EventKernel/EventDefinitionSO.cs` - SO定義
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - 実行エンジン
- `Assets/Script/Walk/EventKernel/EventHost.cs` - 発火ホスト
- `Assets/Script/Walk/EventKernel/Steps/` - 各Step実装

### 詳細設計

詳細は [EventStep統合実装計画.md](./EventStep統合実装計画.md) を参照。

---

## EventQueue共通規格（イベント選択の仕組み）

### 概要

歩行システムの各「容器」（サイドオブジェクト、中央オブジェクト、ゲート等）が**どのイベントを発火するか**を選択するための共通規格。

**重要な区別:**
- **イベント** = `EventDefinitionSO` + `IEventStep[]`（前述のEventStepシステム）
- **EventQueue** = 容器が複数のイベント候補から1つを選ぶ仕組み

EventQueueはイベント自体を変更するものではない。容器側の「イベント選択ロジック」を統一する規格。

### なぜ必要か

従来は各容器が単一の`EventDefinitionSO`しか持てなかった:

```csharp
// 旧: 1つのイベントしか設定できない
public EventDefinitionSO eventDefinition;
```

これでは以下ができなかった:
- 初回だけ別のイベントを発火する
- フラグによってイベントを切り替える
- 一度見たイベントをスキップして次へ進む

### EventQueueEntry

各容器は `EventQueueEntry[]` 配列を持つ:

```csharp
[Serializable]
public sealed class EventQueueEntry
{
    string entryId;              // 状態管理用の識別子
    EventDefinitionSO eventDefinition;  // 発火するイベント
    ConditionSO[] conditions;    // 発火条件
    bool consumeOnTrigger;       // true=1回限り、false=何度でも
    int cooldownSteps;           // 再発火までの歩数（0=即可）
    int maxTriggerCount;         // 最大発火回数（0=無制限）
}
```

### 発火ロジック

配列を上から順に評価し、最初に条件を満たすエントリを発火:

```
foreach entry in entries:
    if 消費済み → スキップ
    if 最大回数到達 → スキップ
    if クールダウン中 → スキップ
    if 条件不一致 → スキップ
    → このエントリを発火して終了

全てスキップ → 発火なし
```

### 使用例

```yaml
CentralObjectSO: 商人NPC
  events:
    - entryId: "first_meet"
      eventDefinition: FirstMeetDialogue
      consumeOnTrigger: true   # 1回限り

    - entryId: "quest_complete"
      eventDefinition: QuestCompleteDialogue
      conditions: [HasFlag("quest_item")]
      consumeOnTrigger: true

    - entryId: "default"
      eventDefinition: ShopDialogue
      consumeOnTrigger: false  # 何度でも
```

動作:
1. 初回 → `first_meet` 発火（消費）
2. クエストアイテム持参時 → `quest_complete` 発火（消費）
3. それ以外 → `default` 発火（毎回）

### 新しい容器を作る場合

歩行システムに新しいイベント容器（SO）を追加する場合、以下を実装する:

**1. フィールド定義**
```csharp
[SerializeField] private EventQueueEntry[] events;
public EventQueueEntry[] Events => events;
```

**2. 発火処理**
```csharp
// AreaController内
var eventDef = eventQueueResolver.ResolveNext(
    container.Events,           // EventQueueEntry[]
    hostKey,                    // 状態管理用のキー
    context,                    // GameContext
    context.EventEntryStateManager
);
if (eventDef != null)
{
    await TriggerEvent(eventDef);
}
```

**3. hostKey命名規則**

状態は `{hostKey}:{entryId}` で管理される。hostKeyは以下の形式:

| 容器の種類 | hostKey形式 | 例 |
|-----------|------------|-----|
| 中央オブジェクト | `central:{id}` | `central:npc_merchant` |
| サイドオブジェクト | `side:{id}` | `side:treasure_chest` |
| ゲート | `gate:{id}` | `gate:boss_gate` |
| ノード入退場 | `node:{nodeId}:{timing}` | `node:forest:enter` |
| エンカウント結果 | `encounter:{id}:{outcome}` | `encounter:goblin:win` |
| 強制イベント | `forced:{nodeId}:{triggerId}` | `forced:forest:story_01` |

**注意**: hostKeyにノードIDを含めない場合（中央/サイド/ゲート等）、同じ容器は**ノード間で状態を共有**する。別状態にしたい場合は別の容器SOを作成する。

### 適用済み容器一覧

| 容器 | フィールド |
|------|-----------|
| CentralObjectSO | `events` |
| SideObjectSO | `events` |
| GateMarker | `gateEvents` |
| NodeSO | `onEnterEvents`, `onExitEvents` |
| EncounterSO | `onWinEvents`, `onLoseEvents`, `onEscapeEvents` |

### 状態の永続化

`EventEntryStateManager`が全容器の発火状態を統合管理し、`WalkProgressData`経由でセーブ/ロードされる。

### 関連コード

- `Assets/Script/Walk/EventQueue/EventQueueEntry.cs` - エントリ定義
- `Assets/Script/Walk/EventQueue/EventQueueResolver.cs` - 発火判定
- `Assets/Script/Walk/EventQueue/EventEntryStateManager.cs` - 状態管理
- `Assets/Script/Walk/EventQueue/EventQueueEntryState.cs` - 状態データ

### 詳細設計

詳細は [EventQueue共通規格設計.md](./EventQueue共通規格設計.md) を参照。

---

## 戦闘敗北/逃走時のRewind仕様

### 概要

戦闘敗北（Defeat）または逃走（Escape）時の歩数巻き戻し（Rewind）は、**ランダムエンカウントのみ自動適用**。その他のイベント経由戦闘では明示的にEffectで指定する。

### Rewind適用ルール

| 戦闘経路 | 自動Rewind | 明示的指定 |
|---------|-----------|-----------|
| ランダムエンカウント | ✅ 10歩巻き戻し | - |
| BattleStep | ❌ なし | onLose/onEscapeにEffect追加で可能 |
| リアクション戦闘 | ❌ なし | EncounterSO.OnLose/OnEscapeで可能 |

### 設計意図

- **ランダムエンカウント**: システム組み込みのペナルティとして自動Rewind。プレイヤーの進行ペースを調整する役割
- **イベント戦闘**: シナリオ上の意図が様々（ボス戦、強制敗北イベント等）なので、デザイナーが明示的に制御

### 実装箇所

**ランダムエンカウント（自動）:**
```csharp
// AreaController.HandleEncounterOutcome()
if (outcome == BattleOutcome.Defeat || outcome == BattleOutcome.Escape)
{
    context.Counters.Rewind(RewindStepsOnFail);  // 10歩
    sideObjectSelector.ClearPending();
    // サイドオブジェクト再抽選...
}
```

**イベント戦闘（明示的）:**
```yaml
# BattleStepでの例
- BattleStep:
    encounter: "BossEncounter"
    overrideOutcomeEffects: true
    onLose:
      - RewindCountersEffect(10)  # 明示的に指定
      - Jump("RecoveryNode")
```

### 関連コード

- `AreaController.HandleEncounterOutcome()` - ランダムエンカウントのRewind処理
- `AreaController.RewindStepsOnFail` - Rewind歩数定数（10）
- `BattleStep.onLose/onEscape` - イベント戦闘の結果Effect

---

## エンカウントシステム

### 概要

ランダムエンカウント（敵との遭遇）を管理するシステム。ステージ（ノード）単位でエンカウントテーブルを持ち、歩数に応じて敵グループとの戦闘を発生させる。

関連仕様書:
- `doc/友情コンビ登録システム仕様書.md` — 戦闘を通じた敵コンビの永続登録

### データ構造

#### EncounterTableSO（テーブル）

ノード単位で設定する。複数の `EncounterSO` を重み付きで保持し、エンカウント発生時に1つを抽選する。

| フィールド | 型 | 内容 |
|---|---|---|
| `tableId` | `string` | セーブ/ロード用の識別子 |
| `baseRate` | `float` | 基本エンカウント率（0〜1） |
| `cooldownSteps` | `int` | エンカウント後のクールダウン歩数 |
| `graceSteps` | `int` | ノード入場後の猶予歩数 |
| `pityIncrement` | `float` | ミスごとのエンカウント率上昇 |
| `pityMax` | `float` | エンカウント率の上限 |
| `entries` | `EncounterEntry[]` | エンカウント候補リスト |

#### EncounterEntry（候補）

| フィールド | 型 | 内容 |
|---|---|---|
| `encounter` | `EncounterSO` | 敵プール |
| `weight` | `float` | 抽選重み |
| `conditions` | `ConditionSO[]` | 発火条件（全て満たす必要あり） |

#### EncounterSO（敵プール）

1つのエンカウント候補。敵テンプレートのリストを持ち、戦闘時にここからグループが組まれる。

| フィールド | 型 | 内容 |
|---|---|---|
| `id` | `string` | 識別子 |
| `enemyList` | `List<NormalEnemy>` | 敵テンプレートの候補プール |
| `enemyCount` | `int` | グループの人数（1〜3） |
| `escapeRate` | `float` | このエンカウントの逃走成功率 |
| `isStoryEncounter` | `bool` | ストーリー敵フラグ（後述） |
| `onWinEvents` | `EventQueueEntry[]` | 勝利時イベント |
| `onLoseEvents` | `EventQueueEntry[]` | 敗北時イベント |
| `onEscapeEvents` | `EventQueueEntry[]` | 逃走時イベント |

**EncounterSO同士は混ざらない**。テーブルから1つの EncounterSO が選ばれ、その `enemyList` の中だけからグループが組まれる。

### エンカウント発生フロー

```
WalkStep() ステップ10: エンカウント判定
    ↓
EncounterResolver.Resolve(table, context)
    ├── クールダウン/猶予中 → スキップ
    ├── エンカウント率判定（baseRate + pity）→ 失敗 → misses++
    └── 成功 → PickEncounter()
        └── entries から条件を満たすものを重み抽選 → 1つの EncounterSO が決定
    ↓
AreaController.RunEncounter(encounter)
    ↓
UnityBattleRunner.RunBattleAsync(EncounterContext)
    ├── GameContext.GetRuntimeEnemies(encounter) → DeepCopy + GUID復元
    ├── BattleInitializer.InitializeBattle(enemies, ..., comboRegistry)
    │   └── EncounterEnemySelector.SelectGroup(enemies, ..., comboRegistry)
    │       ├── リーダーをランダム選出
    │       ├── リーダーがコンビメンバー → AssembleComboGroup()（再結成）
    │       └── リーダーがフリー → ExcludeComboMembers() → 通常の相性判定
    └── 戦闘実行 → 結果イベント発火
```

### 友情コンビとの関係

友情コンビ登録システム（`doc/友情コンビ登録システム仕様書.md`）と以下の接点がある:

**グループ選出時:**
- `EncounterEnemySelector` が `ComboRegistry` を参照し、リーダーがコンビメンバーならコンビ再結成を行う
- フリーリーダーの場合、コンビメンバーを候補から除外してバラバラに出ることを防ぐ
- コンビの再登場は `EncounterTableSO` の仕組みとは独立。同じ `EncounterSO` が選ばれた時に `enemyList` 内のコンビメンバーが自然に再結成される

**戦闘終了時:**
- `BattleManager.OnBattleEnd()` で `ComboRegistry` にコンビ登録・broken反映が行われる

### isStoryEncounter（ストーリー敵フラグ）

`EncounterSO.isStoryEncounter = true` に設定すると、そのエンカウントでは友情コンビ登録に関する全ての処理がスキップされる。

| 処理 | isStoryEncounter=true |
|---|---|
| コンビ登録判定 | スキップ |
| グループ逃走コンビ登録 | スキップ |
| broken記録 | スキップ |
| コンビ再結成 | スキップ |
| コンビメンバー除外 | スキップ |

**実装方式**: `UnityBattleRunner` が `isStoryEncounter` を見て `ComboRegistry` を `null` で渡すことにより、上記全てが自動的にスキップされる。個別のif文は不要。

**用途**: イベント戦闘やストーリー固定敵など、ランダムマッチングの人間関係とは切り離したいエンカウントに使用する。

### 関連コード

- `Assets/Script/Walk/Encounter/EncounterSO.cs` - 敵プール定義
- `Assets/Script/Walk/Encounter/EncounterTableSO.cs` - テーブル定義
- `Assets/Script/Walk/Encounter/EncounterResolver.cs` - エンカウント判定・抽選
- `Assets/Script/Walk/Encounter/EncounterEnemySelector.cs` - グループ選出（コンビ再結成含む）
- `Assets/Script/Walk/Battle/UnityBattleRunner.cs` - 戦闘実行（isStoryEncounterチェック）
- `Assets/Script/Walk/Battle/EncounterContext.cs` - EncounterSO + GameContextの受け渡し
