# 歩行システム導入アプローチ（会話先行・最小コア）v_0

> **目的**: 会話／遭遇／分岐を優先し、サイドオブジェクトUIは後回しで、段階的に拡張できる最小構成を示す。

---

## 0) 設計ポリシーと中核仕様との関係

### 設計意図の明確化

**このドキュメントの位置づけ**:
- ✅ **プロトタイプ開発のための実装アプローチ**
- ✅ 拡張案の要素（TrackConfig, SpawnSource）を段階的に実装
- ⚠️ 中核仕様（確率のみ）の範囲は逸脱している

### 中核仕様との関係

**中核仕様の設計思想**:
```
すべてのイベント・遭遇・出口を「確率」で制御
- メモリレス遭遇（歩数非依存）
- Edge遷移ベース（進捗管理なし）
- シンプルなentries配列
```

**将来的な完成形**:
- ✅ **すべてを確率で制御するゲーム**（中核仕様に準拠）
- ✅ 歩数・進捗管理は使わない
- ✅ ランダム性とEdge遷移のみで構成

### プロトタイプと完成形の移行戦略

**重要な設計判断**: 
1. **プロトタイプでは歩数管理を使う**（TrackConfig, AmbientTalkTrigger）
2. **完成形では確率のみに移行する**（中核仕様に準拠）
3. **移行はデータ変更のみで可能**（プログラム設計の大きな変更は不要）

#### 移行の仕組み

```csharp
// 実装: オプショナルな分岐
void Step() {
    // TrackConfigがあればtrack管理（プロトタイプ）
    if (currentNode.trackConfig != null) {
        trackProgress += stepDelta;
        CheckGates();
    }
    
    // 確率ベースの処理（常に動作、完成形でも使用）
    TryEncounter();  // メモリレス確率
    
    // 出口判定: TrackConfigがなければEdge遷移（完成形）
    if (CanExit()) ChooseExit();
}

bool CanExit(GameContext ctx) {
    // TrackConfigがあれば進捗判定（プロトタイプ）
    if (currentNode.trackConfig != null) {
        return trackProgress >= length;
    }
    
    // なければEdge遷移（完成形、中核仕様準拠）
    return EvaluateExitConditions(ctx);
}
```

#### データ変更のみでの移行

**プロトタイプのノード**:
```yaml
nodeId: "area_01"
trackConfig:
  length: 50
  gates: [...]
ambientTalks: [...]
```

**完成形のノード（中核仕様準拠）**:
```yaml
nodeId: "area_01"
trackConfig: null  # ← nullに変更するだけ
ambientTalks: []   # ← 空にするだけ

# Edge遷移ベースに移行
edges:
  - fromNodeId: "area_01"
    toNodeId: "area_02"
    policy: Conditional  # 確率や条件で遷移
    conditions: [RandomChance(0.3), HasFlag("key")]
```

**移行コスト**:
- ✅ プログラムコードの変更: **不要**
- ✅ データファイルの変更: **必要**（trackConfig→null、Edge設定）
- ✅ 設計の互換性: **保証されている**

### このアプローチの利点

1. **早期検証**: 歩数管理でプロトタイプを素早く作成
2. **段階的移行**: データ変更のみで中核仕様（確率のみ）に移行可能
3. **実装の再利用**: 確率ベースの処理（遭遇等）は完成形でも使用
4. **設計の柔軟性**: 両方の挙動をノード単位で選択可能

### 注意事項

⚠️ **このドキュメントは「最小」ではなく「段階的拡張」アプローチ**
- 中核仕様よりも複雑な要素を含む
- 将来的には中核仕様（確率のみ）に統一する前提
- プロトタイプ開発の効率を優先した設計判断

---

### 設計者の論評（2025-10-19）

**背景**:
> 中核仕様を作った時に思い描いた完成図は、起こる予定のイベントや敵遭遇、出口としてのイベント門等、そういったすべての要素を文字通り「確率」で扱う設計だった。将来的な完成時は全てを確率で制御したいのも事実。

**プロトタイプ開発の判断**:
> しかし、今やろうとしているプロトタイプ制作を進めるにあたっては、この最小アプローチの内容（TrackConfig + 歩数会話）が正しい。将来的な確率のみのゲーム挙動再現において、中核仕様の確率などの歩数を前提としない仕様に変更する上で、最小アプローチで用いた歩数等の要素も大きく共存を妨げず、少なくとも大きなプログラムの設計的変更は現れず、エリアなどをノードで設定するファイルをちょっとばかり変更で済む。

**評価**:
- ✅ **論評は正確**: データ変更のみで移行可能
- ✅ **設計判断は合理的**: プロトタイプ効率を優先
- ✅ **移行コストは最小限**: プログラム設計の大きな変更は不要

**補足**:
- 「共存」というより「オプショナルなので無効化可能」が正確
- 実装には`if (trackConfig != null)`の分岐が残るが、データ側で制御可能
- 全ノードで`trackConfig=null`にすれば中核仕様（確率のみ）の挙動になる

---

### このCanvasが満たす提案項目（適用範囲）

- ✅ **敵候補リスト/遭遇情報**：`EncounterTableSO` / `EncounterDefinitionSO`
- ✅ **戦闘前/後会話**：`preTalk` / `postTalkByOutcome`
- ✅ **エリア分岐/出口条件**：`ExitCandidate{conditions, weight}`
- ✅ **エリアの長さ**：`StepCountInArea` 条件で表現（門/到達/開放）
- ✅ **独立会話（歩数/乱数/フラグ）**：`AmbientTalkTrigger`
- ✅ **サイドオブジェクト無視**：後回し前提で他機能と分離済み

---

## 1) 実装順ロードマップ（序盤MVP）- TrackConfig + 歩数会話アプローチ

**推奨方針**: ✅ **Phase 0から TrackConfig + 歩数会話で実装**

### Phase 0: 基本コア（1-2週間）

1. **会話コア**：`DialogueDefinitionSO` + `ConversationRunner`（UIは仮）を先に実装し、どこからでも起動できる基盤を用意。
2. **遭遇パイプライン（SpawnSource対応）**：
   - `EncounterDefinitionSO`（`preTalk`/`postTalkByOutcome`）
   - `EncounterTableSO`（`baseRate`/`spawnSources`）← **SpawnSource方式**
   - `SpawnSource`（Phase 0では`LocalEntries`のみ実装）
   - `IBattleRunner`を繋ぎ**Pre→戦→Post**の流れを固定
3. **TrackConfig + 歩数会話**：
   - `TrackConfig`（`length`/`gates`）← **進行管理**
   - `AmbientTalkTrigger`（`Step/Random/Flag`）← **フィールドイベント**
   - 両方のカウンタを同時に管理
4. **分岐/出口**：
   - `ExitCandidate{conditions, weight}`で複数出口
   - TrackConfigがある場合は`trackProgress >= length`で自動判定
5. **再現性/検証**：シード固定RNG + 簡易ログ（候補/除外理由/重み/結果）で早期検証。

### Phase 1-2: 基本機能追加（1週間）

6. **バリエティバイアス**：同じ敵の連発抑止
7. **条件DSL拡張**：`And/Or/Not`の合成条件
8. **デバッグUI**：候補一覧、重み、選出結果の可視化

### Phase 3: 高度機能（1-2週間）

9. **PoolRef/TagQuery**：SpawnSourceに`PoolRef`と`TagQuery`を追加
10. **進捗UI**：TrackConfigの`progress/length`でバー表示
11. **巻き戻し**：Gate失敗時のRewind機能

## 2) 全体像（まずここまで動かす）

### ランタイム1ステップ（TrackConfig + 歩数会話）

1. **カウンタ更新**：`stepCountInArea++`と`trackProgress += stepDelta`（両方同時）
2. **TrackConfigの門チェック**（進行管理）：通過できないと停止
3. **歩数会話の判定/実行**（フィールドイベント）：歩数・乱数・フラグでトリガ
4. **遭遇ロール**：`baseRate`判定 → 当たれば **PreTalk** → **戦闘** → **Outcome別PostTalk**
5. **出口決定**：TrackConfigがあれば`trackProgress >= length`で判定、なければ条件で判定

### データモデル（ScriptableObject 主体）- TrackConfig + SpawnSource対応

- **DSL（最小）**：`ConditionSO`（HasFlag/Random/StepCountInArea>=N）・`EffectSO`（SetFlag/UnsetFlag/Jump）
- **会話**：`DialogueDefinitionSO` + `ConversationRunner`（どこからでも呼べる独立ランナー）
- **遭遇（SpawnSource対応）**：
  - `EncounterDefinitionSO`（pre/post会話, 敵候補, 条件, 重み）
  - `EncounterTableSO`（baseRate, **spawnSources**）← SpawnSource方式
  - `SpawnSource`（type: LocalEntries/PoolRef/TagQuery）← Phase 0はLocalEntriesのみ
- **エリア（TrackConfig + 歩数会話対応）**：
  - `NodeSO`（**trackConfig**, **ambientTalks**, encounters, exits, onEnter/onExit）
  - `TrackConfig`（length, gates）← 進行管理
  - `AmbientTalkTrigger`（type: Step/Random/Flag）← フィールドイベント
- **進行制御**：`AreaController`（1ステップ進行：カウンタ更新→門チェック→歩数会話→遭遇→出口）

---

### ステージとエリア（ノード）の扱い
- **用語対応（このプロジェクトの運用）**：
  - ゲーム用語の**ステージ** ≒ 本システムの**エリア（=ノード）**の“内部での1まとまり”として扱う。
  - 中核仕様は階層を固定しないが、**オーサリング上は「1ノード＝1ステージ」想定で進めてもOK**（後日、複数ノードで1ステージを構成する運用に移行しても破綻しない）。

### 1歩ごとの更新（WalkStepのリフレッシュ規約）
- **サイドオブジェクト**：
  - **毎歩**、そのノードの `SideObjectTable` から**左右ペア**を**重み抽選**で再選出（`fixedOnEnter` 指定があるものは固定提示）。
  - プレイヤーは**どちらか一方だけ選択可能**。選ばなかった側は**次の歩行で更新**される。
  - 連発抑止は `varietyBias`（履歴/減衰）で管理。
- **ランダムエンカウント**：
  - **毎歩**、`baseRate × 各種倍率 × pity/クールダウン` で**メモリレス判定**→成立時は候補を**条件→重み→Bias**で選出。
- **中立的敵オブジェクト**：
  - 実体は**Encounter**の一種（`resolver=Talk/Trade/PreemptiveCombat` など）。**毎歩の遭遇ロール**の結果として更新される。
- **更新順序（標準）**：
  1) **サイドオブジェクトのペア提示/更新**（選択しなければスキップ）
  2) **独立会話**（歩数/乱数/フラグで発火）
  3) **遭遇（PreTalk→Battle→PostTalk）**
  4) **出口決定**（条件＋重み、`Jump`があれば優先）

> MVPではサイドオブジェクトUIは**無効化**のまま進めるが、**“毎歩リフレッシュ”という規約**だけここで確定しておく。UIを戻す時に差し込むだけで整合が取れる。

### ランダムエンカウント（詳細メモ）

**目的**：体感（連発/スカスカを抑える）と再現性（シード固定）を両立。

**発生判定（1ステップごとのBernoulli）**
- 基本式：`p_step = clamp01( baseRate × M_overlay × M_area × M_story × R_pity(t) )`
  - `baseRate`：エリア既定（例: 0.12〜0.22）
  - `M_overlay`：夜/警戒/天候などの倍率（例: 0.8〜1.5）
  - `M_area`：難易度/地形での倍率
  - `M_story`：ストーリー抑制/強制（0 または 1 以上）
  - `R_pity(t)`：**遭遇間隔の揺らぎを抑える緩和**。`t=前回遭遇からの歩数`。
    - 例1（線形ランプ）：`R_pity(t) = 1 + rampK × max(0, t - rampStart)`（上限`pMax`でクランプ）
    - 例2（ハザード制御）：目標間隔`L`に対し `p_step = 1 - exp(-1/L)` を基準に、`t`が小さい間は減衰、`t`が大きいほど増強。
- **グレース期間**：`graceSteps`（入場直後は遭遇を0に）
- **クールダウン**：`cooldownSteps`（遭遇直後の連発抑止）
- **強制/抑止**：特定フラグ中は `p_step=1`（強制戦闘）や `=0`（完全抑止）

**候補選定（同一ステップで発生が確定した後）**
- 1) `conditions`でフィルタ（昼夜/フラグ/プレイヤLv/進捗）
- 2) `weight`で重み抽選
- 3) `varietyBias`で**連発抑止**（履歴`H`歩の同カテゴリ/同敵IDにペナルティ）
- 4) **決定の再現性**：単一のシードから `roll(encounter?) → roll(entry)` の順で使用

**体感安定のためのオプション**
- `minGapSteps`/`maxGapSteps`：最小/最大間隔のハードガード（必要なときのみ使用）
- `softCap`：同カテゴリが連続するほど重みを指数的に低下（`w' = w × γ^k`, `0<γ<1`）
- `gateMinStep`：エリアで**門イベント**が来るまで遭遇率を下げる等のシナリオ寄り調整

**前後会話との連携**
- 発生順：`独立会話 → 遭遇(PreTalk→Battle→PostTalk) → 出口`（独立会話が発火したステップは遭遇ロールをスキップ／同時許可にするかはエリア設定で選択）
- `postTalkByOutcome`で `Win/Lose/Escape` 別に会話分岐

**デバッグログ（検証に必須）**
- `stepIndex, stepsSinceLast, p_step, roll値`
- 採用候補一覧（`id, weight, 条件結果, varietyBias後の重み`）
- 除外理由（`条件NG/クールダウン/抑止フラグ`）
- 選出結果（`encounterId`）と `outcome`

**セーブ項目**
- `rngSeed`, `stepsSinceLastEncounter`, `cooldown残`, `variety履歴`（敵ID/カテゴリ）

**擬似コード（SpawnSource対応）**
```csharp
bool TryEncounterStep(EncounterTableSO tbl, Ctx ctx, out EncounterDefinitionSO enc){
    enc=null;
    if(ctx.InGrace() || ctx.InCooldown()) return false;
    double p = tbl.baseRate * OverlayMul(ctx) * AreaMul(ctx) * StoryMul(ctx) * Pity(ctx.stepsSinceLast);
    p = Math.Clamp(p, 0.0, ctx.tuning.pMax);
    if(ctx.rng.NextDouble() >= p) return false; // 未発生
    
    // SpawnSourceから候補を取得（Phase 0ではLocalEntriesのみ）
    var pool = GetCandidatesFromSpawnSources(tbl.spawnSources, ctx);
    pool = FilterByConditions(pool, ctx);
    ApplyVarietyBias(pool, ctx.history, ctx.tuning.variety);
    enc = WeightedPick(pool, ctx.rng);
    return enc!=null;
}

// SpawnSourceから候補を合流
List<EncounterEntry> GetCandidatesFromSpawnSources(List<SpawnSource> sources, Ctx ctx) {
    var result = new List<EncounterEntry>();
    foreach (var source in sources) {
        if (source.conditions != null && !EvaluateAll(source.conditions, ctx)) continue;
        
        // Phase 0: LocalEntriesのみ実装
        if (source.type == SpawnSourceType.LocalEntries) {
            result.AddRange(source.entries);
        }
        // Phase 3: PoolRef, TagQueryを追加
        // if (source.type == SpawnSourceType.PoolRef) {
        //     var pool = FindPool(source.poolId);
        //     result.AddRange(pool.entries);
        // }
    }
    return result;
}
```

---

## 3) データ構造（最小セット）

### 共有：GameContext / WalkState / Flags

- 再現性のための **rngSeed** と **履歴** を保持。
- `WalkState.stepCountInArea`（エリア内歩数）で条件化。

### Condition / Effect（最小DSL）

- **Condition**：`HasFlag(key)`, `Random(p)`, `StepCountInArea >= N`
- **Effect**：`SetFlag(key)`, `UnsetFlag(key)`, `Jump(toNodeId)`

### 会話（独立ランナー）

- `DialogueDefinitionSO`: `conditions[]`, `steps[](text, choices[onChoose Effects])`, `effectsOnEnd[]`, `once`, `cooldownSteps`
- `ConversationRunner.Run(def, ctx, onDone)`: UIは別層。完了時にEffects適用。

### 遭遇（エンカウント）

- `EncounterDefinitionSO`: `enemyIds[]`, `preTalk?`, `postTalkByOutcome[]`, `conditions[]`, `weight`
- `EncounterTableSO`: `baseRate(0..1)`, `entries(encRef, weight, conditions[])`
- `IBattleRunner.Run(enemyIds, ctx) -> BattleOutcome`

### エリア（分岐・長さ・出口）

- `AreaNodeSO`: `encounterTable`, `ambientTalks[]`, `exits[]`, `onEnter`, `onExit`
- `AmbientTalkTrigger`: `type(Step|Random|Flag)`, `dialogue`, `once`, `cooldownSteps`
- `ExitCandidate`: `toNodeId`, `conditions[]`, `weight`, `uiLabel?`

---

## 4) 実装ひな形（C# / Unity）

> 必要箇所だけコピペでOK。UIは仮でもよい。将来のEvent Kernel/Overlayに接続しやすい形。

### 3.1 共有：Context/DSL

```csharp
[Serializable]
public class FlagStore { /* Has/Set/Unset 実装 */ }
public enum BattleOutcome { None, Win, Lose, Escape }
[Serializable] public class WalkState { public string currentNodeId; public int stepCountInArea; public System.Random rng; public string nextNodeId; }
[CreateAssetMenu(menuName="Walk/Core/GameConfig")] public class GameConfig : ScriptableObject { public int rngSeed = 12345; }
public class GameContext { public readonly FlagStore Flags = new(); public readonly WalkState Walk = new(); public readonly GameConfig Config; public GameContext(GameConfig cfg){ Config = cfg; Walk.rng = new System.Random(cfg.rngSeed); } }
public abstract class ConditionSO : ScriptableObject { public abstract bool Evaluate(GameContext ctx); }
public abstract class EffectSO : ScriptableObject { public abstract void Apply(GameContext ctx); }
```

```csharp
// Conditions
[CreateAssetMenu(menuName="Walk/Conditions/HasFlag")] class HasFlagCondition : ConditionSO { public string key; public override bool Evaluate(GameContext ctx)=>ctx.Flags.Has(key);}
[CreateAssetMenu(menuName="Walk/Conditions/Random")] class RandomCondition : ConditionSO { [Range(0,1)] public float p=0.5f; public override bool Evaluate(GameContext ctx)=>ctx.Walk.rng.NextDouble()<p; }
[CreateAssetMenu(menuName="Walk/Conditions/StepCountInArea>=")] class StepCountCondition : ConditionSO { public int minSteps=5; public override bool Evaluate(GameContext ctx)=>ctx.Walk.stepCountInArea>=minSteps; }
// Effects
[CreateAssetMenu(menuName="Walk/Effects/SetFlag")] class SetFlagEffect : EffectSO { public string key; public override void Apply(GameContext ctx)=>ctx.Flags.SetFlag(key);}
[CreateAssetMenu(menuName="Walk/Effects/UnsetFlag")] class UnsetFlagEffect : EffectSO { public string key; public override void Apply(GameContext ctx)=>ctx.Flags.Unset(key);}
[CreateAssetMenu(menuName="Walk/Effects/Jump")] class JumpEffect : EffectSO { public string toNodeId; public override void Apply(GameContext ctx)=>ctx.Walk.nextNodeId=toNodeId; }
```

### 3.2 会話（独立ランナー）

```csharp
[Serializable] public class DialogueChoice { public string label; public EffectSO[] onChoose; }
[Serializable] public class DialogueStep { public string text; public DialogueChoice[] choices; }
[CreateAssetMenu(menuName="Walk/Dialogue/Definition")]
public class DialogueDefinitionSO : ScriptableObject {
  public string id; public ConditionSO[] conditions; public DialogueStep[] steps; public EffectSO[] effectsOnEnd; public bool once; public int cooldownSteps;
}
public class ConversationRunner : MonoBehaviour {
  public void Run(DialogueDefinitionSO def, GameContext ctx, Action onDone) {
    if (def?.conditions!=null) foreach (var c in def.conditions) if (!c.Evaluate(ctx)) { onDone?.Invoke(); return; }
    if (def?.effectsOnEnd!=null) foreach (var e in def.effectsOnEnd) e.Apply(ctx); // UI省略（擬似）
    onDone?.Invoke();
  }
}
```

### 3.3 遭遇（遭遇表 + 実行）

```csharp
[Serializable] public class EnemyRef { public string enemyId; }
[Serializable] public class OutcomeDialoguePair { public BattleOutcome outcome; public DialogueDefinitionSO dialogue; }
[CreateAssetMenu(menuName="Walk/Encounter/Definition")]
public class EncounterDefinitionSO : ScriptableObject {
  public string id; public EnemyRef[] enemyIds; public DialogueDefinitionSO preTalk; public OutcomeDialoguePair[] postTalkByOutcome; public ConditionSO[] conditions; public int weight=1;
}

// SpawnSource対応（Phase 0ではLocalEntriesのみ実装）
public enum SpawnSourceType { LocalEntries /* PoolRef, TagQuery は Phase 3以降 */ }
[Serializable]
public class SpawnSource {
  public SpawnSourceType type;
  public List<EncounterEntry> entries;  // LocalEntries用
  public ConditionSO[] conditions;
  // public string poolId;              // Phase 3で追加
  // public string[] tags;               // Phase 4で追加
  // public float weightScale = 1.0f;    // Phase 3で追加
}

[Serializable] public class EncounterEntry { public EncounterDefinitionSO encounter; public int weight=1; public ConditionSO[] conditions; }

[CreateAssetMenu(menuName="Walk/Encounter/Table")]
public class EncounterTableSO : ScriptableObject {
  [Range(0,1)] public float baseRate=0.15f;
  public List<SpawnSource> spawnSources;  // ← SpawnSource方式を最初から採用
}

public interface IBattleRunner { BattleOutcome Run(EnemyRef[] enemies, GameContext ctx); }

public static class EncounterSystem {
  // SpawnSourceから候補を取得（Phase 0ではLocalEntriesのみ対応）
  private static List<EncounterEntry> GetCandidates(EncounterTableSO table, GameContext ctx) {
    var result = new List<EncounterEntry>();
    if (table.spawnSources == null) return result;
    
    foreach (var source in table.spawnSources) {
      // 条件チェック
      if (source.conditions != null && !EvaluateAll(source.conditions, ctx)) continue;
      
      // Phase 0: LocalEntriesのみ実装
      if (source.type == SpawnSourceType.LocalEntries) {
        result.AddRange(source.entries);
      }
      // Phase 3以降: PoolRef, TagQueryを追加
    }
    return result;
  }
  
  public static bool TryRoll(EncounterTableSO table, GameContext ctx, out EncounterDefinitionSO picked) {
    picked = null;
    if (ctx.Walk.rng.NextDouble() >= table.baseRate) return false;
    
    var candidates = GetCandidates(table, ctx);
    var filtered = candidates.Where(e => e.conditions == null || EvaluateAll(e.conditions, ctx)).ToList();
    if (filtered.Count == 0) return false;
    
    picked = WeightedPick(filtered, ctx.Walk.rng)?.encounter;
    return picked != null;
  }
  
  public static void RunEncounter(EncounterDefinitionSO enc, GameContext ctx, ConversationRunner conv, IBattleRunner battle, Action onDone) {
    void AfterPre(){ var outcome=battle.Run(enc.enemyIds,ctx); var post=Array.Find(enc.postTalkByOutcome,x=>x.outcome==outcome)?.dialogue; if(post!=null) conv.Run(post,ctx,onDone); else onDone?.Invoke(); }
    if (enc.preTalk!=null) conv.Run(enc.preTalk,ctx,AfterPre); else AfterPre();
  }
}
```

### 3.4 エリア（独立会話トリガ／出口）& 進行

```csharp
public enum AmbientTriggerType { Step, Random, Flag }
[Serializable]
public class AmbientTalkTrigger {
  public AmbientTriggerType type; public int stepMin; [Range(0,1)] public float p; public string flagKey; public DialogueDefinitionSO dialogue; public bool once=true; public int cooldownSteps; [NonSerialized] public int _cooldown; [NonSerialized] public bool _consumed;
  public bool TryFire(GameContext ctx){ if(_consumed) return false; if(_cooldown>0){_cooldown--; return false;} bool ok = type switch {
    AmbientTriggerType.Step=>ctx.Walk.stepCountInArea>=stepMin,
    AmbientTriggerType.Random=>ctx.Walk.rng.NextDouble()<p,
    AmbientTriggerType.Flag=>ctx.Flags.Has(flagKey), _=>false}; if(ok){ if(once)_consumed=true; _cooldown=cooldownSteps; return true;} return false; }
}
[Serializable] public class ExitCandidate { public string toNodeId; public string uiLabel; public ConditionSO[] conditions; public int weight=1; }
[CreateAssetMenu(menuName="Walk/Area/Node")]
public class AreaNodeSO : ScriptableObject { public string id; public EncounterTableSO encounterTable; public AmbientTalkTrigger[] ambientTalks; public ExitCandidate[] exits; public EffectSO[] onEnter, onExit; }
```

```csharp
public class AreaController : MonoBehaviour {
  public GameConfig config; public ConversationRunner conversation; public IBattleRunner battleRunner; public AreaNodeSO entry;
  private GameContext _ctx; private Dictionary<string,AreaNodeSO> _nodes;
  void Start(){ _ctx=new GameContext(config); _nodes=new(); foreach(var n in Resources.LoadAll<AreaNodeSO>("")) _nodes[n.id]=n; EnterNode(entry.id);}
  void EnterNode(string nodeId){ _ctx.Walk.currentNodeId=nodeId; _ctx.Walk.stepCountInArea=0; var node=_nodes[nodeId]; Apply(node.onEnter);}
  void Apply(EffectSO[] eff){ if(eff!=null) foreach(var e in eff) e.Apply(_ctx);}
  public void WalkStep(){ var node=_nodes[_ctx.Walk.currentNodeId]; _ctx.Walk.stepCountInArea++;
    // 1) 独立会話
    if(node.ambientTalks!=null){ foreach(var t in node.ambientTalks){ if(t.TryFire(_ctx)){ conversation.Run(t.dialogue,_ctx,()=>{}); return; } } }
    // 2) 遭遇
    if(EncounterSystem.TryRoll(node.encounterTable,_ctx,out var enc)) EncounterSystem.RunEncounter(enc,_ctx,conversation,battleRunner,()=>{});
    // 3) 出口
    DecideExit(node);
  }
  void DecideExit(AreaNodeSO node){ if(!string.IsNullOrEmpty(_ctx.Walk.nextNodeId)){ var next=_ctx.Walk.nextNodeId; _ctx.Walk.nextNodeId=null; Transition(node,next); return; }
    var pool=new List<(ExitCandidate,int)>(); foreach(var e in node.exits){ bool ok=true; if(e.conditions!=null) foreach(var c in e.conditions) ok&=c.Evaluate(_ctx); if(ok) pool.Add((e,Mathf.Max(1,e.weight))); }
    if(pool.Count==0) return; int total=0; foreach(var p in pool) total+=p.Item2; int roll=_ctx.Walk.rng.Next(total); string to=null; foreach(var p in pool){ if((roll-=p.Item2)<0){ to=p.Item1.toNodeId; break; } } Transition(node,to);
  }
  void Transition(AreaNodeSO node, string to){ Apply(node.onExit); EnterNode(to); }
}
```

---

## 5) テスト観点（早期に潰す）

- **再現性**：同シード・同操作→同結果（遭遇/出口）。
- **会話の独立性**：戦闘前後・独立・出口直前で同じ定義が動く。
- **PostTalk分岐**：Win/Lose/Escape の会話が期待通り。
- **Jump優先**：イベント門などで通常出口抽選をバイパス。
- **冷却/一度きり**：AmbientTalkTriggerの`once`/`cooldownSteps`確認。

---

## 5.5) 中核仕様 ↔ 導入アプローチ：記述対応（サイド/遭遇の更新）

| 観点 | 中核仕様（FlowGraph v0.1 など） | 導入アプローチ（このCanvas） |
|---|---|---|
| ステージとエリア | 階層は固定しない。**Node=場面**。ステージ相当は運用で束ねる（任意）。 | **運用として「1ノード＝1ステージ」**で制作開始。後から複数ノード構成に移行可。
| サイドオブジェクトの更新 | **毎手ランダム**（左右ペア提示）、`fixedOnEnter`、`varietyBias`、抽選は重み＋条件。 | **毎歩再抽選**を明文化。ペア更新→選択は片側のみ。UIはMVPでは無効化して規約だけ確定。
| ランダムエンカウント | **メモリレス確率**（`baseRate`×倍率）。候補は条件→重み→Bias。 | 同一。さらに**pity/クールダウン**・`min/max gap`等の体感安定オプションをメモ追加。
| 中立的敵 | `EncounterSO.resolver` で**戦闘に入らない**会話/取引/先制等を扱える。 | 遭遇の一種として**毎歩のロール**で更新。将来`PreemptiveCombat`等のResolverで具体化。
| 更新順序 | 仕様本文は「SideObjects→Encounters→Transitions」を標準ユースケースとして記述。 | **Side→独立会話→遭遇→出口**の順序に固定（独立会話の優先度を明示）。

> 結論：**記述は整合**。Canvasで明文化した「毎歩リフレッシュ」「選択は片側のみ」「独立会話の優先順」は、中核仕様の範囲内での**運用規約**として自然に収まる。

## 6) 将来拡張の受け口

- **イベント門**：`StepCountInArea>=K` + `Jump`/`Unlock` で確定出現。専用UIは後付け。
- **Overlay（昼/夜/警戒）**：遭遇率/重み/会話トリガ倍率をModとして追加可能。
- **VarietyBias**：遭遇/会話の連発抑止をテーブル側に導入。
- **サイドオブジェクト**：本アプローチでは無視でOK。後で“寄り道UI”として同じDSL適用。
- **Event Kernel**：`ConversationRunner`/`EncounterSystem`にHookし、Outcomeに応じたEffect列を差し込み。

---

## 7) 落とし穴と回避策（要点）

1. **会話を戦闘専用に実装**→ ランナーを**用途非依存**に（Contextだけ渡す）。
2. **出口ロジックを歩数ベタ書き**→ 条件（Condition）に押し込み、`ExitCandidate{conditions[]}`で管理。
3. **PostTalkをif文分岐**→ `postTalkByOutcome[]`で**データ駆動**。
4. **独立会話の乱発**→ `once/cooldownSteps`と履歴保存を初期から。
5. **セーブ/ロードで再現不能**→ シード固定・履歴永続化・同手順同結果の方針を確定。

---

## 8) 次の一手（導入手順)

1. `ConversationRunner` + `DialogueDefinitionSO` を先に実装（即時完了でもOK）。
2. `EncounterDefinitionSO/Table` と `IBattleRunner` の前後フックを接続。
3. `AreaNodeSO` に `AmbientTalkTrigger` と `ExitCandidate` を載せて1ステップ進行を回す。
4. シード固定＋簡易ログ（候補/除外理由/重み/結果）で検証ループを回す。

---

## 9) 最小構成と段階的拡張戦略（追加セクション）

### 9.1 最小構成の定義（実装する最低限の要素）

**基本方針**: 「先に進むだけ＋分岐」のシンプルな進行で、RPGの基本ループを完成させる。

#### 必須要素（NodeSOの最小構成）
```csharp
public class NodeSO : ScriptableObject {
    // 基本構造
    public string nodeId;              // ノード識別子
    public string[] tags;              // タグ（任意、検索用）
    
    // 進入/退出処理
    public EffectSO[] onEnter;         // 進入時の自動処理
    public EffectSO[] onExit;          // 退出時の自動処理
    
    // イベント（nullでもOK）
    public EncounterTableSO encounters;           // 遭遇テーブル
    public AmbientTalkTrigger[] ambientTalks;     // 独立会話トリガ
    
    // 出口（必須）
    public ExitCandidate[] exits;      // 出口候補
}
```

#### 必須Condition（最小DSL）
- `HasFlag(key)`: フラグ所持判定
- `HasItem(id)`: アイテム所持判定（任意）
- `HasTag(tag)`: タグ所持判定（任意）
- 合成: `Not`, `And`, `Or`

#### 必須Effect（最小DSL）
- `SetFlag(key)`: フラグ設定
- `UnsetFlag(key)`: フラグ解除
- `AddTag(tag)`: タグ追加
- `RemoveTag(tag)`: タグ削除
- `Jump(nodeId)`: ノードへ強制遷移

#### 遭遇の最小構成
```csharp
public class EncounterTableSO : ScriptableObject {
    public float baseRate;             // 基本遭遇率（0.0〜1.0）
    public EncounterEntry[] entries;   // 遭遇候補
}

public class EncounterEntry {
    public EncounterDefinitionSO encounter;  // 遭遇定義
    public int weight;                       // 重み
    public ConditionSO[] conditions;         // 出現条件（任意）
}
```

#### 会話トリガの最小構成
```csharp
public class AmbientTalkTrigger {
    public AmbientTriggerType type;    // Step / Random / Flag
    public int stepMin;                // 歩数（Stepタイプ）
    public float p;                    // 確率（Randomタイプ）
    public string flagKey;             // フラグ（Flagタイプ）
    public DialogueDefinitionSO dialogue;  // 会話定義
    public bool once;                  // 一度きりか
}
```

### 9.2 削減した要素一覧（後から追加可能）

#### ❌ Overlay（状況レイヤ）全般 → フラグで代用
**削減内容**:
- `OverlaySO`（Night, Alert, 天候等）
- `PushOverlay/PopOverlay` Effect
- `OverlayActive` Condition
- `TimeOfDay` Condition
- 遭遇率/重みの倍率補正（`M_overlay`, `M_area`）

**代用方法**:
```csharp
// 夜の代用例
onEnter: [SetFlag("is_night")]
encounters.entries: [
    { encounter: "night_wolf", conditions: [HasFlag("is_night")] }
]
```

**復活の容易さ**: ✅ **容易**
- `OverlaySO`を追加
- `PushOverlay/PopOverlay` Effectを追加
- `ConditionSO`に`OverlayActive`を追加
- 遭遇率計算に`M_overlay`を乗算
- **既存のNodeSO構造は変更不要**

---

#### ❌ TrackConfig（内部トラック・イベント門）→ 歩数会話で代用
**推奨**: ✅ **TrackConfig + 歩数会話の組み合わせは完全に問題なし**

**注意**: ⚠️ TrackConfigと**StepCount条件の出口判定**は競合するので併用しない

**代用方法**:
```csharp
// 10歩目でイベントを起こす
ambientTalks: [
    { type: Step, stepMin: 10, dialogue: "門イベント", once: true }
]
```

**復活の容易さ**: ⚠️ **中程度**
- `NodeSO`に`TrackConfig`フィールド追加
- 進行処理に門チェックロジック追加
- **既存のNodeSOデータは互換性維持**（フィールドがnullなら無視）

---

#### ❌ Anchor/Rewind（巻き戻し）→ セーブ/ロードで代用
**削減内容**:
- `AnchorSO`
- `RewindToAnchor` Effect
- 状態スナップショット機能

**代用方法**:
- プレイヤーが手動でセーブ/ロードする

**復活の容易さ**: ⚠️ **中程度**
- `AnchorSO`を追加
- `GameState`にスナップショット機能追加
- `RewindToAnchor` Effectを追加
- **既存システムとは独立して追加可能**

---

#### ❌ varietyBias（連発抑止）→ cooldownで最低限対応
**削減内容**:
- `VarietyBiasConfig`（履歴長、同カテゴリ連続制限、減衰率）
- 履歴管理システム
- 重み再計算ロジック

**代用方法**:
```csharp
// cooldownで最低限の連発抑止
ambientTalks: [
    { type: Random, p: 0.2, dialogue: "雑談", cooldownSteps: 5 }
]
```

**復活の容易さ**: ✅ **容易**
- `SideObjectTableSO`と`EncounterTableSO`に`varietyBias`フィールド追加
- 履歴を`GameState`に保存
- 重み計算時に履歴を参照
- **既存のテーブルSOは互換性維持**（フィールドがnullなら無視）

---

#### ❌ SpawnSource拡張（共有プール）→ ローカルのみ
**削減内容**:
- `SpawnSource`（PoolRef, TagQuery）
- 共有プールシステム
- タグクエリによる候補合流

**代用方法**:
- 各ノードで個別に候補を定義

**復活の容易さ**: ⚠️ **中程度**
- `SpawnSource`システムを追加
- `SideObjectTableSO`と`EncounterTableSO`を拡張
- **既存データは`type=LocalEntries`として扱える**

---

#### ❌ 遭遇率の高度制御 → baseRateのみ
**削減内容**:
- `R_pity(t)`（揺らぎ抑制）
- `graceSteps`（入場直後の猶予）
- `cooldownSteps`（遭遇直後のクールダウン）
- `minGapSteps / maxGapSteps`（間隔ガード）
- `softCap`（同カテゴリの指数減衰）

**代用方法**:
```csharp
// シンプルに確率のみ
encounters.baseRate = 0.25;  // 25%
```

**復活の容易さ**: ✅ **容易**
- `EncounterTableSO`にフィールド追加
- 遭遇判定ロジックに追加計算を挿入
- **既存のbaseRateはそのまま動作**

---

#### ❌ WeightMod/CurveByCounter → 固定重みのみ
**削減内容**:
- `WeightMod`（動的倍率）
- `CurveByCounter`（カウンタによる曲線補正）

**代用方法**:
```csharp
// 固定重み
entries: [
    { encounter: "wolf", weight: 10 },
    { encounter: "bear", weight: 5 }
]
```

**復活の容易さ**: ✅ **容易**
- `WeightModSO`を追加
- エントリに`weightMods[]`フィールド追加
- 重み計算時に乗算
- **既存データは変更不要**

---

#### ❌ OutcomeHook（戦闘結果フック）→ 通常処理のみ
**削減内容**:
- `OutcomeHook`（Win/Lose別の特殊処理）
- 条件付き結果分岐

**代用方法**:
- 戦闘後は常に同じ処理（敗北→拠点へ戻る等）

**復活の容易さ**: ✅ **容易**
- `EncounterSO`に`outcomeHooks[]`フィールド追加
- 戦闘終了処理でフック判定を追加
- **既存の`EncounterSO`は通常処理のまま動作**

---

#### ❌ FeatureFlags/ReleaseFlags → 全て有効
**削減内容**:
- `featureFlags`
- `releaseTags`
- ビルド時フィルタリング

**代用方法**:
- 全ての要素が常に有効

**復活の容易さ**: ✅ **容易**
- `NodeSO`等に`releaseFlags[]`フィールド追加
- ビルド時にフィルタ処理を追加
- **既存データはそのまま使用可能**

---

#### ❌ uiHints → 直接指定
**削減内容**:
- `UIHint`（背景/BGM/SE/演出ヒント）

**代用方法**:
- ノードIDやタグから直接参照

**復活の容易さ**: ✅ **非常に容易**
- `NodeSO`に`uiHints`フィールド追加
- **既存システムに影響なし**

---

### 9.3 拡張可能性の保証

#### ✅ **設計原則による保証**

1. **Node/Edge構造は不変**
   - 拡張は**DSL型の追加**で吸収
   - 既存のNodeSOにフィールドを**後方互換で追加**可能
   - データ移行不要（未知フィールドは無視）

2. **疎結合設計**
   - 各システムは独立
   - Overlay、TrackConfig、VarietyBias等は**オプション機能**
   - 無ければシンプルに動作、あれば機能拡張

3. **データ駆動**
   - ロジックはコードに、設定はScriptableObjectに分離
   - 新機能は新しいSOタイプを追加するだけ

#### ✅ **具体的な拡張手順**

**例: Overlayシステムの追加**
```csharp
// Step 1: OverlaySOを追加
[CreateAssetMenu(menuName="Walk/Overlay")]
public class OverlaySO : ScriptableObject {
    public string id;
    public float encounterRateMul = 1.0f;
    // ... 他の設定
}

// Step 2: GameStateに管理機能追加
public class GameState {
    private Stack<OverlaySO> _activeOverlays = new();
    
    public void PushOverlay(OverlaySO overlay) { /* ... */ }
    public float GetEncounterRateMul() { /* overlaysを乗算 */ }
}

// Step 3: PushOverlay/PopOverlay Effectを追加
[CreateAssetMenu(menuName="Walk/Effects/PushOverlay")]
public class PushOverlayEffect : EffectSO {
    public OverlaySO overlay;
    public override void Apply(GameContext ctx) {
        ctx.State.PushOverlay(overlay);
    }
}

// Step 4: 遭遇判定を修正
bool TryEncounterStep(...) {
    float p = baseRate * ctx.State.GetEncounterRateMul();  // ← 1行追加
    // ... 既存のロジック
}
```

**影響範囲**:
- ✅ 既存のNodeSOデータ: **変更不要**
- ✅ 既存のCondition/Effect: **動作継続**
- ✅ 既存の遭遇判定: **baseRateのみの動作を維持**
- ✅ 新規データ: **Overlayを使える**

---

### 9.4 実装段階の推奨順序

#### Phase 0: 最小構成（1-2週間）
```
✅ NodeSO（基本構造のみ）
✅ Condition（HasFlag, And, Or, Not）
✅ Effect（SetFlag, UnsetFlag, Jump）
✅ EncounterTable（baseRate + entries）
✅ AmbientTalkTrigger（Step, Random, Flag）
✅ ExitCandidate（conditions + toNodeId）
```

**動作確認**:
- 一本道の進行
- フラグによる分岐
- 基本的な遭遇
- 歩数/ランダム/フラグ会話

---

#### Phase 1: 基本機能の充実（1週間）
```
✅ Condition追加（HasItem, HasTag, Random）
✅ Effect追加（AddTag, RemoveTag, IncCounter）
✅ 遭遇の条件付き出現
✅ cooldownSteps（最低限の連発抑止）
✅ weight（重み付き抽選）
```

**動作確認**:
- 複雑な分岐条件
- 敵の条件付き出現
- カウンタを使った進行管理

---

#### Phase 2: 利便性向上（1-2週間）
```
⚠️ varietyBias（連発抑止の自動管理）
⚠️ uiHints（背景/SE/演出ヒント）
⚠️ 遭遇率の基本制御（graceSteps, cooldownSteps）
⚠️ OutcomeHook（戦闘結果分岐）
```

**動作確認**:
- 敵の連発抑止
- UI演出の自動化
- 入場直後の猶予期間
- 敗北時の特殊処理

---

#### Phase 3: 高度な機能（2-3週間）
```
⚠️ Overlay（状況レイヤ）
⚠️ TrackConfig + GateMarker（固定位置イベント門）
⚠️ SpawnSource（共有プール）
⚠️ WeightMod（動的重み補正）
```

**動作確認**:
- 昼夜システム
- 固定位置のボスイベント
- エリア横断の共有イベント
- カウンタによる重み変化

---

#### Phase 4: 高度な安定化（2週間）
```
⚠️ R_pity（遭遇間隔の揺らぎ抑制）
⚠️ Anchor/Rewind（状態巻き戻し）
⚠️ FeatureFlags/ReleaseFlags（段階リリース）
```

**動作確認**:
- 遭遇間隔の安定化
- 門の失敗時巻き戻し
- ビルドバリアント管理

---

### 9.5 最小構成でできることの確認

#### ✅ RPGとして完全に成立
- **基本ループ**: 歩く → 遭遇 → 戦闘 → 会話 → 分岐
- **ストーリー分岐**: フラグとConditionで実現
- **クエストシステム**: フラグ管理で実現
- **エリア間遷移**: ExitCandidateで実現

#### ✅ 実装できるシナリオ例
1. **鍵を探すクエスト**
   - 受注 → 探索（遭遇あり） → 鍵発見 → 救出 → 報酬
   
2. **昼夜で変化する街**
   - フラグ`is_night`で敵と遭遇率を切り替え
   
3. **敵撃破カウント**
   - フラグ`enemies_defeated_N`で進行管理
   
4. **条件付き分岐**
   - アイテム所持、フラグ、タグで出口を制御

#### ❌ 最小構成ではできないこと
- **天気・時間の自動変化** → フラグで手動管理で代用
- **固定位置の複雑な門** → 歩数会話で代用
- **状態の巻き戻し** → セーブ/ロードで代用
- **動的な重み変化** → 固定重みで代用
- **高度な連発抑止** → cooldownで最低限対応

---

### 9.6 拡張時の破壊的変更リスク

#### ✅ 破壊的変更が**発生しない**もの
- Overlay、varietyBias、uiHints、OutcomeHook、FeatureFlags、遭遇率制御
- **理由**: フィールド追加のみ、既存データはnullで動作

#### ⚠️ 注意が必要なもの
- TrackConfig（進行管理の変更）
- SpawnSource（候補システムの変更）
- **理由**: 既存ロジックの置き換えが必要だが、互換性レイヤーで吸収可能

#### ❌ 破壊的変更が**発生する可能性**があるもの
- なし
- **理由**: 設計が疎結合でモジュール化されている

---

### 9.7 結論: 最小構成から始めることの妥当性

#### ✅ **推奨理由**
1. **実装工数が半減**: 4-6週間 → 1-2週間
2. **早期に遊べる**: 最小構成でRPGとして完全に機能
3. **拡張が容易**: 設計が保証、データ移行不要
4. **リスクが低い**: 破壊的変更なし、段階的に追加

#### ✅ **実装方針**
```
Phase 0: 最小構成で完全なゲームループを実現（1-2週間）
  ↓
動作確認・テストプレイ・バランス調整
  ↓
Phase 1-2: 必要な機能を優先度順に追加（2-3週間）
  ↓
Phase 3-4: 高度な機能を必要に応じて追加（任意）
```

#### ✅ **「先に進むだけ＋分岐」で十分か？**
**回答: 完全に十分です。**

最小構成は以下を実現できます：
- 一本道の進行
- 条件付き分岐（フラグ、アイテム、タグ）
- ランダムエンカウント
- 会話イベント（歩数、ランダム、フラグ）
- クエスト管理
- エリア間遷移

これだけで「RPGとして完全に遊べる」状態が完成します。

#### ✅ **拡張案への移行は容易か？**
**回答: 非常に容易です。**

- 設計が疎結合でモジュール化
- フィールド追加による後方互換拡張
- データ移行不要
- 段階的に機能追加可能
- 破壊的変更なし

---

## 10) 最小構成の具体的な実装例（補足）

### NodeSOの最小実装（SpawnSource対応）
```csharp
[CreateAssetMenu(menuName="Walk/Node")]
public class NodeSO : ScriptableObject {
    public string nodeId;
    public string[] tags;
    public EffectSO[] onEnter;
    public EffectSO[] onExit;
    public EncounterTableSO encounters;     // ← SpawnSource方式を使用
    public AmbientTalkTrigger[] ambientTalks;
    public ExitCandidate[] exits;
}

// データ例（SpawnSource形式）
/*
encounterTable:
  baseRate: 0.25
  spawnSources:
    - type: LocalEntries
      entries:
        - encounter: wolf
          weight: 10
        - encounter: bear
          weight: 5
*/
```

### 実装の簡潔さ
- **約50行**: NodeSO本体
- **約30行**: Condition各種（HasFlag, And, Or, Not）
- **約30行**: Effect各種（SetFlag, UnsetFlag, Jump）
- **約50行**: EncounterTable + 判定ロジック
- **約40行**: AmbientTalkTrigger + 判定ロジック
- **約30行**: ExitCandidate + 判定ロジック

**合計約230行で基本システムが完成**（UI除く）

---

### 最終結論

**最小構成で「先に進むだけ＋分岐」を実装し、動作を確認してから段階的に拡張する戦略は、最も効率的で安全なアプローチです。**

- ✅ 実装工数: 半減
- ✅ 動作確認: 早期
- ✅ 拡張性: 保証
- ✅ リスク: 最小

---

## 11) 推奨実装戦略: 最初から拡張可能な設計

### 問題: 後から追加する難しさ

**TrackConfig/SpawnSourceを後から追加する場合**:
- 既存のステップ処理ロジックを**置き換える**必要がある
- 候補取得の単純参照を**複雑な合流処理**に変更する必要がある
- コードの大きな変更が発生

### 解決策: 最初から拡張可能な設計にする

**重要な発見**: 最初からフィールドを用意し、nullチェックで分岐すれば、後から追加する難しさがなくなる。

---

### 11.1 NodeSOの推奨実装

```csharp
[CreateAssetMenu(menuName="Walk/Node")]
public class NodeSO : ScriptableObject {
    // === 基本構造（Phase 0から実装）===
    public string nodeId;
    public string[] tags;
    
    // === 進入/退出処理（Phase 0から実装）===
    public EffectSO[] onEnter;
    public EffectSO[] onExit;
    
    // === イベント（Phase 0から実装）===
    public EncounterTableSO encounters;
    public AmbientTalkTrigger[] ambientTalks;
    
    // === 出口（Phase 0から実装）===
    public ExitCandidate[] exits;
    
    // === 拡張要素（Phase 0から追加、nullでOK）===
    public TrackConfig trackConfig;        // ← null許容（Phase 3で実装）
    public SideObjectTableSO sideObjects;  // ← null許容（Phase 2で実装）
    public UIHint uiHints;                 // ← null許容（Phase 2で実装）
}
```

**重要**: 
- ✅ フィールドは最初から存在
- ✅ nullなら従来の処理
- ✅ 後から値を設定するだけで機能する

---

### 11.2 EncounterTableSOの推奨実装

```csharp
[CreateAssetMenu(menuName="Walk/EncounterTable")]
public class EncounterTableSO : ScriptableObject {
    // === 基本要素（Phase 0から実装）===
    public float baseRate;
    public List<EncounterEntry> entries;  // ← ローカルエントリ（互換性用）
    
    // === 拡張要素（Phase 0から追加、nullでOK）===
    public List<SpawnSource> spawnSources;  // ← null許容（Phase 3で実装）
    public VarietyBiasConfig varietyBias;   // ← null許容（Phase 2で実装）
}
```

---

### 11.3 実行時の推奨実装

#### TrackConfig対応
```csharp
public class AreaController {
    void Step() {
        // TrackConfig対応（nullチェック）
        if (currentNode.trackConfig != null) {
            // Phase 3で実装する処理
            progress += currentNode.trackConfig.stepDelta;
            
            var gate = GetNextGate(progress);
            if (gate != null && !TryPassGate(gate)) {
                return; // 門で停止
            }
        }
        
        // 遭遇・会話（共通処理）
        var candidates = GetEncounterCandidates(currentNode.encounters);
        TryEncounter(candidates);
        TryAmbientTalk();
        
        // 出口判定（TrackConfig対応）
        if (CanExit()) {
            ChooseExit();
        }
    }
    
    bool CanExit() {
        // TrackConfigがある場合は進捗チェック
        if (currentNode.trackConfig != null) {
            return progress >= currentNode.trackConfig.length;
        }
        
        // ない場合は常にtrue（従来通り）
        return true;
    }
}
```

#### SpawnSource対応
```csharp
List<EncounterEntry> GetEncounterCandidates(EncounterTableSO table) {
    // SpawnSourceがある場合（Phase 3以降）
    if (table.spawnSources != null && table.spawnSources.Count > 0) {
        return MergeSpawnSources(table.spawnSources);
    }
    
    // ない場合はローカルエントリのみ（Phase 0〜2）
    return table.entries;
}

List<EncounterEntry> MergeSpawnSources(List<SpawnSource> sources) {
    var result = new List<EncounterEntry>();
    
    foreach (var source in sources) {
        switch (source.type) {
            case SpawnSourceType.LocalEntries:
                // Phase 3で実装
                result.AddRange(source.entries);
                break;
                
            case SpawnSourceType.PoolRef:
                // Phase 4で実装
                // var pool = FindPool(source.poolId);
                // result.AddRange(pool.entries);
                break;
                
            case SpawnSourceType.TagQuery:
                // Phase 4で実装
                // var tagged = FindByTags(source.tags);
                // result.AddRange(tagged);
                break;
        }
    }
    
    return Dedup(result, source.dedupPolicy);
}
```

---

### 11.4 段階的実装の流れ

#### Phase 0: 最小構成（1-2週間）
```csharp
// フィールドは全て存在するが、拡張要素はnull
var node = new NodeSO {
    nodeId = "forest_01",
    encounters = encounterTable,
    trackConfig = null,      // ← まだ使わない
    sideObjects = null,      // ← まだ使わない
    uiHints = null          // ← まだ使わない
};

// 実行時: nullチェックで従来の処理
if (node.trackConfig != null) {
    // スキップ
}
```

#### Phase 2: 基本機能追加（1週間）
```csharp
// SideObjectsを有効化
var node = new NodeSO {
    nodeId = "forest_01",
    encounters = encounterTable,
    sideObjects = sideObjectTable,  // ← 追加
    trackConfig = null,              // ← まだ使わない
    uiHints = null                  // ← まだ使わない
};

// 実行時: 自動的に動作
if (node.sideObjects != null) {
    // サイドオブジェクト処理 ← 自動的に実行される
}
```

#### Phase 3: TrackConfig追加（1-2週間）
```csharp
// TrackConfigを有効化
var node = new NodeSO {
    nodeId = "forest_01",
    encounters = encounterTable,
    sideObjects = sideObjectTable,
    trackConfig = new TrackConfig {
        length = 100,
        stepDelta = 1
    },  // ← 追加
    uiHints = null  // ← まだ使わない
};

// 実行時: 進捗管理が動作
if (node.trackConfig != null) {
    UpdateProgress();  // ← 自動的に実行される
    CheckGates();
}
```

---

### 11.5 利点の比較

| 方式 | 初期実装 | Phase 3追加 | 総変更量 | 破壊的変更 |
|------|----------|------------|---------|-----------|
| **後から追加** | シンプル | 大きな変更 | 大 | あり |
| **最初から対応** | やや複雑 | 小さな追加 | **小** | **なし** |

---

### 11.6 推奨事項

#### ✅ **最初から拡張可能な設計で実装する**

**理由**:
1. ✅ 総変更量が最小になる
2. ✅ 破壊的変更が発生しない
3. ✅ 既存データの変更が不要
4. ✅ Phase 0から段階的に有効化するだけ

**実装方針**:
```
Phase 0: 全フィールドを定義、拡張要素はnull
  ↓
Phase 1-2: 基本機能を追加（nullチェックで分岐）
  ↓
Phase 3-4: 高度機能を追加（値を設定するだけ）
```

**これが真の「aを77%で実装→100%」です。**

---

## 12) TrackConfig + 歩数会話の共存設計（推奨アプローチ）

### 12.0 重要な方針転換

**結論**: ✅ **TrackConfig + 歩数会話（AmbientTalkTrigger）は完全に共存可能、かつ推奨**

**理由**:
1. ✅ **TrackConfig**: 進行管理（門、進捗UI、巻き戻し）
2. ✅ **歩数会話**: フィールドイベント（雰囲気、ヒント、フラグ設定）
3. ✅ **目的が異なる**ため競合しない
4. ✅ 両方同時にカウントすれば完全に共存

**非推奨なのは**: ❌ TrackConfigと**StepCount条件の出口判定**の併用のみ

---

### 12.1 共存の仕組み

#### ランタイム状態

```csharp
public class WalkState {
    // 常にカウント（歩数会話用）
    public int stepCountInArea;  // ← 歩数会話が参照
    
    // TrackConfigがあるノードのみ使用
    public int trackProgress;    // ← TrackConfigの門が参照
}
```

#### 実行フロー

```csharp
void Step() {
    // === 1. 両方のカウンタを更新 ===
    ctx.Walk.stepCountInArea++;  // ← 常にカウント
    
    if (currentNode.trackConfig != null) {
        ctx.Walk.trackProgress += currentNode.trackConfig.stepDelta;
    }
    
    // === 2. TrackConfigの門チェック（進行管理） ===
    if (currentNode.trackConfig != null) {
        var gate = GetNextGate(ctx.Walk.trackProgress);
        if (gate != null && !TryPassGate(gate, ctx)) {
            return;  // 門で停止（進行ブロック）
        }
    }
    
    // === 3. 歩数会話（フィールドイベント） ===
    TryAmbientTalk(ctx.Walk.stepCountInArea, ctx);  // ← stepCountInAreaを参照
    
    // === 4. 遭遇 ===
    TryEncounter(ctx);
    
    // === 5. 出口判定 ===
    if (CanExit(ctx)) {
        ChooseExit(ctx);
    }
}

bool CanExit(GameContext ctx) {
    // TrackConfigがある場合: 進捗で判定
    if (currentNode.trackConfig != null) {
        return ctx.Walk.trackProgress >= currentNode.trackConfig.length;
    }
    
    // ない場合: 出口条件で判定
    return EvaluateExitConditions(ctx);
}
```

**重要**: 両方のカウンタは**独立**して動作する

---

### 12.2 データ構造

```csharp
[CreateAssetMenu(menuName="Walk/Node")]
public class NodeSO : ScriptableObject {
    public string nodeId;
    
    // === TrackConfig（進行管理） ===
    public TrackConfig trackConfig;  // ← nullでもOK
    
    // === 歩数会話（フィールドイベント） ===
    public AmbientTalkTrigger[] ambientTalks;  // ← 常に使用可能
    
    // === 遭遇・出口 ===
    public EncounterTableSO encounters;
    public ExitCandidate[] exits;
}

// TrackConfig: 進行管理とイベント門
[Serializable]
public class TrackConfig {
    public int length;           // 全長
    public int stepDelta = 1;    // 1歩の進捗量
    public Gate[] gates;         // イベント門（停止可能）
}

// Gate: 進行をブロックする門
[Serializable]
public class Gate {
    public int position;                 // trackProgress上の位置
    public DialogueDefinitionSO dialogue;
    public ConditionSO[] passConditions; // 通過条件
    public bool blocking = true;         // ← 停止するか
}

// AmbientTalkTrigger: フィールドイベント
[Serializable]
public class AmbientTalkTrigger {
    public AmbientTriggerType type;  // Step, Random, Flag
    public int stepMin;              // ← stepCountInAreaを参照
    public DialogueDefinitionSO dialogue;
    public bool once;
}
```

---

### 12.3 具体例: TrackConfig + 歩数会話の組み合わせ

```csharp
// Node: 長いダンジョン
nodeId: "dungeon_corridor"

// TrackConfig: 進行管理
trackConfig: {
    length: 100,      // 全長100
    stepDelta: 1,
    gates: [
        {
            position: 50,  // 50進捗で門出現
            dialogue: "ボスの気配",
            passConditions: [HasFlag("boss_key")],
            blocking: true  // ← 通過できないと停止
        },
        {
            position: 90,  // 90進捗で門出現
            dialogue: "最終ボス",
            passConditions: [],
            blocking: true
        }
    ]
}

// 歩数会話: フィールドイベント
ambientTalks: [
    {
        type: Step,
        stepMin: 10,
        dialogue: "暗闇が続く...",
        once: true
    },
    {
        type: Step,
        stepMin: 25,
        dialogue: "遠くで何か音がした",
        once: true
    },
    {
        type: Step,
        stepMin: 40,
        dialogue: "宝箱を発見！",
        once: true,
        onEnd: [SetFlag("found_treasure")]
    },
    {
        type: Step,
        stepMin: 60,
        dialogue: "ボスの咆哮が聞こえる",
        once: true
    },
    {
        type: Step,
        stepMin: 80,
        dialogue: "もうすぐ終わり...",
        once: true
    }
]
```

**プレイヤー体験**:
1. **10歩**: 「暗闇が続く...」（雰囲気）
2. **25歩**: 「遠くで何か音がした」（雰囲気）
3. **40歩**: 「宝箱を発見！」（フラグ設定）
4. **50進捗**: **門出現！** 鍵がないと進めない（**停止**）
   - 鍵があれば通過
5. **60歩**: 「ボスの咆哮が聞こえる」（警告）
6. **80歩**: 「もうすぐ終わり...」（ヒント）
7. **90進捗**: **最終ボス門！**（**停止**）
8. **100進捗**: 出口が有効になる

**重要**: 
- **歩数会話**（10, 25, 40, 60, 80歩）: `stepCountInArea`を参照
- **TrackConfigの門**（50, 90進捗）: `trackProgress`を参照
- 両方が**独立**して動作し、豊かな体験を作る

---

### 12.4 共存のメリット

#### ✅ TrackConfigだけでは作れない体験

```csharp
// 歩数会話で「雰囲気」を作る
ambientTalks: [
    { stepMin: 5, dialogue: "足音が響く..." },
    { stepMin: 15, dialogue: "壁に何か書かれている" },
    { stepMin: 30, dialogue: "冷たい風が吹いてきた" }
]

// TrackConfigで「進行管理」
trackConfig: {
    length: 50,
    gates: [
        { position: 40, dialogue: "ボス門", blocking: true }
    ]
}
```

**効果**:
- ✅ 雰囲気のある探索体験
- ✅ 明確な進行管理
- ✅ プレイヤーが「前に進んでいる」感覚

---

#### ✅ 歩数会話だけでは作れない体験

```csharp
// 歩数会話だけで門を作ろうとすると...
ambientTalks: [
    {
        stepMin: 50,
        dialogue: "ボスが立ちはだかる",
        onEnd: [SetFlag("boss_encountered")]
    }
]
```

**問題**:
- ❌ 会話は**通過可能**（停止できない）
- ❌ 鍵がなくても進める
- ❌ 進捗UIが作れない

```csharp
// TrackConfigなら
trackConfig: {
    gates: [
        {
            position: 50,
            dialogue: "ボス門",
            passConditions: [HasFlag("boss_key")],
            blocking: true  // ← 通過できないと停止
        }
    ]
}
```

**利点**:
- ✅ 鍵がないと**物理的に進めない**
- ✅ 進捗UIでボスまでの距離を表示
- ✅ 巻き戻しも可能

---

### 12.5 推奨戦略（更新版）

#### ✅ **Phase 0から TrackConfig + 歩数会話で実装**

**理由**:
1. ✅ 完全に共存可能
2. ✅ 後から変更する必要がない
3. ✅ 豊かな体験を作れる
4. ✅ データ移行不要

**実装方針**:
```
Phase 0: TrackConfig（LocalEntriesのみ）+ 歩数会話
  ↓
Phase 1-2: 基本機能追加
  ↓
Phase 3: PoolRef/TagQuery追加
```

---

### 12.7 実装の複雑さ

#### コード量の見積もり

**TrackConfig + 歩数会話**:
- TrackConfig構造: 約20行
- Gate処理: 約40行
- AmbientTalkTrigger: 約30行
- Step実行フロー: 約50行
- **合計**: 約140行

**追加実装量**:
- 最小アプローチ（歩数会話のみ）: 約80行
- **差分**: +60行（TrackConfig追加分）

**結論**: ✅ TrackConfigを最初から入れても、追加実装は+60行程度

---

### 12.8 最小アプローチ（TrackConfigなし）も有効

**重要**: ✅ **TrackConfigはオプショナル。ないノードではStepCount条件で出口判定**

#### 最小アプローチのノード例

```csharp
// Node: シンプルなエリア（TrackConfigなし）
nodeId: "simple_area"

trackConfig: null  // ← TrackConfigを使わない

// 歩数会話: フィールドイベント
ambientTalks: [
    { stepMin: 10, dialogue: "中間地点" },
    { stepMin: 20, dialogue: "もうすぐ出口" }
]

// 出口: StepCount条件で判定
exits: [
    {
        toNodeId: "next",
        conditions: [StepCountInArea(min: 30)]  // ← 30歩で出口有効
    }
]
```

**動作**:
1. 10歩: 「中間地点」会話
2. 20歩: 「もうすぐ出口」会話
3. 30歩: 出口が有効になる

**利点**:
- ✅ 実装が簡単（TrackConfig不要）
- ✅ 歩数会話は使える
- ✅ シンプルなエリアには十分

**欠点**:
- ❌ 門で停止できない
- ❌ 進捗UIが作れない

---

### 12.9 実装フローの全体像

```csharp
void Step() {
    // === 1. カウンタ更新 ===
    ctx.Walk.stepCountInArea++;  // ← 常にカウント
    
    if (currentNode.trackConfig != null) {
        ctx.Walk.trackProgress += currentNode.trackConfig.stepDelta;
    }
    
    // === 2. TrackConfigの門チェック（あれば） ===
    if (currentNode.trackConfig != null) {
        var gate = GetNextGate(ctx.Walk.trackProgress);
        if (gate != null && !TryPassGate(gate, ctx)) {
            return;  // 門で停止
        }
    }
    
    // === 3. 歩数会話（常に実行） ===
    TryAmbientTalk(ctx.Walk.stepCountInArea, ctx);
    
    // === 4. 遭遇 ===
    TryEncounter(ctx);
    
    // === 5. 出口判定 ===
    if (CanExit(ctx)) {
        ChooseExit(ctx);
    }
}

bool CanExit(GameContext ctx) {
    // TrackConfigがある場合: trackProgressで判定
    if (currentNode.trackConfig != null) {
        return ctx.Walk.trackProgress >= currentNode.trackConfig.length;
    }
    
    // TrackConfigがない場合: StepCount条件で判定
    return EvaluateExitConditions(ctx);  // ← StepCountInArea条件等
}
```

---

### 12.10 まとめ: 2つのアプローチ

#### ✅ **アプローチA: TrackConfig + 歩数会話（推奨）**

**使用場面**: 門、進捗UI、巻き戻しが必要なノード

```csharp
nodeId: "dungeon"

trackConfig: {
    length: 100,
    gates: [
        { position: 50, dialogue: "ボス門", blocking: true }
    ]
}

ambientTalks: [
    { stepMin: 10, dialogue: "雰囲気1" },
    { stepMin: 20, dialogue: "雰囲気2" }
]

exits: [
    { toNodeId: "next" }  // trackConfig.lengthで自動判定
]
```

**利点**: 門、進捗UI、巻き戻し、豊かな体験

---

#### ✅ **アプローチB: StepCount条件 + 歩数会話（最小）**

**使用場面**: シンプルなエリア（門不要）

```csharp
nodeId: "simple_area"

trackConfig: null  // TrackConfigなし

ambientTalks: [
    { stepMin: 10, dialogue: "雰囲気1" },
    { stepMin: 20, dialogue: "雰囲気2" }
]

exits: [
    {
        toNodeId: "next",
        conditions: [StepCountInArea(min: 30)]  // StepCount条件
    }
]
```

**利点**: 実装が簡単、シンプルなエリアには十分

---

#### 📊 使い分け

| ノードの特性 | 推奨アプローチ |
|-------------|--------------|
| 門が必要 | **A: TrackConfig** |
| 進捗UI必要 | **A: TrackConfig** |
| 巻き戻し必要 | **A: TrackConfig** |
| シンプルなエリア | **B: StepCount条件** |
| 雰囲気会話のみ | **B: StepCount条件** |

**重要**: ✅ **両方のアプローチが同じプロジェクトで共存可能**

---

