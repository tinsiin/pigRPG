# 中核仕様：設計思想と確率ベースイベントシステム

> **目的**: 中核仕様が目指す「確率とフラグのみで、キャラに合わせた選択的イベント体験」を実現する設計思想を明確化する。

---

## 0. TL;DR（設計思想の核心）

**中核仕様が目指すゲーム体験**:

```
確率のみで制御 + フラグ/パッシブ状態 + 左右選択
= キャラに合わせた動的イベント + プレイヤーの選択制 + ランダム性
```

**歩数管理は不要**: すべてを確率とフラグで制御できる

---

## 1. 設計思想の全体像

### 1.1 中核となる3つの要素

#### ① サイドオブジェクト（イベント候補プール）

```csharp
// サイドオブジェクトテーブル
public class SideObjectTableSO {
    public float baseRate;  // 毎歩の出現確率（例: 0.3 = 30%）
    public List<SideObjectEntry> entries;  // イベント候補
}

public class SideObjectEntry {
    public SideObjectDefinitionSO definition;  // イベント定義
    public int weight;  // 重み
    public ConditionSO[] conditions;  // 出現条件
}
```

**特徴**:
- ✅ 毎歩ランダムに抽選（確率ベース）
- ✅ フラグ条件でフィルタ
- ✅ 左右のペアとして提示

---

#### ② 左右選択（プレイヤーの意思決定）

```
毎歩の処理:
1. サイドオブジェクトテーブルから候補を抽選
2. 左右2つのペアとして提示
3. プレイヤーが選択（または進むのみ）
4. 選んだ方のイベントを実行
```

**意義**:
- ✅ プレイヤーに選択権を与える
- ✅ ランダム性と選択制の共存
- ✅ 「どちらが良いか」の判断が戦略性を生む

---

#### ③ 動的イベント選択（キャラの状態に応じた分岐）

```csharp
// サイドオブジェクト定義
public class SideObjectDefinitionSO {
    public string id;
    public EventResolver resolver;  // イベント解決方法
}

// イベント解決方法（選択時に決定）
public class EventResolver {
    public ResolverEntry[] entries;  // 実行候補
}

public class ResolverEntry {
    public ConditionSO[] conditions;  // 実行条件
    public int weight;  // 重み
    public DialogueDefinitionSO dialogue;  // 実行する会話
    public EffectSO[] effects;  // 実行する効果
}
```

**動作**:
1. プレイヤーがサイドオブジェクトを選択
2. **選択時にキャラの状態（フラグ、パッシブ等）をチェック**
3. 条件に合うイベントを抽選
4. キャラに合ったイベントを実行

---

## 2. 具体的な動作例

### 2.1 基本例：フラグによる順番制御

#### シナリオ
「導入イベント→展開イベント→クライマックス」の順番でイベントを起こしたい

#### 従来の考え方（歩数依存）
```csharp
// ❌ 歩数カウントが必要
ambientTalks: [
    { stepMin: 10, dialogue: "導入イベント", onEnd: [SetFlag("intro_done")] },
    { stepMin: 30, dialogue: "展開イベント", onEnd: [SetFlag("develop_done")] },
    { stepMin: 50, dialogue: "クライマックス" }
]
```

#### 中核仕様の考え方（確率 + フラグ）
```csharp
// ✅ 確率のみで順番制御
sideObjects: {
    baseRate: 0.3,  // 毎歩30%で左右に出現
    entries: [
        {
            definition: "導入イベント",
            weight: 10,
            conditions: []  // 最初から出現可能
        },
        {
            definition: "展開イベント",
            weight: 10,
            conditions: [HasFlag("intro_done")]  // 導入後のみ
        },
        {
            definition: "クライマックス",
            weight: 10,
            conditions: [HasFlag("develop_done")]  // 展開後のみ
        }
    ]
}

// 各イベント定義
intro_event: {
    id: "導入イベント",
    resolver: {
        entries: [
            {
                dialogue: "導入会話",
                effects: [SetFlag("intro_done")]
            }
        ]
    }
}
```

**プレイヤー体験**:
1. **1-N歩**: 30%で「導入イベント」が左右に出現 → 選択 → `intro_done`
2. **N+1歩以降**: 30%で「展開イベント」が候補に追加 → 選択 → `develop_done`
3. **M+1歩以降**: 30%で「クライマックス」が候補に追加

**利点**:
- ✅ 順番は保証される（フラグ依存）
- ✅ いつ出るかはランダム（ドキドキ感）
- ✅ 歩数カウント不要

---

### 2.2 高度な例：キャラの状態に応じた動的分岐

#### シナリオ
同じサイドオブジェクト「森の泉」でも、キャラの状態（パッシブ）で異なるイベントが起こる

#### データ定義

```csharp
// サイドオブジェクト
sideObjects: {
    entries: [
        {
            definition: "森の泉",
            weight: 10,
            conditions: []  // 常に出現可能
        }
    ]
}

// サイドオブジェクト定義（動的選択）
forest_spring: {
    id: "森の泉",
    resolver: {
        entries: [
            {
                // 火属性パッシブがある場合
                conditions: [HasPassive("FireAffinity")],
                weight: 1,
                dialogue: "泉から炎の精霊が現れた！",
                effects: [AddItem("FireCrystal")]
            },
            {
                // 水属性パッシブがある場合
                conditions: [HasPassive("WaterAffinity")],
                weight: 1,
                dialogue: "泉の水が神秘的に輝いている",
                effects: [HealHP(50)]
            },
            {
                // 探索フラグがある場合
                conditions: [HasFlag("探索中")],
                weight: 1,
                dialogue: "泉の底に何か光るものが...",
                effects: [AddItem("HiddenTreasure")]
            },
            {
                // デフォルト
                conditions: [],
                weight: 1,
                dialogue: "美しい泉だ",
                effects: [HealHP(20)]
            }
        ]
    }
}
```

**動作**:
1. プレイヤーが「森の泉」を選択
2. **選択時**にキャラの状態をチェック:
   - `HasPassive("FireAffinity")` → 炎の精霊イベント
   - `HasPassive("WaterAffinity")` → 神秘の輝きイベント
   - `HasFlag("探索中")` → 隠し宝イベント
   - どれもなし → デフォルトイベント
3. キャラに合ったイベントを実行

**プレイヤー体験**:
- ✅ 同じサイドオブジェクトでも異なる体験
- ✅ キャラビルドが体験に影響
- ✅ リプレイ性の向上

---

### 2.3 さらに高度な例：複数条件の組み合わせ

#### シナリオ
「森の泉」のイベントが、パッシブ + フラグ + 時間帯（Overlay）で変化

```csharp
forest_spring_advanced: {
    id: "森の泉",
    resolver: {
        entries: [
            {
                // 夜 + 火属性 + 特定フラグ
                conditions: [
                    OverlayActive("Night"),
                    HasPassive("FireAffinity"),
                    HasFlag("精霊契約")
                ],
                weight: 1,
                dialogue: "夜の泉で炎の精霊王が現れた！",
                effects: [StartBattle("FireSpiritKing")]
            },
            {
                // 昼 + 水属性 + 高レベル
                conditions: [
                    Not(OverlayActive("Night")),
                    HasPassive("WaterAffinity"),
                    LevelAtLeast(20)
                ],
                weight: 1,
                dialogue: "泉の守護者が試練を与える",
                effects: [StartBattle("Guardian")]
            },
            // ... その他のバリエーション
            {
                // デフォルト
                conditions: [],
                weight: 1,
                dialogue: "美しい泉だ",
                effects: [HealHP(20)]
            }
        ]
    }
}
```

**影響を与える要素**:
- ✅ パッシブ（BasePassive）
- ✅ フラグ（シナリオ進行度）
- ✅ Overlay（時間帯、天候、警戒度等）
- ✅ レベル、所持アイテム等
- ✅ **将来的な拡張要素すべて**（中核仕様により担保）

---

## 3. 左右選択の戦略性

### 3.1 選択の意思決定

```
例: 左右に異なるサイドオブジェクトが出現

左: 「森の泉」（回復イベントかも？）
右: 「怪しい影」（戦闘イベントかも？）

プレイヤーの判断:
- HP少ない → 左（泉）を選ぶ
- レベル上げたい → 右（戦闘）を選ぶ
- どちらも無視して進む
```

### 3.2 情報の非対称性

```csharp
// サイドオブジェクトのUIヒント
sideObject_forest_spring: {
    uiLabel: "森の泉",  // プレイヤーに見える名前
    uiIcon: "spring_icon",
    uiHint: "何かが起こりそう..."  // 曖昧なヒント
    
    // 実際のイベントは選択時に決定
    resolver: { ... }
}
```

**プレイヤー体験**:
- ✅ 「森の泉」とわかるが、何が起こるかはわからない
- ✅ 自分の状態（パッシブ等）から推測する楽しみ
- ✅ 予想外のイベントも起こる（サプライズ）

---

## 4. 確率のみでの制御（歩数管理との比較）

### 4.1 順番制御の比較

| 要素 | 歩数管理 | 確率 + フラグ |
|------|---------|-------------|
| **順番保証** | ✅ 10歩目、20歩目 | ✅ フラグ依存 |
| **ランダム性** | ❌ 固定位置 | ✅ いつ出るか不明 |
| **実装** | TrackConfig必要 | 既存機能のみ |
| **中核仕様準拠** | ❌ 逸脱 | ✅ 完全準拠 |

---

### 4.2 動的イベント選択の比較

| 要素 | 歩数管理 | 確率 + フラグ |
|------|---------|-------------|
| **キャラ状態反映** | ⚠️ 別途実装必要 | ✅ resolver機構で自然に実現 |
| **拡張性** | ⚠️ 新しい条件追加が困難 | ✅ ConditionSO追加のみ |
| **リプレイ性** | ❌ 毎回同じ位置 | ✅ キャラビルドで変化 |

---

### 4.3 プレイヤー体験の比較

#### 歩数管理アプローチ
```
プレイヤー: 「10歩歩けばイベントが起こる」
→ 予測可能、安心感はあるが驚きが少ない
```

#### 確率 + フラグアプローチ
```
プレイヤー: 「いつ出るかわからないが、順番は保証される」
→ ドキドキ感、サプライズ性、でも安心感もある
```

---

## 5. 中核仕様との完全な整合性

### 5.1 中核仕様の原則

```
1. サイドオブジェクト: 毎歩ランダム抽選（確率ベース）
2. 候補フィルタ: 条件（フラグ、パッシブ等）でフィルタ
3. 左右ペア提示: プレイヤーが選択
4. メモリレス: 歩数や座標に依存しない
5. 拡張可能: ConditionSO追加で新しい条件を導入
```

### 5.2 このアプローチの準拠状況

| 原則 | 準拠状況 |
|------|---------|
| 確率ベース | ✅ 完全準拠（baseRate） |
| 条件フィルタ | ✅ 完全準拠（ConditionSO） |
| 左右選択 | ✅ 完全準拠（中核機能） |
| メモリレス | ✅ 完全準拠（歩数不要） |
| 拡張可能 | ✅ 完全準拠（DSL追加） |

**結論**: ✅ **中核仕様に完全準拠**

---

## 6. 将来的な拡張性

### 6.1 追加可能な要素（例）

#### ① パッシブによる影響
```csharp
// 新しいConditionSO
public class HasPassiveCondition : ConditionSO {
    public string passiveId;
    public override bool Evaluate(GameContext ctx) {
        return ctx.Player.HasPassive(passiveId);
    }
}
```

#### ② 時間帯による影響
```csharp
// 既存のOverlay機構を使用
overlay_night: {
    encounterMods: [
        { category: "夜行性", weightMultiplier: 2.0 }
    ],
    sideObjectMods: [
        { id: "精霊イベント", weightMultiplier: 1.5 }
    ]
}
```

#### ③ 所持アイテムによる影響
```csharp
// 新しいConditionSO
public class HasItemCondition : ConditionSO {
    public string itemId;
    public override bool Evaluate(GameContext ctx) {
        return ctx.Player.HasItem(itemId);
    }
}
```

#### ④ クエスト状態による影響
```csharp
// フラグの拡張
public class QuestStateCondition : ConditionSO {
    public string questId;
    public QuestState requiredState;
    public override bool Evaluate(GameContext ctx) {
        return ctx.Quest.GetState(questId) == requiredState;
    }
}
```

**重要**: ✅ **中核仕様のConditionSO機構により、すべて追加可能**

---

### 6.2 複雑なイベント連鎖の例

#### シナリオ: 「精霊契約」クエストライン

```csharp
// ステップ1: 精霊の噂を聞く
sideObject_rumor: {
    conditions: [],  // 最初から出現可能
    resolver: {
        entries: [
            {
                dialogue: "精霊の噂を聞いた",
                effects: [SetFlag("精霊の噂")]
            }
        ]
    }
}

// ステップ2: 精霊を目撃
sideObject_sighting: {
    conditions: [HasFlag("精霊の噂")],  // 噂を聞いた後
    resolver: {
        entries: [
            {
                conditions: [OverlayActive("Night")],  // 夜のみ
                dialogue: "精霊を目撃した！",
                effects: [SetFlag("精霊目撃")]
            }
        ]
    }
}

// ステップ3: 精霊との接触
sideObject_contact: {
    conditions: [
        HasFlag("精霊目撃"),
        HasItem("聖なる水晶")  // アイテム必要
    ],
    resolver: {
        entries: [
            {
                conditions: [HasPassive("霊感")],  // パッシブがあれば成功
                dialogue: "精霊と契約した！",
                effects: [
                    SetFlag("精霊契約"),
                    AddPassive("精霊の加護")
                ]
            },
            {
                conditions: [],  // パッシブがなければ失敗
                dialogue: "精霊に拒絶された...",
                effects: [SetFlag("精霊契約失敗")]
            }
        ]
    }
}
```

**特徴**:
- ✅ 複雑なクエスト連鎖
- ✅ 複数の条件（フラグ、Overlay、アイテム、パッシブ）
- ✅ 成功/失敗の分岐
- ✅ すべて確率ベース（歩数不要）

---

## 7. 設計思想のまとめ

### 7.1 核心となる考え方

```
歩数管理は「順番」を作るための手段に過ぎない
↓
本当に欲しいのは「順番」そのもの
↓
フラグ依存で順番は保証できる
↓
歩数管理は不要
```

### 7.2 確率 + フラグの威力

**実現できること**:
1. ✅ **順番制御**（フラグ依存）
2. ✅ **ランダム性**（いつ出るか不明）
3. ✅ **キャラ適応**（パッシブ、レベル等で変化）
4. ✅ **プレイヤー選択**（左右選択）
5. ✅ **リプレイ性**（キャラビルドで変化）
6. ✅ **拡張性**（ConditionSO追加で無限に拡張）

**必要ないもの**:
- ❌ 歩数カウント
- ❌ TrackConfig
- ❌ Gate（固定位置イベント）
- ❌ 進捗管理

---

### 7.3 中核仕様が目指すゲーム体験

```
プレイヤー視点:
「このキャラビルドだと、どんなイベントが起こるかな？」
「左右どっちを選ぼう？」
「お、こんなイベントもあるのか！」（サプライズ）

開発者視点:
「新しい条件を追加するだけで、イベントバリエーションが増える」
「データ変更のみで、ゲームバランス調整ができる」
「プログラムコードの変更は不要」
```

**これが中核仕様の目指す姿**

---

## 8. プロトタイプとの関係

### 8.1 プロトタイプでの妥協

**プロトタイプ（現在）**:
- ⚠️ TrackConfig + 歩数会話を使用
- 理由: 開発効率優先

**完成形（将来）**:
- ✅ 確率 + フラグのみ
- 理由: 中核仕様に準拠

### 8.2 移行の容易さ

```yaml
# プロトタイプのノード
trackConfig: { length: 50, gates: [...] }
ambientTalks: [...]

↓ データ変更のみ

# 完成形のノード
trackConfig: null  # ← nullにするだけ
ambientTalks: []   # ← 空にするだけ
sideObjects: { ... }  # ← サイドオブジェクトに移行
```

**移行コスト**:
- ✅ プログラムコードの変更: **不要**
- ✅ データファイルの変更: **必要**
- ✅ 設計の互換性: **保証されている**

---

## 9. 結論

### ✅ 中核仕様の設計思想

1. **すべてを確率で制御**
   - メモリレス遭遇
   - ランダム抽選
   - 歩数非依存

2. **フラグ/パッシブで順番と分岐を制御**
   - 順番保証（フラグ依存）
   - キャラ適応（パッシブ、レベル等）
   - 動的イベント選択（resolver機構）

3. **左右選択で戦略性を提供**
   - プレイヤーの意思決定
   - 情報の非対称性
   - リスク/リターンの判断

4. **無限の拡張性**
   - ConditionSO追加で新しい条件
   - EffectSO追加で新しい効果
   - Overlay追加で新しい状況

### ✅ 目指すゲーム体験

```
確率のみで制御 + フラグ/パッシブ状態 + 左右選択
= キャラに合わせた動的イベント + プレイヤーの選択制 + ランダム性
```

**歩数管理は不要。確率とフラグで、すべてを実現できる。**

---

**このドキュメントは、将来的な完成形（中核仕様準拠）のための設計思想を示すものである。**
