# 中央オブジェクト抽選システム実装計画

## 概要

現在の中央オブジェクトは NodeSO に固定で埋め込まれているが、サイドオブジェクトと同様に**テーブルから抽選する方式**に変更する。

## 背景・動機

### 現状の問題

```
現在のNodeSO:
├── sideObjectTable: SideObjectTableSO  ← 抽選テーブル（複数候補から選ぶ）
├── centralVisual: CentralObjectVisual  ← 固定（1つだけ）
└── centralEvent: EventDefinitionSO     ← 固定（1つだけ）
```

**問題点:**
- 1つのNodeで1つの中央オブジェクトしか設定できない
- ステージで常に同じイベントしか発生しない
- サイドオブジェクトは抽選なのに、中央オブジェクトだけ固定は設計の不整合

### 期待する状態

```
修正後のNodeSO:
├── sideObjectTable: SideObjectTableSO    ← 抽選テーブル
├── centralObjectTable: CentralObjectTableSO  ← 抽選テーブル（新規）
└── fixedCentralObject: CentralObjectSO   ← ノード入場時固定（オプション）
```

### 関連機能：3者会話構図

この抽選システムは [3者会話構図設計.md](../ノベルパート/3者会話構図設計.md) の前提となる。

```
抽選で中央オブジェクトが選ばれる
    ↓
ユーザーがアプローチ
    ↓
ズームイン（演出ズーム）
    ↓
ノベルパート開始（3者会話構図）
    ↓
会話中に中央オブジェクトのスプライト変更可能  ← 3者会話構図設計の範囲
```

つまり:
- **本計画**: 「どの中央オブジェクトが出現するか」の抽選
- **3者会話構図**: 「会話中に中央オブジェクトの見た目をどう変えるか」

---

## 設計方針

### サイドオブジェクトとの構造対比

| 項目 | サイドオブジェクト | 中央オブジェクト（新規） |
|------|------------------|------------------------|
| テーブルSO | SideObjectTableSO | CentralObjectTableSO |
| エントリ | SideObjectEntry | CentralObjectEntry |
| オブジェクトSO | SideObjectSO | CentralObjectSO |
| 抽選ロジック | SideObjectSelector | CentralObjectSelector |
| 出現数 | 左右ペア（2個） | 単体（1個） |
| Prefab | prefabLeft/prefabRight | なし（Visual構造体で表現） |

### 中央オブジェクト固有の特性

サイドオブジェクトと異なる点:
1. **単体抽選**: 左右ペアではなく1つだけ選ぶ
2. **Visual構造体**: Prefabではなく `CentralObjectVisual` で見た目を定義（Sprite方式を維持）
3. **ズーム連携**: 選ばれた中央オブジェクトにズームしてノベルパートを開始できる
4. **アニメーション方向**: サイドは左右から登場/退場、中央はその場で登場/真上へ退場

### サイドオブジェクトとの見た目定義の違い

| 項目 | サイドオブジェクト | 中央オブジェクト |
|------|------------------|----------------|
| 見た目定義 | Prefab (GameObject) | Visual構造体 (Sprite) |
| 描画方式 | UILineRenderer（プログラム描画） | Image（Sprite表示） |
| 配置情報 | SideObjectMove内に埋め込み | Visual構造体で直接指定 |
| アニメーション | SideObjectMove（左右から登場） | CentralObjectAnimator（中央で登場） |

**→ Sprite + Visual構造体方式を維持し、アニメーションは専用クラスで実装**

---

## データ構造

### 1. CentralObjectSO（新規）

```csharp
[CreateAssetMenu(menuName = "Walk/CentralObject")]
public sealed class CentralObjectSO : ScriptableObject
{
    [SerializeField] private string id;
    [SerializeField] private string uiLabel;
    [SerializeField] private CentralObjectVisual visual;
    [SerializeField] private EventDefinitionSO eventDefinition;

    public string Id => id;
    public string UILabel => string.IsNullOrEmpty(uiLabel) ? id : uiLabel;
    public CentralObjectVisual Visual => visual;
    public EventDefinitionSO EventDefinition => eventDefinition;
}
```

### 2. CentralObjectTableSO（新規）

```csharp
[CreateAssetMenu(menuName = "Walk/CentralObject Table")]
public sealed class CentralObjectTableSO : ScriptableObject
{
    [SerializeField] private CentralObjectEntry[] entries;
    [SerializeField] private float varietyBias = 0.5f;
    [Tooltip("Number of recent picks to track for variety bias. 0 = disabled.")]
    [SerializeField] private int varietyDepth;

    public CentralObjectEntry[] Entries => entries;
    public float VarietyBias => varietyBias;
    public int VarietyDepth => varietyDepth;
}
```

### 3. CentralObjectEntry（新規）

```csharp
[Serializable]
public sealed class CentralObjectEntry
{
    [SerializeField] private CentralObjectSO centralObject;
    [SerializeField] private float weight = 1f;
    [SerializeField] private ConditionSO[] conditions;
    [Tooltip("Steps before this can appear again after selection. 0 = no cooldown.")]
    [SerializeField] private int cooldownSteps;

    public CentralObjectSO CentralObject => centralObject;
    public float Weight => weight;
    public ConditionSO[] Conditions => conditions;
    public int CooldownSteps => cooldownSteps;
}
```

### 4. NodeSO の変更

```csharp
// 削除
// [SerializeField] private EventDefinitionSO centralEvent;
// [SerializeField] private CentralObjectVisual centralVisual;

// 追加
[SerializeField] private CentralObjectTableSO centralObjectTable;
[SerializeField] private CentralObjectSO fixedCentralObject;  // ノード入場時固定（オプション）

public CentralObjectTableSO CentralObjectTable => centralObjectTable;
public CentralObjectSO FixedCentralObject => fixedCentralObject;
```

---

## 抽選ロジック

### CentralObjectSelector（新規）

サイドオブジェクトの `SideObjectSelector` をベースに、単体抽選版を実装。

```csharp
public sealed class CentralObjectSelector
{
    private readonly VarietyHistory varietyHistory = new();
    private readonly CentralObjectCooldownTracker cooldownTracker = new();

    public void Configure(int varietyDepth)
    {
        varietyHistory.MaxDepth = varietyDepth;
    }

    /// <summary>
    /// 中央オブジェクトを1つ抽選する。
    /// </summary>
    public CentralObjectEntry Roll(
        CentralObjectTableSO table,
        NodeSO node,
        GameContext context,
        bool isNodeEntry = false)
    {
        if (table == null) return null;

        // ノード入場時の固定中央オブジェクト
        if (isNodeEntry && node?.FixedCentralObject != null)
        {
            return FindEntryByCentralObject(table, node.FixedCentralObject);
        }

        // 通常の重み付き抽選
        return PickWithFilters(table, context);
    }

    public void OnCentralObjectSelected(CentralObjectEntry selected, int cooldownSteps)
    {
        if (selected?.CentralObject == null) return;

        var id = selected.CentralObject.Id;
        varietyHistory.Record(id);

        if (cooldownSteps > 0)
        {
            cooldownTracker.StartCooldown(id, cooldownSteps);
        }
    }

    public void AdvanceStep()
    {
        cooldownTracker.AdvanceStep();
    }

    public void Reset()
    {
        varietyHistory.Clear();
        cooldownTracker.Clear();
    }

    // 状態保存/復元メソッド（省略）

    private CentralObjectEntry PickWithFilters(CentralObjectTableSO table, GameContext context)
    {
        // SideObjectSelector.PickWithFilters と同じロジック
        // - 条件評価
        // - クールダウンチェック
        // - バラエティバイアス適用
        // - 重み付き抽選
    }
}
```

---

## AreaController の変更

### 変更前

```csharp
var centralEvent = currentNode.CentralEvent;
var hasCentral = centralEvent != null || currentNode.CentralVisual.HasVisual;
```

### 変更後

```csharp
// 中央オブジェクト抽選
var centralEntry = centralObjectSelector.Roll(
    currentNode.CentralObjectTable,
    currentNode,
    context,
    isNodeEntry: isNodeEntry);

var centralEvent = centralEntry?.CentralObject?.EventDefinition;
var centralVisual = centralEntry?.CentralObject?.Visual ?? default;
var hasCentral = centralEntry != null;
```

### ShowApproachObjects の変更

```csharp
private void ShowApproachObjects(SideObjectEntry[] sidePair, CentralObjectEntry centralEntry)
{
    sidePresenter?.Show(sidePair);

    if (centralEntry != null)
    {
        centralPresenter?.Show(centralEntry.CentralObject.Visual, forceShow: true);
    }
    else
    {
        centralPresenter?.Hide();
    }
}
```

---

## アニメーション

サイドオブジェクトと同様にLitMotionを使用したアニメーションを実装する。

### サイドオブジェクトとの比較

| 項目 | サイドオブジェクト | 中央オブジェクト |
|------|------------------|----------------|
| 登場方向 | 左右から画面内へスライド | **その場で**（位置移動なし） |
| 登場演出 | 位置+透明度+スケール+回転 | **透明度+スケール**のみ |
| 退場方向 | 左右へ捌ける（2段階移動） | **真上へ**捌ける |
| 退場演出 | 位置移動のみ | 位置移動+透明度フェード |

### CentralAnimConfig（新規）

```csharp
[Serializable]
public struct CentralAnimConfig
{
    [Header("フェードイン")]
    [Tooltip("フェードイン時間")]
    public float FadeInDuration;      // 0.3f

    [Tooltip("開始時のスケール（1.0未満で小さく、1.0超で大きく）")]
    public float FadeInStartScale;    // 0.8f

    [Tooltip("フェードインのイージング")]
    public Ease FadeInEase;           // OutBack（ポップな感じ）

    [Header("フェードアウト")]
    [Tooltip("フェードアウト時間")]
    public float FadeOutDuration;     // 0.25f

    [Tooltip("上方向への移動距離（ピクセル）")]
    public float FadeOutUpDistance;   // 100f

    [Tooltip("フェードアウトのイージング")]
    public Ease FadeOutEase;          // InQuad（加速して消える）

    public static CentralAnimConfig Default => new CentralAnimConfig
    {
        FadeInDuration = 0.3f,
        FadeInStartScale = 0.8f,
        FadeInEase = Ease.OutBack,
        FadeOutDuration = 0.25f,
        FadeOutUpDistance = 100f,
        FadeOutEase = Ease.InQuad
    };
}
```

### CentralObjectAnimator（新規）

```csharp
using Cysharp.Threading.Tasks;
using LitMotion;
using LitMotion.Extensions;
using UnityEngine;
using UnityEngine.UI;

public sealed class CentralObjectAnimator
{
    private readonly Image image;
    private readonly RectTransform rect;
    private readonly CentralAnimConfig config;

    private Vector3 originalScale;
    private Vector2 originalPosition;
    private bool isFadingIn;

    public CentralObjectAnimator(Image image, RectTransform rect, CentralAnimConfig config)
    {
        this.image = image;
        this.rect = rect;
        this.config = config;
    }

    /// <summary>
    /// フェードイン: その場で透明→不透明、小さい→通常サイズ
    /// </summary>
    public async UniTask FadeInAsync(CancellationToken ct = default)
    {
        isFadingIn = true;
        originalScale = rect.localScale;
        originalPosition = rect.anchoredPosition;

        // 初期状態：透明、少し小さく
        SetAlpha(0f);
        rect.localScale = originalScale * config.FadeInStartScale;

        var completed = 0;

        // 透明度アニメーション
        LMotion.Create(0f, 1f, config.FadeInDuration)
            .WithEase(config.FadeInEase)
            .WithOnComplete(() => completed++)
            .Bind(SetAlpha)
            .AddTo(rect);

        // スケールアニメーション
        LMotion.Create(config.FadeInStartScale, 1f, config.FadeInDuration)
            .WithEase(config.FadeInEase)
            .WithOnComplete(() => completed++)
            .Bind(s => rect.localScale = originalScale * s)
            .AddTo(rect);

        await UniTask.WaitUntil(() => completed >= 2, cancellationToken: ct);
        isFadingIn = false;
    }

    /// <summary>
    /// フェードアウト: 真上へ移動しながらフェードアウト
    /// </summary>
    public async UniTask FadeOutAsync(CancellationToken ct = default)
    {
        // フェードイン中なら完了を待つ
        if (isFadingIn)
        {
            await UniTask.WaitUntil(() => !isFadingIn, cancellationToken: ct);
        }

        var startPos = rect.anchoredPosition;
        var endPos = startPos + new Vector2(0, config.FadeOutUpDistance);
        var completed = 0;

        // 位置アニメーション（真上へ）
        LMotion.Create(startPos, endPos, config.FadeOutDuration)
            .WithEase(config.FadeOutEase)
            .WithOnComplete(() => completed++)
            .BindToAnchoredPosition(rect)
            .AddTo(rect);

        // 透明度アニメーション
        LMotion.Create(1f, 0f, config.FadeOutDuration)
            .WithEase(config.FadeOutEase)
            .WithOnComplete(() => completed++)
            .Bind(SetAlpha)
            .AddTo(rect);

        await UniTask.WaitUntil(() => completed >= 2, cancellationToken: ct);

        // 位置を元に戻す（次回表示用）
        rect.anchoredPosition = originalPosition;
    }

    /// <summary>
    /// 即座に非表示（アニメーションなし）
    /// </summary>
    public void HideImmediate()
    {
        SetAlpha(0f);
        rect.localScale = originalScale;
        rect.anchoredPosition = originalPosition;
    }

    private void SetAlpha(float alpha)
    {
        if (image == null) return;
        var c = image.color;
        c.a = alpha;
        image.color = c;
    }
}
```

### 視覚的イメージ

```
【フェードイン】
    ○ スケール0.8 + 透明
    ↓ (徐々に大きく＋不透明に、OutBackでポップに)
    ● スケール1.0 + 不透明

【フェードアウト】
    ● 定位置
    ↑ (上に移動しながらフェードアウト、InQuadで加速)
    ○ (透明になりながら上へ)
    × 消滅（非表示）
```

### CentralObjectPresenter への統合

```csharp
// CentralObjectPresenter.cs に追加
private CentralObjectAnimator animator;
private CentralAnimConfig animConfig = CentralAnimConfig.Default;

public void SetAnimConfig(CentralAnimConfig config)
{
    animConfig = config;
}

public async UniTask ShowAsync(CentralObjectVisual visual, bool forceShow)
{
    if (!forceShow)
    {
        await HideAsync();
        return;
    }

    // 既存のShow処理...
    EnsureViewObject();
    // sprite, size, offset, tint設定...

    viewObject.SetActive(true);

    // アニメーター初期化
    animator ??= new CentralObjectAnimator(image, rectTransform, animConfig);
    await animator.FadeInAsync();
}

public async UniTask HideAsync()
{
    if (viewObject == null || !viewObject.activeSelf) return;

    if (animator != null)
    {
        await animator.FadeOutAsync();
    }

    viewObject.SetActive(false);
}

// 即座に非表示（ゲート/出口切替時など）
public void Hide()
{
    animator?.HideImmediate();
    if (viewObject != null)
    {
        viewObject.SetActive(false);
    }
}
```

---

## 状態管理

### CentralObjectState（新規）

```csharp
[Serializable]
public sealed class CentralObjectState
{
    public List<string> VarietyHistory;
    public Dictionary<string, int> Cooldowns;

    // コンストラクタ、Import/Export省略
}
```

### GameContext への追加

```csharp
// GameContext.cs に追加
public CentralObjectSelector CentralObjectSelector { get; } = new CentralObjectSelector();
```

### WalkProgressData への追加

```csharp
// 保存/復元対象に追加
public CentralObjectState CentralObjectState { get; set; }
```

---

## 実装フェーズ

### Phase 1: データ構造

- [ ] CentralObjectSO 作成
- [ ] CentralObjectEntry 作成（CentralObjectTableSO.cs 内に定義）
- [ ] CentralObjectTableSO 作成
- [ ] NodeSO 変更（centralEvent/centralVisual → centralObjectTable/fixedCentralObject）

### Phase 2: 抽選ロジック

- [ ] CentralObjectCooldownTracker 作成（SideObjectCooldownTracker を参考）
- [ ] CentralObjectSelector 作成
- [ ] CentralObjectState 作成

### Phase 3: アニメーション

- [ ] CentralAnimConfig 構造体作成
- [ ] CentralObjectAnimator クラス作成
- [ ] CentralObjectPresenter に ShowAsync/HideAsync 追加
- [ ] CentralObjectPresenter に Animator 統合

### Phase 4: AreaController 統合

- [ ] AreaController に centralObjectSelector 追加
- [ ] WalkStep() で中央オブジェクト抽選処理追加
- [ ] ShowApproachObjects() を ShowApproachObjectsAsync() に変更
- [ ] HandleApproachSelection() 変更
- [ ] Show/Hide 呼び出しを Async 版に置換

### Phase 5: 状態保存/復元

- [ ] WalkProgressData に CentralObjectState 追加
- [ ] GameContext に CentralObjectSelector 追加
- [ ] 保存/復元処理追加

### Phase 6: 既存データ移行

- [ ] 既存 NodeSO の centralEvent/centralVisual を CentralObjectSO に変換
- [ ] 既存データの CentralObjectTableSO 作成

---

## 移行時の注意

### 後方互換性

既存の NodeSO.centralEvent/centralVisual を使用しているデータがある場合:
1. 移行スクリプトで CentralObjectSO に変換
2. CentralObjectTableSO を作成し、単一エントリとして登録
3. NodeSO に設定

### テスト項目

- [ ] 中央オブジェクトが抽選で出現すること
- [ ] 条件付き中央オブジェクトが正しくフィルタリングされること
- [ ] クールダウンが機能すること
- [ ] バラエティバイアスが機能すること
- [ ] ノード入場時の固定中央オブジェクトが機能すること
- [ ] アプローチ→イベント実行→ズームの一連の流れが動作すること
- [ ] 状態の保存/復元が正しく動作すること
- [ ] フェードインアニメーションが正しく再生されること
- [ ] フェードアウト（真上へ捌ける）アニメーションが正しく再生されること
- [ ] ゲート/出口表示時の即座切替（アニメーションなし）が動作すること

---

## 関連ドキュメント

- [ゼロトタイプ歩行システム設計書.md](./ゼロトタイプ歩行システム設計書.md) - 歩行システム全体設計
- [3者会話構図設計.md](../ノベルパート/3者会話構図設計.md) - ノベルパート中のスプライト変更
- [ノベルパート設計.md](../ノベルパート/ノベルパート設計.md) - ノベルパート全体設計

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-30 | 初版作成 |
| 2026-01-30 | アニメーションセクション追加（LitMotion使用、フェードイン/フェードアウト） |
