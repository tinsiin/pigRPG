ゼロトタイプ歩行システム設計書

目的
- 歩行・分岐・遭遇・イベント門・サイドオブジェクトを1つの設計に統合し、現段階で実装可能な最小コアと拡張点を明文化する。
- 既存BattleManager/WatchUIUpdateと共存しつつ、将来の拡張を阻害しない構造を維持する。

スコープ
- 歩行の進行制御、分岐、遭遇、サイドオブジェクト、イベント門、イベント統一実行基盤（Event Kernel）。
- 戦闘UIや戦闘ロジックの詳細は非スコープ（既存BattleManagerに委譲）。

前提（運用ルール）
- 歩行中のイベントはUnityのシーン分割を行わず、同一シーン内のUI/アニメーションで実行する。
- サイドオブジェクトは一本道の「寄るだけのイベント装置」として扱う。
- 自動戦闘は前提にしない（敵AIはBattleAIBrain等で処理）。

用語整理
- ノード: 歩行の1サイクル単位で処理される場面。
- エッジ: ノード間の遷移。
- ステージ: 運用上のまとまり。基本は「1ノード=1ステージ」運用で開始し、必要なら複数ノードで1ステージを構成する。
- サイドオブジェクト: 寄り道イベント。イベント本体を宿す容器。
- イベント門: 中央に出現するゲート。固定位置で発生し、通過条件を持つ。

コア構造
- FlowGraph: Node/Edgeで進行を表現する。
- GameState: フラグ/タグ/カウンタ/乱数シード/進捗などの状態。
- DSL: Condition/Effectで条件判定と副作用を定義。
- Event Kernel: EventDefinition/EventHost/EventRunnerでイベント実行を統一する。

視覚オブジェクト/Presenter層
- 見た目はPresenterに分離し、ロジックはEvent Kernelに統一する。
- Presenterは「生成/表示/アニメ/破棄」だけを担当し、状態変更はEffect経由で行う。
- サイドオブジェクトPresenter
  - 左右ペアのPrefabを表示する。既存のLine描画（UILineRenderer）やSideObjectMoveのアニメを利用してよい。
  - エディタ拡張（位置/スケール/回転の記録）を使って見た目調整を行う。
- 中央オブジェクトPresenter
  - 画像ベース（Sprite/UI Image）を基本とし、サイドのプログラム描画とは別系統で扱う。
  - 門/独立会話/中央イベントは同じPresenterで表示し、EventHost経由でイベントを起動する。
- 共通方針
  - ロジックは共通、見た目は別（中央は中央専用UI、サイドは左右UI）。
  - 中央オブジェクトをサイドの描画方式に寄せる必要はない。

中央オブジェクトPresenter仕様（具体）
- 目的: 門/独立会話/中央イベントを画像で表示し、Event Kernelの起動口を統一する。
- Prefab構成（例）
  - CentralObjectPresenter（RectTransform）
    - Image（本体Sprite）
    - BackImage（門/出口の背面Sprite）
    - TMP_Text（任意のラベル）
    - Button/Collider（クリック判定）
    - CanvasGroup（フェード/ブロック制御）
- 表示データ（CentralObjectVisual）
  - sprite, size, anchor, offset, tint, label
  - backSprite, backTint, backOffset
  - appearAnim, hideAnim, sfx（任意）
- 表示モード
  - HardBlock: 歩行入力/サイド更新/遭遇を停止し中央イベントに専念。
  - SoftBlock: 表示のみ。歩行は続行可能。
  - AutoTrigger: 表示と同時にEventHost.Triggerを実行（クリック不要）。
- フロー
  1) 門チェック or 独立会話トリガが成立
  2) CentralObjectPresenter.Show(visual, mode)
  3) クリックまたはAutoTriggerでEventHost.Trigger
  4) Effect適用後にHide
- 既存UIとの接続
  - MessageDropper/CreateAreaButtonを使う場合は中央表示を維持し、選択完了でHideする。
  - WatchUIUpdateに中央Presenterの親Rectを持たせ、同一シーン内で制御する。
- 描画順の方針
  - BackImage（門/出口）→ CentralObject（前面）の順に重ねる。
  - サイドオブジェクトとは独立したレイヤで描画する。

Unityでの作業フロー（運用ガイド）
- 目的: 「どのノードにどのイベントを入れるか」をUnity上で具体的に操作できる状態にする。
- 作成するSO一覧（プロジェクト内で資産化する単位）
  - FlowGraphSO: ノードとエッジの一覧（進行の全体像）。
  - NodeSO: ノード単位の設定（sideObjects/encounters/gates/exits）。
  - SideObjectTableSO / SideObjectSO: サイドオブジェクトの候補と個別定義。
  - EncounterTableSO / EncounterSO: 遭遇候補と個別定義（戦闘/会話/取引）。
  - EventDefinitionSO: イベント本体（EventStepの並びとEffects）。
  - DialogueDefinitionSO: 独立会話やイベント内会話の定義。
- 配置の流れ（最短）
  1) EventDefinitionSOを作成（例: 戦闘起動/推理/会話）。
  2) SideObjectSOまたはEncounterSOからEmitEvent/Effectで参照する。
  3) SideObjectTableSO/EncounterTableSOにエントリを追加する。
  4) NodeSOにsideObjects/encounters/gates/exitsを設定する。
  5) FlowGraphSOでNode/Edgeを繋げる（Choice/Conditional/Weightedなど）。
     歩行フローの遷移は出口候補（ExitCandidate）で制御し、Auto遷移は使わない。
- 既存Manager連携（例）
  - BattleManager起動: EncounterSOのresolverやEventStepでLaunchBattleEffectを呼ぶ。
  - 独立会話: DialogueDefinitionSOをConversationRunnerで起動し、終端Effectを適用。
  - 中央イベント: GateMarker/独立会話のトリガでCentralObjectPresenterを表示し、EventHost.Triggerで実行。
- エディタ拡張の想定
  - まずはInspectorで配列編集（NodeSO/FlowGraphSO）。
  - 後からGraphViewでノード/エッジ/門位置を可視化する。
  - SimRunner/Validatorで抽選結果・条件の検証を行う。
- 注意点
  - 旧StageData/StageCutからの移行はNodeSOへの変換スクリプトで行う。
  - UIの見た目はPresenter層で統一し、ロジックはEvent Kernel側で固定する。

歩行サイクル（1歩の更新順序）
1) サイドオブジェクト更新（左右ペアの見た目更新）
2) 中央オブジェクト更新（門/出口の出現判定と背面描画）
3) 遭遇判定（BattleManager起動の有無を決定）
4) 遭遇が発生した場合は戦闘へ移行し、復帰後に同じサイド/中央へアプローチ選択（再抽選しない）
5) 進捗更新と次歩行へ

サイドオブジェクト仕様
- 歩数に依存せず、毎歩ランダム抽選で更新する。
- 左右ペア提示を基本とし、どちらか一方のみ選択可能。選ばれなかった側は次の歩行で更新。
- fixedOnEnter指定は固定提示可。繰り返し抑止はvarietyBias/cooldownで管理。
- サイドオブジェクトはイベントを起動する容器であり、Event Kernelを通じて実行する。
- 表示は左右Prefabを前提とし、SideObjectMove/UILineRendererによるアニメと相性が良い。
- アプローチ（選択）は遭遇判定の後に可能になる。
- 遭遇が発生した歩は、戦闘後に同じサイド/中央へアプローチできる（再抽選しない）。
- 逃走/敗北で巻き戻しが発生した場合は、歩数なしリフレッシュでサイド/中央を再抽選する。
- 将来的に「安息地帯」イベントは片側のみ固定提示できる（例: 右だけ病院固定、反対側は通常抽選）。

遭遇仕様
- メモリレス判定（1歩ごとにbaseRate×倍率でロール）。
- Overlayやエリア倍率で遭遇率を補正。
- cooldown/grace/pityで体感のムラを抑制。

逃走/敗北時の巻き戻し（設計枠）
- 逃走/敗北時は歩行システムの進捗を巻き戻すためのフックを用意する。
- 仮実装としては「10歩巻き戻し」を既定とする。
- トリガはEncounterのOutcomeHook（Lose）またはEventStepからRewindToAnchor/JumpToAnchorを実行する。
- 巻き戻し対象は歩数/内部進捗/門の解除状態/出口出現判定など歩行系の進捗を含む。
- 巻き戻し先はAnchor（nodeId/anchorId）で指定し、PositionOnly/PositionAndStateを切り替え可能にする。
- 巻き戻し直後に「歩数を進めない歩行リフレッシュ」を1回挟める（サイド/中央の再抽選のみ、遭遇ロールはスキップ）。
- 詳細（復元対象キーや門/出口の扱い）は実装開始時に確定する。

イベント門仕様
- 門は中央に出現し、内部進捗（TrackConfig）による固定位置で発生する。
- 複数門を1ノード内に設置可能。優先度で解決順を制御する。
- 門はイベントの一種であり、Event Kernelで同一形式により実行可能。
- 門や独立会話は中央オブジェクトPresenterで表示し、画像ベースの表現を採用する。
- 門は「段階的に解除される」仕様をサポートする。
  - 例: Gate01→Gate02→Gate03→Gate04の順に解除。
  - 解除条件はフラグ/カウンタ/条件式で表現し、次の門は前門の解除後のみ有効。
- ループ歩数とリセット挙動を明文化する。
  - Gateごとに「出現までの歩数（position）」を持つ。
  - プレイヤーが門をスルーする/失敗する/歩行を継続する場合、該当Gateの進捗は0に戻る。
  - 例: position=20なら、20歩ごとに門アプローチが発生するループ。
- Gateを全て解除したとき、出口条件を満たしていれば出口が開く。

出口仕様
- 歩行による遷移は必ず出口アプローチを経由する（Auto遷移は歩行フローでは使用しない）。
- 出口候補が1つのみでも、出口オブジェクトのアプローチ後に選択UIを必ず表示する（分岐の有無に関わらず体験を統一）。
- 門が存在しないノードでは、出口は歩数または確率で出現する。
  - 歩数: 指定歩数到達で出口出現。スルーされた場合は歩数カウンタをリセットし、再度ループ。
  - 確率: 歩行ごとにロールし、成立した歩で出口出現。スルーされた場合は次の歩で再ロール。
- 門が存在するノードでは、全門解除後にのみ出口が出現する。
- 出口は中央オブジェクトの背面に描画され、アプローチ時に次エリア選択UIを開く。
- 出口/門のBackObjectは中央オブジェクトと同様、画像（Sprite/UI Image）で扱う。
- 出口の選択肢はフラグ条件で一択または複数を制御できる。

分岐仕様
- 分岐はExitCandidateとEdgeで表現する。歩行の遷移は必ず出口アプローチで決定する。
- EdgeのAuto遷移は歩行フローでは使用しない（イベントのJump/強制遷移は例外）。
- 既存ステージデータの「エリア分岐」は、Node/Edgeに変換して扱う。

データ構造（概略）
- Node
  - nodeId, tags, onEnter/onExit
  - sideObjects, encounters
  - trackConfig (length, stepDelta, progressKey)
  - gates: GateMarker[]
  - exitSpawn: ExitSpawnRule
  - exits: ExitCandidate[]
- GateMarker
  - gateId, order, positionSpec
  - passConditions, onPass, onFail
  - blockingMode (Hard/Soft)
  - repeatable, cooldown
  - resetOnSkip (trueで門スルー時に進捗リセット)

統合ポイント
- BattleManager: 既存の戦闘処理をそのまま起動する（IBattleRunner経由）。
- WatchUIUpdate/MessageDropper/CreateAreaButton: 既存UIを流用する。
- Unityシーンは分割せず、イベントは同一シーン内のUI/演出として実装する。

既存実装との整合・移行メモ
- 目的: 旧ステージ設計とNowProgress依存をノード/出口前提に置き換えるための整理。
- 旧ステージ→ノード移行（計画）
  - StageData/StageCut/AreaDates: 1 AreaDate = 1 NodeSOで直列化。分岐はExitCandidate/Edgeに変換する。
  - NextID/NextStageID/選択肢: ExitCandidate（toNodeId/uiLabel/conditions）へ移行する。
  - EncounterRate/EscapeRate: EncounterTableSO.baseRate/EncounterSO側の設定へ移行する。
  - _sideObject_Lefts/_sideObject_Rights: SideObjectTableSO.entriesへ移行する（weight/conditions付与）。
  - StageThemeColorUI/MapLine: NodeのuiHints/Presenter設定へ移行する。
  - StageID/AreaID/NowProgress: nodeId + trackProgress + walkCountersに置換する。
- 合わない要素（要調整）
  - NowProgressを「移動距離」として使う処理（再遭遇/復活歩数）が、ノード遷移/巻き戻しと衝突する。
  - 再遭遇コールバックが「前回遭遇との差分=距離」をNowProgressで計算しており、ノード切替や巻き戻しで距離が壊れる。
  - 敵の復活歩数（RecovelySteps）がNowProgress差分に依存しており、巻き戻し時に早期復活/遅延復活が起きうる。
  - NowProgressをAreaDatesのインデックスに使う線形前提（一本道）が、分岐グラフと整合しない。
  - NowProgress前提の線形マップUIが、分岐グラフと整合しない。
  - EncounterRate/EscapeRateがStageDataに結び付いており、ノード単位のEncounterTableへ移し替えが必要。
  - 歩行効果（パッシブ減衰/回復/属性ポイント減衰）が歩数カウンタと直結しており、巻き戻し後の「歩数なしリフレッシュ」と混線する。
  - 歩行効果が「歩数=進捗」と結び付いているため、歩数なしリフレッシュの挙動を分離する必要がある。
- 対応方針（設計）
  - WalkCountersを新設（globalSteps/nodeSteps/trackProgress）し、用途ごとに参照を分ける。
  - 再遭遇/復活はglobalStepsまたはnodeStepsで判定し、巻き戻し時の戻し方を仕様で決める。
  - 再遭遇/復活は「前回遭遇時のglobalSteps」を持たせ、巻き戻しの影響を受けない方式も選択肢にする。
  - 歩数なしリフレッシュ用に「視覚更新のみ」の更新パスを用意し、歩数カウンタや歩行効果を通さない。
  - UIはノード内進捗バー/門位置表示に切り替え、線形マップ依存を廃止する。
  - BattleManager自体は独立して呼び出せるため、歩行側のEncounterResolverから起動する。

保存・再現性
- 進捗（trackProgress/stepCount）、門の解除状態、cooldown、variety履歴、乱数シードを保存対象とする。
- デバッグ用途でロールログ（候補/除外理由/重み/結果）を保持する。

実装フェーズ（最短）
- Phase 0: FlowGraph/AreaController/WalkStateで歩行ループを稼働。
- Phase 1: Event Kernelでイベント実行を統一。
- Phase 2: TrackConfig + GateMarkerで固定門/順次解除/ループ歩数を実装。

備考
- 本書は「現段階の最新設計の単一ソース」とする。他ドキュメントは参照用に留め、仕様の更新は本書を優先する。
