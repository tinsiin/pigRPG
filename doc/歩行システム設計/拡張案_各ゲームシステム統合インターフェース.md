# 拡張案：各ゲームシステム統合のためのインターフェース

> **目的**: 推理システム、戦闘システム、ミニゲーム等、将来実装する各ゲームシステムを拡張歩行システムに接続するためのインターフェース設計

---

## 1. 基本方針

### アダプターとしての拡張歩行システム

```
拡張歩行システム（基盤・アダプター）
    ↓ 接続
推理システム、戦闘システム、ミニゲーム、ノベルパート、戦略パート、etc...

接続方法: EffectSOの拡張
```

**設計原則**:
- ✅ 疎結合: 各システムは独立して開発可能
- ✅ 拡張性: 新しいシステムを追加しても既存コードを変更しない
- ✅ データ駆動: システム起動をデータで制御

---

## 2. 各システムへのインターフェース定義

### 基本パターン: LaunchXXXEffect

```csharp
// 推理システム起動
public class LaunchInferenceEffect : EffectSO {
    public string caseId;  // 推理事件ID
    
    public override void Execute(GameContext ctx) {
        InferenceSystem.Launch(caseId, ctx);
    }
}

// 戦闘システム起動
public class LaunchBattleEffect : EffectSO {
    public string battleId;  // 戦闘ID
    
    public override void Execute(GameContext ctx) {
        BattleSystem.Launch(battleId, ctx);
    }
}

// ミニゲーム起動
public class LaunchMiniGameEffect : EffectSO {
    public string gameId;  // ミニゲームID
    
    public override void Execute(GameContext ctx) {
        MiniGameSystem.Launch(gameId, ctx);
    }
}

// 戦略パート起動
public class LaunchStrategyEffect : EffectSO {
    public string strategyId;  // 戦略パートID
    
    public override void Execute(GameContext ctx) {
        StrategySystem.Launch(strategyId, ctx);
    }
}
```

**使用例**:
```csharp
// サイドオブジェクト定義
sideObject_inference_case: {
    id: "推理事件",
    resolver: {
        entries: [
            {
                dialogue: "事件現場に到着した",
                effects: [LaunchInference("murder_case_01")]  // ← 推理システム起動
            }
        ]
    }
}
```

---

## 3. 各システムからの結果受け取り

### 基本パターン: Result列挙型 + 結果分岐

```csharp
// 推理システムの結果
public enum InferenceResult {
    Success,   // 完全成功
    Failure,   // 失敗
    Partial    // 部分的成功
}

// 戦闘システムの結果
public enum BattleResult {
    Victory,
    Defeat,
    Escape
}

// ミニゲームの結果
public enum MiniGameResult {
    Success,
    Failure,
    TimeOut
}
```

### 結果に応じた分岐

```csharp
// サイドオブジェクト定義（結果分岐版）
sideObject_inference_with_result: {
    id: "推理事件",
    resolver: {
        effects: [LaunchInference("murder_case_01")]
    },
    
    // 結果に応じた分岐
    onInferenceResult: {
        Success: [
            SetFlag("case_solved"),
            AddItem("evidence"),
            AddPassive("推理力+1")
        ],
        Failure: [
            SetFlag("case_failed"),
            DamageHP(10),
            SetFlag("犯人逃亡")
        ],
        Partial: [
            SetFlag("case_partial"),
            AddItem("部分的証拠")
        ]
    }
}
```

### 実装方法（ランタイム）

```csharp
// システム起動と結果待機
public async UniTask ExecuteSideObject(SideObjectDefinitionSO definition, GameContext ctx) {
    // 通常の効果実行
    foreach (var effect in definition.resolver.effects) {
        effect.Execute(ctx);
    }
    
    // 特殊システムの結果待機
    if (definition.onInferenceResult != null) {
        var result = await InferenceSystem.WaitForResult();
        var effects = definition.onInferenceResult[result];
        foreach (var effect in effects) {
            effect.Execute(ctx);
        }
    }
    
    if (definition.onBattleResult != null) {
        var result = await BattleSystem.WaitForResult();
        var effects = definition.onBattleResult[result];
        foreach (var effect in effects) {
            effect.Execute(ctx);
        }
    }
}
```

---

## 4. コンテキストの受け渡し

### GameContext構造

```csharp
public class GameContext {
    // 歩行システムの状態
    public WalkState Walk;
    
    // プレイヤーの状態
    public PlayerState Player;
    
    // 世界の状態
    public WorldState World;
    
    // フラグの状態
    public FlagState Flags;
    
    // パッシブの状態
    public PassiveState Passives;
    
    // 各システムが情報を取得・書き込み
}

public class WalkState {
    public int stepCountInArea;
    public int trackProgress;
    public string currentNodeId;
}

public class PlayerState {
    public int hp;
    public int level;
    public List<string> items;
    public List<string> passives;
}

public class FlagState {
    private Dictionary<string, bool> flags;
    
    public bool HasFlag(string flagId);
    public void SetFlag(string flagId);
    public void UnsetFlag(string flagId);
}
```

### 各システムからのアクセス

```csharp
// 推理システム側
public class InferenceSystem {
    public static async UniTask<InferenceResult> Launch(string caseId, GameContext ctx) {
        // コンテキストから情報取得
        var hasClue = ctx.Flags.HasFlag("重要な手がかり入手");
        var hasPassive = ctx.Player.passives.Contains("推理力");
        
        // 推理ゲームを実行
        var result = await RunInferenceGame(caseId, hasClue, hasPassive);
        
        // コンテキストに結果を書き込み（オプション）
        if (result == InferenceResult.Success) {
            ctx.Flags.SetFlag($"{caseId}_solved");
        }
        
        return result;
    }
}
```

---

## 5. マルチストーリー対応

### ストーリー分岐による異なるゲームシステムの使用

```csharp
// A√: 推理メイン
route_a_node: {
    sideObjects: {
        entries: [
            { definition: "推理事件1", weight: 30 },
            { definition: "推理事件2", weight: 30 },
            { definition: "戦闘", weight: 10 }  // 少ない
        ]
    }
}

// B√: 戦闘メイン
route_b_node: {
    sideObjects: {
        entries: [
            { definition: "戦闘1", weight: 30 },
            { definition: "戦闘2", weight: 30 },
            { definition: "推理事件", weight: 10 }  // 少ない
        ]
    }
}

// C√: 潜入メイン
route_c_node: {
    sideObjects: {
        entries: [
            { definition: "ハッキングミニゲーム", weight: 30 },
            { definition: "ステルスミニゲーム", weight: 30 },
            { definition: "戦闘", weight: 10 }  // 少ない
        ]
    }
}
```

**重要**: ✅ 同じ基盤で、異なるゲーム体験を提供可能

---

## 6. 実装の優先順位

### Phase 1: 基盤（拡張歩行システム）
- [x] NodeSO、EdgeSO、ConditionSO、EffectSO
- [x] SideObjectTableSO、EncounterTableSO
- [x] AmbientTalkTrigger、TrackConfig
- [ ] LaunchXXXEffectの基底クラス
- [ ] GameContext構造

### Phase 2: 最初のゲームシステム（推理 or 戦闘）
- [ ] 推理システムの基本実装
- [ ] LaunchInferenceEffect実装
- [ ] InferenceResult分岐の実装
- [ ] 1つのサンプルケース

### Phase 3: 2つ目のゲームシステム
- [ ] 戦闘システムの基本実装
- [ ] LaunchBattleEffect実装
- [ ] BattleResult分岐の実装

### Phase 4以降: その他のシステム
- [ ] ミニゲーム
- [ ] 戦略パート
- [ ] 企業潜入パート
- [ ] Axiom論理ゲーム
- [ ] etc...

---

## 7. 重要な設計原則

### ✅ 各システムは独立して開発

```
推理システム開発中でも、戦闘システムは影響を受けない
新しいミニゲーム追加でも、既存システムは変更不要
```

### ✅ データで制御

```
プログラムコード変更なしで、新しいイベント追加可能
ScriptableObjectで各システムの起動を制御
```

### ✅ 段階的実装

```
Phase 1: 基盤だけ
Phase 2: 1つのシステム追加
Phase 3: 2つ目のシステム追加
...

各フェーズが独立、いつでも方針変更可能
```

---

## 8. 今後の課題

### 実装が必要なもの

1. **LaunchXXXEffectの基底クラス設計**
   - 共通処理の抽出
   - Result待機の統一インターフェース

2. **GameContext構造の詳細設計**
   - 各システムが必要な情報の洗い出し
   - データの受け渡し方法の確定

3. **Result分岐の実装方法**
   - ScriptableObjectでの定義方法
   - ランタイムでの分岐処理

4. **各ゲームシステムの仕様策定**
   - 推理システムの仕様
   - 戦闘システムの仕様
   - etc...

---

## 9. まとめ

### この拡張案の意義

```
拡張歩行システム = アダプター

どんなゲームシステムも接続可能
→ マルチストーリー対応
→ ゲーム性の変化に対応
→ 段階的実装が可能
```

**結論**: ✅ **この基盤があれば、将来的にどんな複雑なゲームシステムも統合できる**

---

**このドキュメントは、将来の実装のための指針である。各システムの実装時に参照すること。**
