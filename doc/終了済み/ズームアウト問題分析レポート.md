# ズームアウト問題分析レポート

**作成日:** 2026-01-24
**状態:** ✅ 解決済み

---

## 関連ドキュメント

- [UI構造の問題点.md](./UI構造の問題点.md)
- [シングルトン依存解消計画.md](./シングルトン依存解消計画.md)
- [ズーム共通化_実装計画.md](./ズーム共通化_実装計画.md)
- [ズーム仕様書.md](../ズーム仕様書.md)

---

## 問題の概要

シングルトン依存解消（DI化）の過程で、**戦闘終了時のズームアウトが動作しなくなった**。
根本原因を特定し、`IIntroOrchestratorFacade`の導入により解決。

---

## 経緯

### 1. 元のコード（動作していた）

```csharp
// BattleUIBridge.cs
public UniTask RestoreZoomViaOrchestrator(bool animated, float duration)
{
    var ui = WatchUIUpdate.Instance;  // シングルトン直接参照
    if (ui == null) return UniTask.CompletedTask;
    return ui.RestoreZoomViaOrchestrator(animated: animated, duration: duration);
}
```

### 2. DI化の試み（失敗）

`IZoomController`をDI注入するように変更したが、`IZoomController`は単純なズーム操作用インターフェースであり、`IIntroOrchestrator`が行う複雑なズーム復帰ロジック（`IntroContext`を使ったコンテナのスケール・位置復帰）を代替できなかった。

**根本原因:** 「ズーム操作」と「ズーム演出（文脈込み）」は別の責務であり、混同していた。

### 3. 解決策: IIntroOrchestratorFacade の導入

```csharp
// IIntroOrchestratorFacade.cs - 新規作成
public interface IIntroOrchestratorFacade
{
    UniTask PrepareAsync(CancellationToken ct = default);
    UniTask PlayAsync(CancellationToken ct = default);
    UniTask RestoreAsync(bool animated = false, float duration = 0f, CancellationToken ct = default);
}
```

```csharp
// BattleUIBridge.cs - 解決後
private readonly IIntroOrchestratorFacade _introOrchestrator;

public UniTask RestoreZoomViaOrchestrator(bool animated, float duration)
{
    if (_introOrchestrator == null) return UniTask.CompletedTask;
    return _introOrchestrator.RestoreAsync(animated, duration);
}
```

```csharp
// BattleManager.cs - IntroOrchestratorFacadeを注入
uiBridge = new BattleUIBridge(
    ...
    wui?.IntroOrchestrator,  // IIntroOrchestratorFacadeとして渡す
    ...);
```

---

## 解決のポイント

### 責務の分離

| 責務 | インターフェース | 役割 |
|------|-----------------|------|
| ズーム操作 | `IZoomController` | ZoomIn/ZoomOut/SetZoom の低レベル操作 |
| ズーム演出 | `IIntroOrchestratorFacade` | Prepare/Play/Restore の文脈込みライフサイクル管理 |
| ビューポート参照 | `IViewportController` | コンテナへの参照提供 |

### なぜIZoomControllerでは不十分だったか

```
IZoomController（操作層）:
├── ZoomInAsync()      ← 単純なズームイン
├── ZoomOutAsync()     ← 単純なズームアウト
├── CaptureOriginal()  ← 呼び出し側が事前に呼ぶ必要あり
└── RestoreAsync()     ← カーブ等を呼び出し側が渡す必要あり

IIntroOrchestratorFacade（演出層）:
├── PrepareAsync()     ← CaptureOriginal + Context構築を内部で管理
├── PlayAsync()        ← Context込みのズームイン
└── RestoreAsync()     ← Context込みのズームアウト（呼ぶだけでOK）
```

**結論:** バトル終了時のズームアウトには「演出層」が必要だった。

---

## 現在の状態

### 動作状況
- ✅ **完全に解決**: `IIntroOrchestratorFacade` 経由でズームアウトが正常動作

### 汎用アクセス（EyeAreaManager）

`EyeAreaManager`に汎用ラッパーを追加済み。どのシステムからでも同じ入口で呼べる：

```csharp
// バトル/ノベル/歩行 どこからでも同じ
await EyeAreaManager.Instance.PrepareZoomAsync();     // 原状キャプチャ
await EyeAreaManager.Instance.PlayZoomAsync();        // ズームイン
await EyeAreaManager.Instance.RestoreZoomAsync(true, 0.4f);  // ズームアウト
```

### コード構造（解決後）

```
BattleManager
    └── new BattleUIBridge(..., wui?.IntroOrchestrator, ...)
                                  ↓
BattleUIBridge
    └── _introOrchestrator: IIntroOrchestratorFacade
        └── RestoreAsync() → 正しくズームアウト

EyeAreaManager（汎用アクセス）
    └── IntroOrchestrator プロパティ
        └── PrepareAsync/PlayAsync/RestoreAsync
```

---

## 旧問題（解決済み）

以下の問題は `IIntroOrchestratorFacade` 導入により解決：

| 旧問題 | 解決方法 |
|--------|----------|
| IViewportControllerの二重実装 | ズーム演出は別インターフェース（IIntroOrchestratorFacade）に分離 |
| 責務の混乱 | IViewportController = 参照提供、IIntroOrchestratorFacade = 演出管理 |
| ViewportControllerの不完全な実装 | ViewportControllerにはRestoreZoomViaOrchestratorは不要 |

---

## 結論

**✅ 設計上の問題も含めて解決済み。**

- `IIntroOrchestratorFacade` で「ズーム操作」と「ズーム演出」を適切に分離
- DI注入パターンが正しく機能
- 汎用ラッパー（EyeAreaManager）で他システムからも利用可能

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-24 | 初版作成（問題分析、暫定解決） |
| 2026-01-24 | **解決済みに更新**。IIntroOrchestratorFacade導入による根本解決を反映 |
