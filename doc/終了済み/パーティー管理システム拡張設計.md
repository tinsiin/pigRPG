# パーティー管理システム拡張設計

パーティーメンバーの離脱・入れ替え・新キャラ追加を可能にするための設計ドキュメント。

> **ステータス**: 方針C確定、実装準備完了
> - 現状分析完了
> - **方針C（全キャラ管理 + 編成分離）採用決定**
> - 影響調査完了
> - 実装タスク定義済み

## 採用方針

**方針C: 全キャラ管理 + 編成分離**

- `AllyId` enum → `CharacterId` struct に置き換え
- 固定配列 → Dictionary による可変管理
- 派生クラス（StairStates等）廃止 → AllyClass に統一
- 新キャラ追加がコード変更なしで可能に

## 関連ドキュメント

- [ノベルパートと精神属性の連携](./ノベルパート/ノベルパートと精神属性の連携.md)
- [PlayersStates_Global_Dependency_Refactor](./PlayersStates_Global_Dependency_Refactor.md)

---

## 1. 現状分析

### 1.1. 現在のパーティー構成（固定3人）

```csharp
// AllyId.cs
public enum AllyId
{
    Geino = 0,
    Noramlia = 1,
    Sites = 2
}

public const int AllyCount = 3;  // 常に3人固定
```

**特徴**:
- enumによる固定ID
- 新キャラ追加には再コンパイル必須
- インデックスとIDが1対1対応

### 1.2. パーティー管理階層

```
PlayersRuntime（初期化・所有）
    │
    ├─ Init()
    │   └─ roster.SetAllies([geino, noramlia, sites])  ← 固定配列
    │
    ├─ PlayersRoster（キャラクター配列管理）
    │   ├── Allies: AllyClass[]  ← 長さ3固定
    │   ├── GetAllyById(AllyId) → AllyClass
    │   ├── GetAllyByIndex(int) → BaseStates
    │   └── TryGetAllyId(BaseStates) → AllyId
    │
    ├─ PartyBuilder（戦闘用グループ構築）
    │   ├── Geino, Noramlia, Sites をハードコード参照
    │   ├── BuildParty() → BattleGroup
    │   └── GetPartyImpression() → PartyProperty（3人のHP比較）
    │
    └─ PlayersPartyService（外部インターフェース）
        └── GetParty() → BattleGroup
```

### 1.3. キャラクター継承構造

```
BaseStates（基盤クラス）
  │
  ├─ AllyClass（味方共通）
  │   ├─ StairStates（Geino専用）
  │   ├─ BassJackStates（Noramlia専用）
  │   └─ SateliteProcessStates（Sites専用）
  │
  └─ NormalEnemy（敵共通）
```

**問題**: 各キャラクターが専用クラスを持つため、汎用的な追加が困難。

### 1.4. 関連ファイル一覧

| ファイル | 役割 | 影響度 |
|----------|------|--------|
| `AllyId.cs` | キャラクターID定義 | **高** |
| `PlayersRoster.cs` | キャラクター配列管理 | **高** |
| `PartyBuilder.cs` | 戦闘グループ構築 | **高** |
| `PlayersRuntime.cs` | 初期化・統合管理 | **高** |
| `PlayersSaveData.cs` | セーブデータ構造 | **高** |
| `PlayersPartyService.cs` | パーティーサービス | 中 |
| `WalkLoopService.cs` | 歩行時処理 | 中 |
| `PlayersBattleCallbacks.cs` | 戦闘コールバック | 中 |
| `PlayersUIService.cs` | UI管理 | 中 |
| `NovelDialogueStep.cs` | ノベルパート主人公選択 | 低 |

---

## 2. 拡張要件

### 2.1. 必須要件（方針C で対応）

| 要件 | 説明 | 対応方法 |
|------|------|----------|
| パーティー離脱 | ストーリー進行でキャラがパーティーから外れる | IPartyComposition.RemoveMember() |
| パーティー復帰 | 離脱したキャラが再度パーティーに戻る | IPartyComposition.AddMember() |
| **新キャラ追加** | ゲーム進行で新しい仲間が加入 | CharacterId + Roster 登録 |
| パーティー人数可変 | **1〜3人**の可変パーティー | PartyComposition.MaxMembers = 3 |
| 控えメンバー | 戦闘に参加しないが所持はしているメンバー | Roster にいるが Composition にいない |

### 2.2. 将来要件（検討中）

| 要件 | 説明 |
|------|------|
| 編成画面 | プレイヤーがパーティーを自由に編成 |
| ゲストキャラ | 一時的に加入するNPC（操作不可） |

---

## 3. 設計方針

### 3.1. 方針A: 最小変更（離脱フラグ追加）

**概要**: 既存の3人固定構造を維持し、「離脱中」フラグを追加

```csharp
// AllyClass に追加
public bool IsInParty { get; set; } = true;

// PartyBuilder.BuildParty() を修正
var playerGroup = roster.Allies
    .Where(a => a != null && a.IsInParty)
    .ToList();
```

**メリット**:
- 影響範囲が小さい
- 既存コードの大部分がそのまま使える
- AllyId は変更不要

**デメリット**:
- 新キャラ追加には対応不可
- 4人以上のパーティーは不可
- 根本的な構造問題は残る

**影響ファイル**:
- `AllyClass.cs`: フラグ追加
- `PartyBuilder.cs`: フィルタリング追加
- `PlayersSaveData.cs`: フラグ保存

---

### 3.2. 方針B: スロット制（固定枠 + 可変参加）

**概要**: パーティースロット（最大4枠）を設け、キャラを配置

```csharp
// 新規: PartySlot.cs
public sealed class PartySlot
{
    public int SlotIndex { get; }
    public AllyClass Member { get; set; }  // null = 空席
    public bool IsLocked { get; set; }     // ストーリーでロック
}

// 新規: PartyFormation.cs
public sealed class PartyFormation
{
    public const int MaxSlots = 4;
    private readonly PartySlot[] slots = new PartySlot[MaxSlots];

    public IReadOnlyList<AllyClass> ActiveMembers =>
        slots.Where(s => s.Member != null).Select(s => s.Member).ToList();

    public void SetMember(int slotIndex, AllyClass member) { ... }
    public void RemoveMember(int slotIndex) { ... }
    public void SwapSlots(int a, int b) { ... }
}
```

**メリット**:
- パーティー人数が可変（1〜4人）
- 空席の概念がある
- 将来の編成画面に対応しやすい

**デメリット**:
- 中程度の変更量
- Roster と Formation の役割分担が必要
- 既存の AllyId 依存コードの修正が必要

**影響ファイル**:
- 新規: `PartySlot.cs`, `PartyFormation.cs`
- `PlayersRoster.cs`: 全キャラ保持に変更
- `PartyBuilder.cs`: Formation から構築
- `PlayersRuntime.cs`: Formation 初期化追加
- `PlayersSaveData.cs`: スロット情報追加

---

### 3.3. 方針C: 全キャラ管理 + 編成分離

**概要**: 全キャラクターを一元管理し、パーティー編成を別システムに

```csharp
// 新規: CharacterRegistry.cs（全キャラ管理）
public sealed class CharacterRegistry
{
    private readonly Dictionary<CharacterId, AllyClass> characters = new();

    public void Register(CharacterId id, AllyClass character) { ... }
    public AllyClass Get(CharacterId id) { ... }
    public bool IsUnlocked(CharacterId id) { ... }
}

// 新規: CharacterId.cs（拡張可能なID）
public readonly struct CharacterId : IEquatable<CharacterId>
{
    public string Value { get; }

    // 定義済みID
    public static readonly CharacterId Geino = new("geino");
    public static readonly CharacterId Noramlia = new("noramlia");
    public static readonly CharacterId Sites = new("sites");
}

// 新規: PartyManager.cs（編成管理）
public sealed class PartyManager
{
    private readonly List<CharacterId> activeParty = new();

    public void AddToParty(CharacterId id) { ... }
    public void RemoveFromParty(CharacterId id) { ... }
    public IReadOnlyList<AllyClass> GetActiveMembers() { ... }
}
```

**メリット**:
- 最も柔軟な設計
- 新キャラ追加が容易（SOで定義可能）
- 控えメンバー、ゲストキャラに対応
- ノベルパートのcharacterIdと統一可能

**デメリット**:
- 大規模な変更が必要
- 既存の AllyId 依存を全て置換
- enum AllyId を struct CharacterId に移行

**影響ファイル**:
- 新規: `CharacterId.cs`, `CharacterRegistry.cs`, `PartyManager.cs`
- `AllyId.cs`: 廃止または互換レイヤー
- `PlayersRoster.cs`: CharacterRegistry に統合
- `PartyBuilder.cs`: PartyManager から構築
- `PlayersRuntime.cs`: 大幅変更
- `PlayersSaveData.cs`: 構造変更
- `NovelDialogueStep.cs`: CharacterId 対応

---

## 4. 方針比較

| 観点 | 方針A（フラグ） | 方針B（スロット） | 方針C（全管理） |
|------|----------------|------------------|----------------|
| 実装コスト | **低** | 中 | 高 |
| 離脱/復帰 | ○ | ○ | ○ |
| 新キャラ追加 | × | △（要enum拡張） | ○ |
| 可変人数 | × | ○ | ○ |
| 編成画面 | × | ○ | ○ |
| 控えメンバー | × | △ | ○ |
| ゲストキャラ | × | △ | ○ |
| 既存互換性 | **高** | 中 | 低 |

---

## 5. 推奨: 段階的移行

### Phase 1: 最小変更（方針A）

**目標**: 離脱・復帰の基本機能を最小コストで実現

1. `AllyClass` に `IsInParty` フラグ追加
2. `PartyBuilder.BuildParty()` でフィルタリング
3. `PlayersSaveData` にフラグ保存
4. ストーリーイベントで離脱/復帰をトリガー

**実装ファイル**:
```
Assets/Script/Players/Runtime/AllyClass.cs  ← フラグ追加
Assets/Script/Players/PartyBuilder.cs       ← フィルタリング
Assets/Script/Players/PlayersSaveData.cs    ← 保存対応
Assets/Script/Players/PlayersSaveService.cs ← 読み書き
```

### Phase 2: スロット制導入（方針B）

**目標**: 可変人数パーティーと編成の基盤

1. `PartyFormation` クラス新規作成
2. `PartyBuilder` を Formation ベースに変更
3. UI: 編成画面の準備

### Phase 3: 全キャラ管理（方針C）

**目標**: 新キャラ追加とゲストシステム

1. `CharacterId` 導入（AllyId からの移行）
2. `CharacterRegistry` でキャラ一元管理
3. ノベルパートの characterId と統一

---

## 6. Phase 1 詳細設計

### 6.1. AllyClass への追加

```csharp
// Assets/Script/Players/Runtime/AllyClass.cs

public abstract partial class AllyClass : BaseStates
{
    /// <summary>
    /// パーティーに参加中かどうか。
    /// falseの場合、戦闘グループに含まれない。
    /// </summary>
    public bool IsInParty { get; private set; } = true;

    /// <summary>
    /// パーティーから離脱する。
    /// </summary>
    public void LeaveParty()
    {
        IsInParty = false;
    }

    /// <summary>
    /// パーティーに復帰する。
    /// </summary>
    public void JoinParty()
    {
        IsInParty = true;
    }
}
```

### 6.2. PartyBuilder の修正

```csharp
// Assets/Script/Players/PartyBuilder.cs

public BattleGroup BuildParty()
{
    // 変更前: var playerGroup = new List<BaseStates> { Geino };
    // 変更後:
    var playerGroup = new List<BaseStates>();

    foreach (var ally in roster.Allies)
    {
        if (ally != null && ally.IsInParty)
        {
            playerGroup.Add(ally);
        }
    }

    // パーティーが空の場合の警告
    if (playerGroup.Count == 0)
    {
        Debug.LogWarning("BuildParty: パーティーメンバーがいません。");
    }

    var nowOurImpression = GetPartyImpression();
    // ... 以下同じ
}

private PartyProperty GetPartyImpression()
{
    // 参加中のメンバーのみでHP比較
    var activeMembers = roster.Allies.Where(a => a != null && a.IsInParty).ToList();

    if (activeMembers.Count < 2)
    {
        return PartyProperty.MelaneGroup;  // デフォルト
    }

    // TODO: 2人以下の場合のロジック
    // 現状は3人前提のロジックを維持
    // ...
}
```

### 6.3. セーブデータ対応

```csharp
// Assets/Script/Players/PlayersSaveData.cs

[System.Serializable]
public class PlayersSaveData
{
    // 既存フィールド...

    /// <summary>
    /// 各キャラクターのパーティー参加状態。
    /// インデックスは AllyId に対応。
    /// </summary>
    public bool[] IsInParty;
}
```

```csharp
// Assets/Script/Players/PlayersSaveService.cs

public PlayersSaveData Build(PlayersRoster roster)
{
    var allies = roster.Allies;
    var data = new PlayersSaveData
    {
        // 既存...
        IsInParty = allies.Select(a => a?.IsInParty ?? false).ToArray()
    };
    return data;
}

public void Apply(PlayersSaveData data, PlayersRoster roster)
{
    var allies = roster.Allies;
    if (data.IsInParty != null)
    {
        for (int i = 0; i < allies.Length && i < data.IsInParty.Length; i++)
        {
            if (allies[i] != null)
            {
                if (data.IsInParty[i])
                    allies[i].JoinParty();
                else
                    allies[i].LeaveParty();
            }
        }
    }
    // 既存...
}
```

### 6.4. ストーリーイベント連携

```csharp
// 新規: Assets/Script/Walk/Effects/PartyMemberEffect.cs

[CreateAssetMenu(menuName = "pigRPG/Effects/PartyMemberEffect")]
public sealed class PartyMemberEffect : EffectSO
{
    public enum Action { Leave, Join }

    [SerializeField] private AllyId target;
    [SerializeField] private Action action;

    public override void Apply(EffectContext context)
    {
        var roster = context.GameContext?.Players?.Roster;
        if (roster == null) return;

        var ally = roster.GetAllyById(target) as AllyClass;
        if (ally == null) return;

        switch (action)
        {
            case Action.Leave:
                ally.LeaveParty();
                break;
            case Action.Join:
                ally.JoinParty();
                break;
        }
    }
}
```

---

## 7. ノベルパートとの連携

### 7.1. 現状の主人公選択

`NovelDialogueStep.cs` では `AllyId` で主人公を選択:

```csharp
[SerializeField] private bool hasProtagonist;
[SerializeField] private AllyId protagonist;

public AllyId? GetProtagonist() => hasProtagonist ? protagonist : null;
```

### 7.2. Phase 1 での影響

- **影響なし**: AllyId は変更しないため
- 離脱中キャラも主人公として選択可能（ノベルパートは戦闘とは独立）

### 7.3. 将来（Phase 3）での変更

```csharp
// CharacterId 導入後
[SerializeField] private bool hasProtagonist;
[SerializeField] private CharacterId protagonist;

public CharacterId? GetProtagonist() => hasProtagonist ? protagonist : null;
```

これにより、ノベルパートの `characterId`（文字列）と統一可能。

---

## 8. 検討事項

### 8.1. 離脱中キャラの扱い

| 状況 | 扱い |
|------|------|
| 戦闘 | 参加しない（BattleGroup に含まれない） |
| 歩行時回復 | 回復しない or する（要検討） |
| セーブ/ロード | 状態保持 |
| ノベルパート | 登場可能（主人公にもなれる） |
| UI表示 | 非表示 or グレーアウト（要検討） |

### 8.2. パーティー0人の場合

- 戦闘開始時にエラー？
- ストーリー上ありえない前提？
- 少なくとも1人は必須？

### 8.3. GetPartyImpression の対応

現状は3人前提のHP比較ロジック。可変人数対応が必要:
- 2人の場合: 2人比較
- 1人の場合: デフォルト値
- 0人の場合: デフォルト値 + 警告

---

## 9. 次のアクション

1. **方針確定**: 方針A（最小変更）から始めるか確認
2. **Phase 1 実装**:
   - [ ] AllyClass に IsInParty 追加
   - [ ] PartyBuilder 修正
   - [ ] PlayersSaveData/Service 対応
   - [ ] PartyMemberEffect 作成（ストーリー連携用）
3. **動作確認**: テストシナリオで離脱/復帰を検証
4. **UI対応**: 離脱中キャラの表示方法を決定

---

## 10. 3人前提ロジック調査結果

### 10.1. 調査概要

プロジェクト全体で「3人前提」のロジックを調査した結果、**広範囲に存在**することが判明。
ただし、**3人以下であれば安全**に動作する設計が多い。

### 10.2. 高影響度の箇所

| ファイル | 行番号 | 内容 | 影響度 |
|----------|--------|------|--------|
| `AllyId.cs` | 1-11 | enum AllyId(Geino=0, Noramlia=1, Sites=2) | **高** |
| `AllyId.cs` | 10 | `const int AllyCount = 3` | **高** |
| `TabContents.cs` | 15-18 | `enum SkillUICharaState { geino, sites, normalia }` | **高** |
| `PlayersRuntime.cs` | 87-92 | `new AllyClass[3]` で固定配列初期化 | **高** |
| `PlayersBootstrapper.cs` | 12-14 | Init_geino, Init_noramlia, Init_sites を明示指定 | **高** |
| `PlayersBootstrapper.cs` | 27-29 | geino/noramlia/sites プロパティで型キャスト | **高** |
| `PlayersUIRefs.cs` | 7 | `new AllyUISet[PlayersConstants.AllyCount]` | **高** |
| `BattleUIBridge.cs` | 154-162 | TryGetAllyId で型判定（3キャラ固定） | **高** |
| `BattleUIBridge.cs` | 172-175 | ToSkillUiState で3人を switch | **高** |
| `CharaconfigController.cs` | 183-186 | AllyId を整数キャスト | **高** |
| `TabCharaStateContent.cs` | 8-40 | 3つのGameObjectを case 分岐 | **高** |
| `PartyBuilder.cs` | 15-17 | Geino/Noramlia/Sites プロパティ | **高** |
| `PartyBuilder.cs` | 63-101 | **GetPartyImpression で3人HP比較** | **高** |

### 10.3. 中〜低影響度の箇所

| ファイル | 行番号 | 内容 | 影響度 |
|----------|--------|------|--------|
| `RestPartyEffect.cs` | 16-19 | AllyCount ループで AllyId キャスト | 中 |
| `CharaconfigController.cs` | 240 | SetCharacterIndex で色分け | 低 |

### 10.4. 結論: 3人以下なら安全

| 観点 | 評価 |
|------|------|
| ループ系 | `AllyCount` でループしているため2人以下でも動作 |
| BattleGroup | 内部は `List<BaseStates>` で可変長対応 |
| UI層 | 3人固定だが離脱中は非表示にすれば問題なし |
| **GetPartyImpression** | **要修正**: 3人のHP直接参照でnullアクセスの恐れ |

### 10.5. 4人以上にする場合の問題

4人以上に拡張する場合、以下の大規模修正が必要:

1. 新キャラ固有クラス作成（例: `NewCharaStates : AllyClass`）
2. `AllyId` enum に追加
3. `SkillUICharaState` enum に追加
4. `BattleUIBridge.TryGetAllyId()` の型判定追加
5. `TabCharaStateContent` に新しいGameObject追加
6. `PlayersUIRefs` の配列拡張
7. `PartyBuilder.GetPartyImpression()` 再設計（6通り→24通り？）
8. `PlayersRuntime` の初期化配列拡張
9. UIプレハブの修正

**結論**: 方針A（離脱フラグ）で3人以下に制限すれば、UI層の変更は不要。

---

## 11. GetPartyImpression 問題詳細

### 11.1. 現状のコード

```csharp
// PartyBuilder.cs:15-17
private StairStates Geino => roster.GetAllyById(AllyId.Geino) as StairStates;
private BassJackStates Noramlia => roster.GetAllyById(AllyId.Noramlia) as BassJackStates;
private SateliteProcessStates Sites => roster.GetAllyById(AllyId.Sites) as SateliteProcessStates;

// PartyBuilder.cs:63-101
private PartyProperty GetPartyImpression()
{
    // 3人のMaxHPで許容誤差を計算
    float toleranceStair = Geino.MaxHP * 0.05f;          // ← null の場合クラッシュ
    float toleranceSateliteProcess = Sites.MaxHP * 0.05f;
    float toleranceBassJack = Noramlia.MaxHP * 0.05f;

    // 3人のHP差が許容範囲内か判定
    if (Mathf.Abs(Geino.HP - Sites.HP) <= toleranceStair &&
        Mathf.Abs(Sites.HP - Noramlia.HP) <= toleranceSateliteProcess &&
        Mathf.Abs(Noramlia.HP - Geino.HP) <= toleranceBassJack)
    {
        return PartyProperty.MelaneGroup;
    }

    // 3人のHP順序で6通り分岐
    if (Geino.HP >= Sites.HP && Sites.HP >= Noramlia.HP)
        return PartyProperty.MelaneGroup;
    else if (Geino.HP >= Noramlia.HP && Noramlia.HP >= Sites.HP)
        return PartyProperty.Odradeks;
    else if (Sites.HP >= Geino.HP && Geino.HP >= Noramlia.HP)
        return PartyProperty.MelaneGroup;
    else if (Sites.HP >= Noramlia.HP && Noramlia.HP >= Geino.HP)
        return PartyProperty.HolyGroup;
    else if (Noramlia.HP >= Geino.HP && Geino.HP >= Sites.HP)
        return PartyProperty.TrashGroup;
    else if (Noramlia.HP >= Sites.HP && Sites.HP >= Geino.HP)
        return PartyProperty.Flowerees;

    return PartyProperty.MelaneGroup;
}
```

### 11.2. 問題点

| 問題 | 説明 |
|------|------|
| **固定キャラ参照** | `Geino`, `Noramlia`, `Sites` を直接プロパティで参照 |
| **nullチェックなし** | 離脱中キャラがいると `NullReferenceException` |
| **3人前提ロジック** | 3人のHP順序で6通り（3! = 6）の PartyProperty を決定 |
| **拡張困難** | 2人の場合は2通り、4人の場合は24通りになる |

### 11.3. PartyProperty の意味

```csharp
// 3人のHP順序で決まる「パーティーの特性」
Geino ≥ Sites ≥ Noramlia  → MelaneGroup
Geino ≥ Noramlia ≥ Sites  → Odradeks
Sites ≥ Geino ≥ Noramlia  → MelaneGroup
Sites ≥ Noramlia ≥ Geino  → HolyGroup
Noramlia ≥ Geino ≥ Sites  → TrashGroup
Noramlia ≥ Sites ≥ Geino  → Flowerees
```

### 11.4. 修正案

#### 案A: 2人以下はデフォルト値

```csharp
private PartyProperty GetPartyImpression()
{
    // 参加中メンバーのみ
    var active = new[] { Geino, Noramlia, Sites }
        .Where(a => a != null && a.IsInParty)
        .ToList();

    // 2人以下はデフォルト
    if (active.Count < 3)
    {
        return PartyProperty.MelaneGroup;
    }

    // 3人の場合は既存ロジック
    // ...
}
```

#### 案B: 参加中メンバーのHP順序で動的判定

```csharp
private PartyProperty GetPartyImpression()
{
    var active = new[] { Geino, Noramlia, Sites }
        .Where(a => a != null && a.IsInParty)
        .OrderByDescending(a => a.HP)
        .ToList();

    if (active.Count == 0) return PartyProperty.MelaneGroup;
    if (active.Count == 1) return GetSoloProperty(active[0]);
    if (active.Count == 2) return GetDuoProperty(active[0], active[1]);

    // 3人の場合
    return GetTrioProperty(active[0], active[1], active[2]);
}
```

#### 案C: PartyProperty 自体を再設計

現在の「HP順序」ベースの設計を見直し、別の基準に変更。

---

## 12. パーティー属性計算の共通化設計

### 12.1. 現状の2つのロジック

| 対象 | ファイル | 計算方式 | 人数対応 |
|------|----------|----------|----------|
| **味方** | `PartyBuilder.cs` | 3人のHP順序比較 | 3人固定 |
| **敵** | `EnemyCollectManager.cs` | 精神属性の相性値 | 可変（1〜3人） |

### 12.2. 敵のパーティー属性計算ロジック

`EnemyCollectManager.calculatePartyProperty()` は**精神属性ベース**で可変人数に対応:

```csharp
// EnemyCollectManager.cs:272-314
public PartyProperty calculatePartyProperty(List<NormalEnemy> calcList)
{
    // 1. 各メンバーの精神属性を抽出
    var keys = calcList.Select(enemy => enemy.MyImpression).ToList();

    // 2. 固定の組み合わせがあれば優先（例: BaleDrival + Psycho + Sacrifaith → HolyGroup）
    if (PartyPropertyMatchupTable.ContainsKey(NormalizeSpiritualKey(keys)))
        return PartyPropertyMatchupTable[NormalizeSpiritualKey(keys)];

    // 3. メンバー同士の相性値を全ペア取得
    var matchPercentages = new List<int>();
    foreach (var one in keys)
        foreach (var other in keys)
            matchPercentages.Add(GetImpressionMatchPercent(one, other));

    // 4. 相性値に基づいて判定
    if (matchPercentages.All(p => p >= 70)) return PartyProperty.HolyGroup;   // 全員仲良し
    if (matchPercentages.All(p => p <= 30)) return PartyProperty.Odradeks;    // 全員仲悪い

    var average = matchPercentages.Average();
    if (average >= 70) return PartyProperty.MelaneGroup;

    var standardDeviation = /* 標準偏差計算 */;
    if (standardDeviation >= 20) return PartyProperty.Odradeks;  // バラつき大きい
    if (average > 57) return PartyProperty.Flowerees;

    // ランダム要素（敵のみ）
    return /* TrashGroup or MelaneGroup or ランダム */;
}
```

**1人の場合**: 精神属性から直接変換（`EnemyLonelyPartyImpression` 辞書）

```csharp
// 例: Doremis → Flowerees, Pillar → Odradeks, etc.
```

> **重要: 味方パーティー属性は決定論的**
>
> 敵ロジックにはランダム要素があるが、**味方計算には使用しない**。
> 味方のパーティー属性は常に同じ入力に対して同じ結果を返す。
> これにより UI 表示やステータス効果が予測可能になる。
>
> | 対象 | ランダム要素 |
> |------|-------------|
> | 敵 | あり（既存ロジック維持） |
> | **味方** | **なし（決定論的）** |

### 12.3. 設計方針: 条件分岐型の共通化

**方針**: 3人揃っている場合は既存のHP比較を維持し、それ以外は精神属性ベースの共通ロジックを使用

```
┌─────────────────────────────────────────────────────────┐
│  GetPartyImpression()                                    │
│                                                          │
│  参加中メンバー取得                                        │
│      ↓                                                   │
│  ┌─────────────────┐                                     │
│  │ 3人全員参加？    │                                     │
│  └─────────────────┘                                     │
│      ↓ Yes              ↓ No                             │
│  ┌──────────────┐   ┌──────────────────────────┐         │
│  │ 既存ロジック   │   │ 共通ロジック              │         │
│  │ (HP順序比較)  │   │ (精神属性相性ベース)       │         │
│  │              │   │ ← 敵と同じ計算方式        │         │
│  └──────────────┘   └──────────────────────────┘         │
│      ↓                  ↓                                │
│  ┌─────────────────────────────────────────────┐         │
│  │ PartyProperty を返す                         │         │
│  └─────────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────────┘
```

### 12.4. 共通ロジックの抽出

`EnemyCollectManager.calculatePartyProperty()` を汎用化し、敵・味方共通で使用可能にする。

#### 12.4.1. 新規インターフェース/クラス

```csharp
// 新規: IPartyPropertyCalculator.cs
public interface IPartyPropertyCalculator
{
    /// <summary>
    /// 精神属性のリストからパーティー属性を計算（2人以上用）
    /// </summary>
    PartyProperty CalculateFromImpressions(IReadOnlyList<SpiritualProperty> impressions);

    /// <summary>
    /// 単独メンバーの精神属性からパーティー属性を決定
    /// </summary>
    PartyProperty GetSoloPartyProperty(SpiritualProperty impression);

    /// <summary>
    /// 2つの精神属性の相性値を取得
    /// </summary>
    int GetImpressionMatchPercent(SpiritualProperty i, SpiritualProperty you);
}
```

#### 12.4.2. 純粋サービスへの抽出

> **変更理由**: `EnemyCollectManager` は `MonoBehaviour` のため、シーンに存在しないと null になる。
> 純粋なサービス（ScriptableObject）に抽出し、敵・味方両方から参照できるようにする。

```csharp
// 新規: Assets/Script/Players/PartyPropertyCalculatorSO.cs

/// <summary>
/// パーティー属性計算の共通ロジック（敵・味方共用）。
/// EnemyCollectManager から抽出。ランダム要素あり。
///
/// 使用箇所:
/// - 敵: 常にこのロジックを使用
/// - 味方: 固定メンバー1人以下、または新キャラのみの場合に使用
/// </summary>
[CreateAssetMenu(menuName = "pigRPG/PartyPropertyCalculator")]
public class PartyPropertyCalculatorSO : ScriptableObject, IPartyPropertyCalculator
{
    [SerializeField] private ImpressionMatchTableSO matchTable;

    /// <summary>
    /// 精神属性リストからパーティー属性を決定（決定論的）
    /// </summary>
    public PartyProperty CalculateFromImpressions(IReadOnlyList<SpiritualProperty> impressions)
    {
        if (impressions.Count == 0)
            return PartyProperty.MelaneGroup;

        if (impressions.Count == 1)
            return GetSoloPartyProperty(impressions[0]);

        // 相性値を全ペア取得（インデックスで自己比較のみ除外）
        var matchPercentages = new List<int>();
        for (int i = 0; i < impressions.Count; i++)
        {
            for (int j = 0; j < impressions.Count; j++)
            {
                if (i != j)  // 自分自身との比較のみ除外（同属性でも比較する）
                {
                    matchPercentages.Add(GetImpressionMatchPercent(impressions[i], impressions[j]));
                }
            }
        }

        // 空の場合のフォールバック（1人の場合は上で処理済みなので通常到達しない）
        if (matchPercentages.Count == 0)
            return PartyProperty.MelaneGroup;

        // 決定論的判定（ランダム要素なし）
        if (matchPercentages.All(p => p >= 70)) return PartyProperty.HolyGroup;
        if (matchPercentages.All(p => p <= 30)) return PartyProperty.Odradeks;

        var average = matchPercentages.Average();
        if (average >= 70) return PartyProperty.MelaneGroup;
        if (average <= 40) return PartyProperty.TrashGroup;
        if (average > 57) return PartyProperty.Flowerees;

        return PartyProperty.MelaneGroup;  // デフォルト
    }

    /// <summary>
    /// 単独メンバーのパーティー属性（決定論的マッピング）
    /// </summary>
    public PartyProperty GetSoloPartyProperty(SpiritualProperty impression)
    {
        return impression switch
        {
            SpiritualProperty.Doremis => PartyProperty.Flowerees,
            SpiritualProperty.Pillar => PartyProperty.Odradeks,
            SpiritualProperty.Kindergarten => PartyProperty.TrashGroup,
            SpiritualProperty.LiminalWhiteTile => PartyProperty.MelaneGroup,
            SpiritualProperty.Sacrifaith => PartyProperty.HolyGroup,
            SpiritualProperty.Cquiest => PartyProperty.MelaneGroup,
            SpiritualProperty.Psycho => PartyProperty.Odradeks,
            SpiritualProperty.GodTier => PartyProperty.Flowerees,
            SpiritualProperty.BaleDrival => PartyProperty.TrashGroup,
            SpiritualProperty.Devil => PartyProperty.HolyGroup,
            _ => PartyProperty.MelaneGroup
        };
    }

    public int GetImpressionMatchPercent(SpiritualProperty i, SpiritualProperty you)
    {
        return matchTable.GetMatchPercent(i, you);
    }
}
```

```csharp
// EnemyCollectManager.cs の変更（共通ロジックを使用）
public class EnemyCollectManager : MonoBehaviour, IEnemyMatchCalculator
{
    [SerializeField] private PartyPropertyCalculatorSO calculator;

    public PartyProperty calculatePartyProperty(List<NormalEnemy> calcList)
    {
        var impressions = calcList.Select(e => e.MyImpression).ToList();
        return calculator.CalculateFromImpressions(impressions);
    }
}
```

#### 12.4.3. PartyBuilder の修正

```csharp
// PartyBuilder.cs
public sealed class PartyBuilder
{
    private readonly PlayersRoster roster;
    private readonly IPlayersUIControl uiControl;
    private readonly IPartyPropertyCalculator propertyCalculator;  // 追加

    public PartyBuilder(
        PlayersRoster roster,
        IPlayersUIControl uiControl,
        IPartyPropertyCalculator propertyCalculator)  // DI
    {
        this.roster = roster;
        this.uiControl = uiControl;
        this.propertyCalculator = propertyCalculator;
    }

    private PartyProperty GetPartyImpression()
    {
        var activeMembers = roster.Allies
            .Where(a => a != null && a.IsInParty)
            .ToList();

        // 0人: デフォルト
        if (activeMembers.Count == 0)
        {
            return PartyProperty.MelaneGroup;
        }

        // 1人: 精神属性から直接
        if (activeMembers.Count == 1)
        {
            return propertyCalculator.GetSoloPartyProperty(activeMembers[0].MyImpression);
        }

        // 2人: 共通ロジック（精神属性相性）
        if (activeMembers.Count == 2)
        {
            var impressions = activeMembers.Select(a => a.MyImpression).ToList();
            return propertyCalculator.CalculateFromImpressions(impressions);
        }

        // 3人全員揃っている: 既存のHP比較ロジック
        if (IsOriginalThreeMembers(activeMembers))
        {
            return GetPartyImpressionByHpOrder();
        }

        // 3人だが構成が異なる（将来の新キャラ等）: 共通ロジック
        var impressions3 = activeMembers.Select(a => a.MyImpression).ToList();
        return propertyCalculator.CalculateFromImpressions(impressions3);
    }

    /// <summary>
    /// オリジナル3人（Geino, Noramlia, Sites）が全員参加中か判定
    /// </summary>
    private bool IsOriginalThreeMembers(List<AllyClass> activeMembers)
    {
        if (activeMembers.Count != 3) return false;

        var hasGeino = activeMembers.Any(a => a is StairStates);
        var hasNoramlia = activeMembers.Any(a => a is BassJackStates);
        var hasSites = activeMembers.Any(a => a is SateliteProcessStates);

        return hasGeino && hasNoramlia && hasSites;
    }

    /// <summary>
    /// 既存のHP比較ロジック（3人専用）
    /// </summary>
    private PartyProperty GetPartyImpressionByHpOrder()
    {
        // 既存コードをそのまま維持
        var geino = roster.GetAllyById(AllyId.Geino);
        var noramlia = roster.GetAllyById(AllyId.Noramlia);
        var sites = roster.GetAllyById(AllyId.Sites);

        // ... 既存の HP 比較ロジック ...
    }
}
```

### 12.5. 実装タスク

| タスク | 詳細 | 優先度 |
|--------|------|--------|
| `IPartyPropertyCalculator` 作成 | 共通インターフェース定義 | 高 |
| `EnemyCollectManager` 拡張 | インターフェース実装、ロジック汎用化 | 高 |
| `PartyBuilder` 修正 | DI 追加、条件分岐実装 | 高 |
| `PlayersRuntime` 修正 | PartyBuilder への DI 設定 | 中 |
| 1人用マッピング確認 | 味方用の SoloPartyProperty 対応表 | 中 |

### 12.6. 固定メンバー人数による分岐（確定）

```
参加メンバー取得
      ↓
┌──────────────────────────────────────┐
│ 固定メンバー（Geino/Noramlia/Sites）  │
│ が何人いる？                          │
└──────────────────────────────────────┘
      ↓
┌─────────┬─────────┬─────────┬─────────┐
│ 3人     │ 2人     │ 1人     │ 0人     │
└─────────┴─────────┴─────────┴─────────┘
    ↓         ↓         ↓         ↓
 既存HP    2人用      共通       共通
 比較      マッピング  ロジック   ロジック
 (6通り)   (6通り)   (精神属性)  (精神属性)
           ✓確定
```

### 12.7. 2人用マッピング（確定）

固定メンバー2人の場合、HP比較でパーティー属性を決定する。
各ペア × 2通り = 計6通りのマッピング。

```
Geino + Sites:
  Geino ≥ Sites  → MelaneGroup（メレーンズ）
  Sites ≥ Geino  → Flowerees（花樹）

Geino + Noramlia:
  Geino ≥ Noramlia  → MelaneGroup（メレーンズ）
  Noramlia ≥ Geino  → Odradeks（オドラデクス）

Sites + Noramlia:
  Sites ≥ Noramlia  → HolyGroup（聖戦）
  Noramlia ≥ Sites  → TrashGroup（馬鹿共）
```

#### 2人マッピングの考察

| ペア | HP順序 | 結果 | 理由 |
|------|--------|------|------|
| G+S | G≥S | MelaneGroup | 秩序が俯瞰より強い → 安定した王道 |
| G+S | S≥G | Flowerees | 俯瞰が秩序より強い → オサレな外向き |
| G+N | G≥N | MelaneGroup | 秩序がカオスを抑制 → 王道 |
| G+N | N≥G | Odradeks | カオスが秩序に勝つ、俯瞰なし → 内向きの捻れ |
| S+N | S≥N | HolyGroup | 俯瞰が強くカオス抑制、秩序なし → 必死の使命 |
| S+N | N≥S | TrashGroup | カオスが強く、俯瞰弱い、秩序なし → 馬鹿騒ぎ |

**詳細**: [パーティー属性HP分岐マッピング.md](./パーティー属性HP分岐マッピング.md) を参照。

### 12.8. 1人の場合のパーティー属性

固定メンバーが1人のみ、または固定メンバー以外のみの場合は、
**敵と同じ共通ロジック**（`PartyPropertyCalculatorSO`）を使用。

```
共通マッピング（敵・味方共用、ランダムあり）:
Doremis         → Flowerees
Pillar          → Odradeks
Kindergarten    → TrashGroup
LiminalWhiteTile → MelaneGroup
Sacrifaith      → HolyGroup
Cquiest         → MelaneGroup
Psycho           → ランダム
GodTier         → Flowerees
BaleDrival      → TrashGroup
devil           → HolyGroup
```

> **注意**: 固定メンバー1人以下の場合、味方もランダム要素が入る。
> 固定メンバー2人以上の場合のみ決定論的（HP比較マッピング）。

### 12.7. 依存関係の変更

```
変更前:
PartyBuilder → (直接) Geino/Noramlia/Sites のHP比較
EnemyCollectManager → (内部) calculatePartyProperty()

変更後:
┌─────────────────────────────────────────────────────┐
│ 共通ロジック                                         │
│              PartyPropertyCalculatorSO               │
│              （EnemyCollectManager から抽出）         │
│              （ランダム要素あり）                     │
├─────────────────────────────────────────────────────┤
│ 敵側                                                 │
│ EnemyCollectManager → PartyPropertyCalculatorSO     │
│ （常に共通ロジックを使用）                            │
├─────────────────────────────────────────────────────┤
│ 味方側                                               │
│ PartyBuilder                                         │
│   ├─ 固定3人 → 既存HP比較（決定論的）                │
│   ├─ 固定2人 → HP比較マッピング（決定論的）          │
│   └─ 固定1人以下/新キャラのみ                        │
│            → PartyPropertyCalculatorSO（ランダムあり）│
└─────────────────────────────────────────────────────┘
```

---

## 13. 方針C 詳細設計（実装用）

### 13.1. 新アーキテクチャ全体像

```
┌─────────────────────────────────────────────────────────────────┐
│                     方針C: 全キャラ管理システム                    │
└─────────────────────────────────────────────────────────────────┘

【キャラクター識別】
  CharacterId (readonly struct)
  ├── 静的定義: Geino, Noramlia, Sites
  └── 動的追加: 新キャラはコード変更なしで追加可能

【全キャラ管理】
  PlayersRoster
  ├── Dictionary<CharacterId, AllyClass>  ← 配列[3]から辞書に変更
  ├── RegisterAlly(CharacterId, AllyClass)
  ├── GetAlly(CharacterId) → AllyClass
  └── AllAllies → IEnumerable<AllyClass>

【編成管理】（新規）
  IPartyComposition / PartyComposition
  ├── MaxMembers = 3
  ├── ActiveMemberIds: IReadOnlyList<CharacterId>
  ├── SetMembers(params CharacterId[] ids)
  ├── AddMember(CharacterId id)
  ├── RemoveMember(CharacterId id)
  └── ストーリーイベントで動的変更

【戦闘グループ構築】
  PartyBuilder
  └── IPartyComposition.ActiveMemberIds から AllyClass を取得
      └── BattleGroup 構築

【セーブデータ】
  PlayersSaveData
  ├── AllySaveData[] (CharacterId indexed)
  └── ActivePartyIds: string[]
```

### 13.2. CharacterId 設計

> **注意**:
> - Unity Inspector でシリアライズ可能にするため、`[Serializable]` と `[SerializeField]` を使用。
> - `ISerializationCallbackReceiver` でデシリアライズ時にも小文字正規化を保証。

```csharp
// 新規: Assets/Script/Players/CharacterId.cs

/// <summary>
/// キャラクター識別子。AllyId enum の置き換え。
/// Unity シリアライズ対応済み。デシリアライズ時に小文字正規化。
/// </summary>
[Serializable]
public struct CharacterId : IEquatable<CharacterId>, ISerializationCallbackReceiver
{
    [SerializeField] private string _value;  // Unity シリアライズ用

    public string Value => _value ?? string.Empty;

    public CharacterId(string value)
    {
        // 小文字に正規化して大文字小文字の不一致を防ぐ
        _value = value?.ToLowerInvariant() ?? string.Empty;
    }

    // === ISerializationCallbackReceiver ===
    // Unity がデシリアライズした後に正規化を適用

    public void OnAfterDeserialize()
    {
        // Inspector や JSON から読み込んだ値を小文字に正規化
        _value = _value?.ToLowerInvariant() ?? string.Empty;
    }

    public void OnBeforeSerialize()
    {
        // シリアライズ前は特に処理なし
    }

    // 既存キャラの静的定義
    public static readonly CharacterId Geino = new("geino");
    public static readonly CharacterId Noramlia = new("noramlia");
    public static readonly CharacterId Sites = new("sites");

    // 無効なID判定用
    public static readonly CharacterId None = new(string.Empty);
    public bool IsValid => !string.IsNullOrEmpty(_value);

    // 比較・ハッシュ
    public bool Equals(CharacterId other) => Value == other.Value;
    public override bool Equals(object obj) => obj is CharacterId id && Equals(id);
    public override int GetHashCode() => Value?.GetHashCode() ?? 0;
    public override string ToString() => Value;

    public static bool operator ==(CharacterId left, CharacterId right) => left.Equals(right);
    public static bool operator !=(CharacterId left, CharacterId right) => !left.Equals(right);

    // 暗黙変換（デバッグ用）
    public static implicit operator string(CharacterId id) => id.Value;
}
```

### 13.3. IPartyComposition 設計

> **設計方針**:
> - **順序不定**: `ActiveMemberIds` の順序に意味はない。UI表示順や戦闘行動順は別途管理する。
> - **戦闘外のみ操作可能**: `AddMember` / `RemoveMember` は戦闘中に呼び出さない（後述の制約参照）。

```csharp
// 新規: Assets/Script/Players/IPartyComposition.cs

/// <summary>
/// パーティー編成を管理するインターフェース。
/// 注意: メンバーの順序は不定。順序依存の処理を書かないこと。
/// </summary>
public interface IPartyComposition
{
    /// <summary>パーティー最大人数</summary>
    int MaxMembers { get; }

    /// <summary>
    /// 現在のパーティーメンバーID一覧。
    /// 順序は不定。UI/バトル順序には依存しないこと。
    /// </summary>
    IReadOnlyList<CharacterId> ActiveMemberIds { get; }

    /// <summary>パーティーにメンバーを追加（戦闘外のみ）</summary>
    bool AddMember(CharacterId id);

    /// <summary>パーティーからメンバーを除外（戦闘外のみ）</summary>
    bool RemoveMember(CharacterId id);

    /// <summary>パーティーを一括設定（戦闘外のみ）</summary>
    void SetMembers(params CharacterId[] ids);

    /// <summary>メンバーがパーティーに参加中か</summary>
    bool Contains(CharacterId id);

    /// <summary>パーティーが空か</summary>
    bool IsEmpty { get; }

    /// <summary>パーティーが満員か</summary>
    bool IsFull { get; }
}
```

```csharp
// 新規: Assets/Script/Players/PartyComposition.cs

public sealed class PartyComposition : IPartyComposition
{
    private readonly List<CharacterId> _members = new();
    private IReadOnlyList<CharacterId> _readOnlyMembers;

    public int MaxMembers => 3;

    /// <summary>外部からの変更を防ぐため AsReadOnly() で返す</summary>
    public IReadOnlyList<CharacterId> ActiveMemberIds
        => _readOnlyMembers ??= _members.AsReadOnly();

    public bool IsEmpty => _members.Count == 0;
    public bool IsFull => _members.Count >= MaxMembers;

    public bool AddMember(CharacterId id)
    {
        if (!id.IsValid) return false;  // 無効なID拒否
        if (IsFull || Contains(id)) return false;
        _members.Add(id);
        return true;
    }

    public bool RemoveMember(CharacterId id)
    {
        return _members.Remove(id);
    }

    public void SetMembers(params CharacterId[] ids)
    {
        _members.Clear();
        foreach (var id in ids.Take(MaxMembers))
        {
            if (id.IsValid && !Contains(id))
                _members.Add(id);
        }
    }

    public bool Contains(CharacterId id) => _members.Contains(id);
}
```

### 13.4. PlayersRoster 変更

> **解放状態管理**: Roster に登録されているキャラ = 解放済み（所持済み）。
> パーティー編成時は Roster に存在するキャラのみ追加可能。

```csharp
// 変更: Assets/Script/Players/PlayersRoster.cs

public sealed class PlayersRoster : IPlayersRoster
{
    private readonly Dictionary<CharacterId, AllyClass> _allies = new();

    /// <summary>キャラクターを登録（解放/加入）</summary>
    public void RegisterAlly(CharacterId id, AllyClass ally)
    {
        if (!id.IsValid)
        {
            Debug.LogWarning($"PlayersRoster: 無効なキャラクターID '{id}'");
            return;
        }
        _allies[id] = ally;
    }

    /// <summary>キャラクターを取得</summary>
    public AllyClass GetAlly(CharacterId id)
    {
        return _allies.TryGetValue(id, out var ally) ? ally : null;
    }

    /// <summary>全キャラクター（解放済み）</summary>
    public IEnumerable<AllyClass> AllAllies => _allies.Values;

    /// <summary>解放済みキャラクターID一覧</summary>
    public IEnumerable<CharacterId> AllCharacterIds => _allies.Keys;

    /// <summary>キャラクターが解放済みか（= Roster に登録されているか）</summary>
    public bool IsUnlocked(CharacterId id) => _allies.ContainsKey(id);

    /// <summary>キャラクターが存在するか（IsUnlocked のエイリアス）</summary>
    public bool HasAlly(CharacterId id) => IsUnlocked(id);

    /// <summary>キャラクターIDを逆引き</summary>
    public bool TryGetCharacterId(BaseStates actor, out CharacterId id)
    {
        foreach (var kvp in _allies)
        {
            if (kvp.Value == actor)
            {
                id = kvp.Key;
                return true;
            }
        }
        id = default;
        return false;
    }

    // === 互換性レイヤー（段階的移行用、最終的に削除） ===

    [Obsolete("CharacterId を使用してください")]
    public AllyClass GetAllyById(AllyId id)
    {
        var charId = id switch
        {
            AllyId.Geino => CharacterId.Geino,
            AllyId.Noramlia => CharacterId.Noramlia,
            AllyId.Sites => CharacterId.Sites,
            _ => default
        };
        return GetAlly(charId);
    }
}
```

**PartyComposition との連携**:

```csharp
// パーティーにメンバー追加時、Roster に存在するか検証
public bool AddMemberWithValidation(CharacterId id, PlayersRoster roster)
{
    if (!roster.IsUnlocked(id))
    {
        Debug.LogWarning($"未解放キャラ '{id}' をパーティーに追加できません");
        return false;
    }
    return AddMember(id);
}
```

### 13.5. 派生クラス統一

```
【現在】
AllyClass (abstract)
├── StairStates        ← DeepCopy() のみ
├── BassJackStates     ← DeepCopy() のみ
└── SateliteProcessStates ← DeepCopy() のみ

【変更後】
AllyClass (concrete)  ← 派生クラス廃止、単一クラスに統一
└── キャラ固有データは CharacterDataSO で管理
```

```csharp
// 変更: Assets/Script/Players/Runtime/AllyClass.cs

[Serializable]
public class AllyClass : BaseStates
{
    /// <summary>このキャラクターのID</summary>
    public CharacterId CharacterId { get; private set; }

    /// <summary>キャラクター初期化</summary>
    public void Initialize(CharacterId id, CharacterDataSO data)
    {
        CharacterId = id;
        // data から初期ステータス等を設定
    }

    /// <summary>ディープコピー</summary>
    public AllyClass DeepCopy()
    {
        var clone = new AllyClass();
        InitBaseStatesDeepCopy(clone);
        clone.CharacterId = this.CharacterId;
        // AllyClass 固有フィールドをコピー
        return clone;
    }
}

// 廃止予定（互換性のため一時的に残す）
[Obsolete("AllyClass を直接使用してください")]
public class StairStates : AllyClass { }
[Obsolete("AllyClass を直接使用してください")]
public class BassJackStates : AllyClass { }
[Obsolete("AllyClass を直接使用してください")]
public class SateliteProcessStates : AllyClass { }
```

### 13.6. セーブデータ構造

```csharp
// 変更: Assets/Script/Players/PlayersSaveData.cs

[Serializable]
public sealed class PlayersSaveData
{
    /// <summary>全キャラクターのセーブデータ</summary>
    public List<AllySaveData> Allies = new();

    /// <summary>現在のパーティー編成</summary>
    public List<string> ActivePartyIds = new();
}

[Serializable]
public sealed class AllySaveData
{
    /// <summary>キャラクターID</summary>
    public string CharacterId;

    /// <summary>HP等のステータス</summary>
    public float HP;
    public float MaxHP;
    public float MentalHP;
    public float MentalMaxHP;
    // ... その他のフィールド
}
```

### 13.7. PartyBuilder 変更

```csharp
// 変更: Assets/Script/Players/PartyBuilder.cs

public sealed class PartyBuilder
{
    private readonly PlayersRoster roster;
    private readonly IPartyComposition composition;
    private readonly IPartyPropertyCalculator propertyCalculator;

    public PartyBuilder(
        PlayersRoster roster,
        IPartyComposition composition,
        IPartyPropertyCalculator propertyCalculator)
    {
        this.roster = roster;
        this.composition = composition;
        this.propertyCalculator = propertyCalculator;
    }

    public BattleGroup BuildParty()
    {
        var members = new List<BaseStates>();

        foreach (var id in composition.ActiveMemberIds)
        {
            var ally = roster.GetAlly(id);
            if (ally != null)
            {
                members.Add(ally);
            }
        }

        if (members.Count == 0)
        {
            Debug.LogWarning("BuildParty: パーティーメンバーがいません");
        }

        var partyProperty = GetPartyImpression(members);
        return new BattleGroup(members, partyProperty);
    }

    /// <summary>
    /// パーティー属性を決定
    /// - 固定メンバー2人以上 → 決定論的（HP比較マッピング）
    /// - 固定メンバー1人以下/新キャラのみ → 共通ロジック（ランダムあり）
    /// </summary>
    private PartyProperty GetPartyImpression(List<BaseStates> members)
    {
        // 0人: デフォルト
        if (members.Count == 0)
            return PartyProperty.MelaneGroup;

        // 固定メンバーを抽出
        var originalIds = CountOriginalMembers(members);

        // 固定メンバー3人 → 既存HP比較（決定論的）
        if (originalIds == 3 && IsOriginalThree(members))
            return GetTrioPartyPropertyByHp(members);

        // 固定メンバー2人 → HP比較マッピング（決定論的）
        if (originalIds == 2 && members.Count == 2)
            return GetDuoPartyProperty(members);

        // 固定メンバー1人以下、または新キャラ含む → 共通ロジック（ランダムあり）
        if (members.Count == 1)
            return propertyCalculator.GetSoloPartyProperty(members[0].MyImpression);

        var impressions = members.Select(m => m.MyImpression).ToList();
        return propertyCalculator.CalculateFromImpressions(impressions);
    }

    /// <summary>
    /// 固定メンバー（Geino/Noramlia/Sites）の人数をカウント
    /// </summary>
    private int CountOriginalMembers(List<BaseStates> members)
    {
        var originals = new[] { CharacterId.Geino, CharacterId.Noramlia, CharacterId.Sites };
        return members.OfType<AllyClass>()
            .Count(a => originals.Contains(a.CharacterId));
    }

    /// <summary>
    /// 2人の場合のパーティー属性決定
    /// </summary>
    private PartyProperty GetDuoPartyProperty(List<BaseStates> members)
    {
        var ids = members.OfType<AllyClass>().Select(a => a.CharacterId).ToList();

        // オリジナルペア（Geino/Noramlia/Sites の組み合わせ）の場合のみHP比較（決定論的）
        if (IsOriginalPair(ids))
        {
            return GetDuoPartyPropertyByHp(members, ids);
        }

        // 新キャラ含む場合は共通ロジック（ランダムあり）
        var impressions = members.Select(m => m.MyImpression).ToList();
        return propertyCalculator.CalculateFromImpressions(impressions);
    }

    /// <summary>
    /// オリジナル3人のペアかどうか判定
    /// </summary>
    private bool IsOriginalPair(List<CharacterId> ids)
    {
        if (ids.Count != 2) return false;
        var originals = new[] { CharacterId.Geino, CharacterId.Noramlia, CharacterId.Sites };
        return ids.All(id => originals.Contains(id));
    }

    private bool IsOriginalThree(List<BaseStates> members)
    {
        if (members.Count != 3) return false;
        var ids = members.OfType<AllyClass>().Select(a => a.CharacterId).ToHashSet();
        return ids.Contains(CharacterId.Geino)
            && ids.Contains(CharacterId.Noramlia)
            && ids.Contains(CharacterId.Sites);
    }

    /// <summary>
    /// オリジナルペアのHP比較マッピング（セクション12.7参照）
    /// </summary>
    private PartyProperty GetDuoPartyPropertyByHp(List<BaseStates> members, List<CharacterId> ids)
    {
        var sorted = members.OrderByDescending(m => m.HP).ToList();
        var higherId = ((AllyClass)sorted[0]).CharacterId;
        var lowerId = ((AllyClass)sorted[1]).CharacterId;

        // Geino + Sites
        if (ids.Contains(CharacterId.Geino) && ids.Contains(CharacterId.Sites))
        {
            return higherId == CharacterId.Geino
                ? PartyProperty.MelaneGroup   // G≥S
                : PartyProperty.Flowerees;    // S≥G
        }

        // Geino + Noramlia
        if (ids.Contains(CharacterId.Geino) && ids.Contains(CharacterId.Noramlia))
        {
            return higherId == CharacterId.Geino
                ? PartyProperty.MelaneGroup   // G≥N
                : PartyProperty.Odradeks;     // N≥G
        }

        // Sites + Noramlia
        if (ids.Contains(CharacterId.Sites) && ids.Contains(CharacterId.Noramlia))
        {
            return higherId == CharacterId.Sites
                ? PartyProperty.HolyGroup     // S≥N
                : PartyProperty.TrashGroup;   // N≥S
        }

        return PartyProperty.MelaneGroup;  // フォールバック
    }

    // ... GetTrioPartyPropertyByHp は既存HP比較ロジック維持
}
```

### 13.8. ストーリー連携（PartyMemberEffect）

> **制約**:
> - パーティー編成操作は**戦闘外のみ**で実行可能
> - **解放済み（Roster 登録済み）のキャラのみ**追加可能

```csharp
// 新規: Assets/Script/Walk/Effects/PartyMemberEffect.cs

[CreateAssetMenu(menuName = "pigRPG/Effects/PartyMemberEffect")]
public sealed class PartyMemberEffect : EffectSO
{
    public enum Action { Add, Remove }

    [SerializeField] private string targetCharacterId;
    [SerializeField] private Action action;

    public override void Apply(EffectContext context)
    {
        // 戦闘中は編成変更不可
        if (BattleContextHub.Current != null)
        {
            Debug.LogWarning("PartyMemberEffect: 戦闘中はパーティー編成を変更できません");
            return;
        }

        var players = context.GameContext?.Players;
        var composition = players?.Composition;
        var roster = players?.Roster;
        if (composition == null || roster == null) return;

        var id = new CharacterId(targetCharacterId);
        if (!id.IsValid)
        {
            Debug.LogWarning($"PartyMemberEffect: 無効なキャラクターID '{targetCharacterId}'");
            return;
        }

        switch (action)
        {
            case Action.Add:
                // 解放済みチェック
                if (!roster.IsUnlocked(id))
                {
                    Debug.LogWarning($"PartyMemberEffect: 未解放キャラ '{id}' は追加できません");
                    return;
                }
                if (composition.AddMember(id))
                {
                    Debug.Log($"パーティーに {id} を追加");
                }
                break;
            case Action.Remove:
                if (composition.RemoveMember(id))
                {
                    Debug.Log($"パーティーから {id} を除外");
                }
                break;
        }
    }
}
```

### 13.9. 影響ファイル一覧

| ファイル | 変更内容 | 難易度 |
|----------|----------|--------|
| **新規作成** | | |
| `CharacterId.cs` | ID構造体定義（ISerializationCallbackReceiver） | 低 |
| `IPartyComposition.cs` | 編成インターフェース | 低 |
| `PartyComposition.cs` | 編成実装（AsReadOnly） | 低 |
| `PartyPropertyCalculatorSO.cs` | 共通パーティー属性計算（EnemyCollectManagerから抽出） | 中 |
| `PartyMemberEffect.cs` | ストーリー連携（戦闘中ガード、IsUnlocked チェック） | 低 |
| **変更** | | |
| `PlayersRoster.cs` | 配列→辞書化 | 中 |
| `PlayersRuntime.cs` | 初期化変更 | 中 |
| `PlayersBootstrapper.cs` | キャスト廃止 | 中 |
| `PartyBuilder.cs` | 編成対応 | 中 |
| `PlayersSaveData.cs` | 構造変更 | 中 |
| `PlayersSaveService.cs` | 保存/読込変更 | 中 |
| `PlayersUIService.cs` | CharacterId参照 | 中 |
| `AllyClass.cs` | CharacterId追加、派生統一 | 中 |
| `NovelDialogueStep.cs` | CharacterId対応 | 低 |
| **廃止** | | |
| `AllyId.cs` | 段階的廃止（互換レイヤー経由） | - |
| `StairStates` | AllyClass に統一 | - |
| `BassJackStates` | AllyClass に統一 | - |
| `SateliteProcessStates` | AllyClass に統一 | - |

### 13.10. 実装タスク（優先度順）

```
Phase 1: 基盤作成
├── [ ] CharacterId.cs 作成（Serializable、小文字正規化）
├── [ ] IPartyComposition.cs 作成
├── [ ] PartyComposition.cs 作成（AsReadOnly、順序不定明記）
├── [ ] PartyPropertyCalculatorSO.cs 作成（敵・味方共用、EnemyCollectManagerから抽出）
└── [ ] AllyClass に CharacterId プロパティ追加

Phase 2: Roster 変更
├── [ ] PlayersRoster を Dictionary 化
├── [ ] IsUnlocked() 追加（解放状態管理）
├── [ ] IPlayersRoster インターフェース更新
└── [ ] 互換性レイヤー追加（GetAllyById）

Phase 3: 編成システム統合
├── [ ] PlayersRuntime に IPartyComposition 追加
├── [ ] PartyBuilder を composition ベースに変更
├── [ ] GetPartyImpression の人数別分岐
└── [ ] 2人ロジック：オリジナルペア以外は精神属性フォールバック

Phase 4: セーブ対応
├── [ ] PlayersSaveData 構造変更
├── [ ] PlayersSaveService 書き直し
└── [ ] パーティー編成の保存/読込

Phase 5: UI 対応
├── [ ] PlayersUIService の CharacterId 対応
├── [ ] CharaconfigController 修正
└── [ ] BattleUIBridge 調整（必要に応じて）

Phase 6: ストーリー連携
├── [ ] PartyMemberEffect.cs 作成（戦闘中ガード付き）
├── [ ] NovelDialogueStep.cs CharacterId 対応
└── [ ] 既存 SO データ更新

Phase 7: クリーンアップ
├── [ ] 派生クラス（StairStates等）削除
├── [ ] AllyId enum 削除
└── [ ] 互換性レイヤー削除
```

---

## 14. UI層の扱い

### 14.1. 変更不要な部分

| ファイル | 理由 |
|----------|------|
| `TabCharaStateContent.cs` | SkillUICharaState は UI状態で AllyId と無関係 |
| `SkillUICharaState` enum | UI表示用、キャラ管理と独立 |

### 14.2. 変更が必要な部分

| ファイル | 変更内容 |
|----------|----------|
| `PlayersUIService.cs` | `(AllyId)i` キャストを CharacterId 参照に |
| `CharaconfigController.cs` | インデックス管理を CharacterId に |
| `BattleUIBridge.cs` | TryGetAllyId を TryGetCharacterId に |

### 14.3. 3人固定UI の扱い

現在のUIは3人分の表示枠がある。方針:

- **パーティー3人以下を維持**（これは変わらない）
- UIの枠は固定3つのまま
- パーティーが2人以下の場合、空き枠は非表示/グレーアウト
- 新キャラが入っても、3人以内なら既存UIで対応可能

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-28 | **レビュー対応2**: 共通ロジック抽出（PartyPropertyCalculatorSO）、同属性ペアバグ修正、IsUnlocked チェック追加、ISerializationCallbackReceiver 追加、固定メンバー判定ロジック明確化 |
| 2026-01-28 | **レビュー対応1**: CharacterId シリアライズ修正、順序不定明記、戦闘外制約追加、2人ロジック修正、IPartyPropertyCalculator SO化、解放状態管理追加、決定論的明記 |
| 2026-01-27 | **方針C確定、詳細設計追加（セクション13-14）** |
| 2026-01-27 | 2人用マッピング確定（セクション12.7） |
| 2026-01-27 | パーティー属性計算の共通化設計追加 |
| 2026-01-27 | 3人前提ロジック調査結果追加、GetPartyImpression問題詳細追加 |
| 2026-01-27 | 初版（現状分析・設計方針策定） |
