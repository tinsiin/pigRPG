# 歩行システム実装計画（ゼロトタイプ準拠）

## 単一ソース
- 仕様の最終決定は「ゼロトタイプ歩行システム設計書」を基準とする。
- 他ドキュメントは参照用として扱う。

## 目的
- 歩行・分岐・遭遇・イベント門・サイドオブジェクトを1つの設計で動かす最小コアを実装する。
- BattleManager、PlayersStates、WatchUIUpdateをブラックボックスとして接続する。
- UIは同一シーン内で完結させ、シーン分割は行わない。
- Event KernelとEffect拡張で将来のゲームシステム追加を可能にする。

## 非目的
- 既存の戦闘UIや戦闘ロジックの再設計。
- PlayersStates内部構造の全面改修。
- 最初の段階でGraphView等の高度な編集ツールを作る。

## 境界と統合方針
- 歩行コア: FlowGraphSO/NodeSO/EdgeSO + AreaController + WalkState。
- Event Kernel: EventDefinitionSO/EventHost/EventRunnerでイベント実行を統一。
- UI: Presenter層のみ。既存UIは public メソッドで呼び出す。
- 戦闘: IBattleRunnerアダプタ経由でBattleManagerを起動。
- プレイヤー状態: GameContextはPlayersStatesを直接参照する。

## 実装フェーズ
補足: Phase 0/1/2は中間の確認地点として分け、Phase 2で既存システムを歩行システムに完全に載せる。
### Phase 0: 歩行ループ基盤
- FlowGraphSO/NodeSO/EdgeSOの最小構成を作成。
- WalkCounters（globalSteps/nodeSteps/trackProgress）とWalkStateを定義。
- AreaControllerで歩行サイクルを実行できる状態にする。
- 退出は出口アプローチ経由、Auto遷移は未使用。

成果物: 1ノードの歩行ループが動作し、出口UIまで到達できる。

作業項目:
- FlowGraphSOにNode/Edge参照と現在ノードIDの取り扱いを追加。
- ExitSpawn/ExitCandidateの最小仕様を定義（1択でもUIを出す）。
- WalkCountersをGameContextに保持し、歩行サイクルで更新する。
- AreaController.WalkStepで「サイド更新→中央更新→遭遇判定→アプローチ→進捗更新」の順を固定する。

実装対象（例）:
- `Assets/Scripts/Walk/FlowGraphSO.cs`
- `Assets/Scripts/Walk/NodeSO.cs`
- `Assets/Scripts/Walk/EdgeSO.cs`
- `Assets/Scripts/Walk/WalkState.cs`
- `Assets/Scripts/Walk/WalkCounters.cs`
- `Assets/Scripts/Walk/AreaController.cs`
- `Assets/Scripts/Walk/ExitSpawnRule.cs`
- `Assets/Scripts/Walk/ExitCandidate.cs`

確認:
- 1ノード/1出口でPlayし、出口UIが必ず出ること。
- Auto遷移を使わずに次ノードへ遷移できること。

### Phase 1: Event KernelとPresenter
- EventDefinitionSOとEventRunnerを実装。
- Condition/Effectの基底と最小セットを実装（SetFlag等）。
- SideObjectPresenterとCentralObjectPresenterの受け口を用意。
- 中央オブジェクトのUIは新規に最小構成で作る（Image/TMP/Buttonなど）。
- MessageDropper/CreateAreaButtonをEvent経由で呼べるようにする。

成果物: サイド/中央イベントがEvent Kernel経由で動作する。

作業項目:
- EventDefinitionSO（EventStep配列）を作成し、EventRunnerで順次実行する。
- Condition/Effectの基底を用意し、最小Effectを実装（SetFlag/SetCounter/PlaySfx程度）。
- EventHost.TriggerからEventRunnerを起動できるようにする。
- SideObject/中央オブジェクトのクリックでEventHost.Triggerが呼べる状態にする。
- MessageDropper/CreateAreaButtonの呼び出しをEventStepに封じ込める。

実装対象（例）:
- `Assets/Scripts/Walk/EventKernel/EventDefinitionSO.cs`
- `Assets/Scripts/Walk/EventKernel/EventRunner.cs`
- `Assets/Scripts/Walk/EventKernel/EventHost.cs`
- `Assets/Scripts/Walk/EventKernel/EventStep.cs`
- `Assets/Scripts/Walk/Effects/SetFlagEffect.cs`
- `Assets/Scripts/Walk/Effects/SetCounterEffect.cs`
- `Assets/Scripts/Walk/Presenter/CentralObjectPresenter.cs`
- `Assets/Scripts/Walk/Presenter/SideObjectPresenter.cs`

確認:
- サイド/中央のイベントがEvent Kernel経由で最後まで実行されること。
- MessageDropperとCreateAreaButtonが既存UIのまま動作すること。

### Phase 2: 遭遇とバトル統合
- EncounterTableSO/EncounterSOを実装。
- 遭遇判定（baseRate、倍率、cooldown/grace/pity）を実装。
- IBattleRunnerアダプタでBattleManagerを呼び出す。
- 戦闘結果をEffectで処理できるようにする。

成果物: 歩行中に遭遇し、戦闘後に歩行へ戻れる。

置き換え方針（現行ステージからの置換）:
- useNewWalkSystem時はWalking.csのEncount()を通らず、AreaController側のEncounterフローで置き換える。
- 旧StageCutのEnemyList/EscapeRateは参照せず、EncounterSO側に敵リスト/escapeRateを保持する。
- WatchUIUpdate.StageDataUIUpdateはWalkingSystemManager内で旧Walk相当の更新を行い、旧ステージUI更新を置換する。

作業項目:
- EncounterTableSOで候補と重みを管理し、EncounterResolverで抽選する。
- baseRateと倍率（Overlay等）の合成を実装する。
- IBattleRunnerアダプタでBattleManagerを起動し、結果（Victory/Defeat/Escape）を返す。
- EncounterOutcomeに応じたEffect実行を実装する。

作業項目（具体化）:
1) NodeSOに encounterTable を追加し、P2テストNodeに割当。
2) Encounterデータを定義:
   - EncounterTableSO: baseRate/entries/cooldown/grace/pity を保持。
   - EncounterSO: id/label/enemyList/escapeRate/battleEvent(onWin/onLose/onEscapeは任意) を保持。
   - EncounterResolver: 判定結果とEncounterState(内部カウンタ)更新を担当。
3) Battle統合:
   - IBattleRunner: RunBattleAsync(EncounterContext) -> BattleResult を定義。
   - UnityBattleRunner: BattleInitializerを使ってBattleOrchestrator生成→UI連携→終了を待つ。
4) Effect連携:
   - LaunchBattleEffect: EncounterSOからIBattleRunnerを実行。
   - BattleResultに応じたEventDefinitionを発火。
5) Flow統合:
   - AreaController.WalkStepへEncounter処理を追加（サイド/中央表示→Encounter判定→遭遇なら戦闘→復帰後にアプローチ）。
   - 戦闘前にロールしたサイド/中央は保持し、戦闘後も同じ対象にアプローチできるようにする（再抽選しない）。
   - 逃走/敗北で巻き戻しが発生した場合は、歩数/ノード状態と同時にサイド/中央も再抽選されるようにする。
   - 遭遇中は歩行ループを停止し、戦闘終了後に復帰させる。

実装対象（例）:
- `Assets/Scripts/Walk/Encounter/EncounterTableSO.cs`
- `Assets/Scripts/Walk/Encounter/EncounterSO.cs`
- `Assets/Scripts/Walk/Encounter/EncounterResolver.cs`
- `Assets/Scripts/Walk/Battle/IBattleRunner.cs`
- `Assets/Scripts/Walk/Battle/UnityBattleRunner.cs`
- `Assets/Scripts/Walk/Effects/LaunchBattleEffect.cs`

確認:
- 遭遇率を100%にしたノードで確実にバトルが起動すること。
- 戦闘終了後に歩行へ復帰できること。
- useNewWalkSystem時に旧Encountが呼ばれないこと。

## 最小データ構成（Phase 0〜2）
### FlowGraphSO
- nodes: NodeSO[]
- edges: EdgeSO[]
- startNodeId: string

### NodeSO
- nodeId: string
- sideObjectTable: SideObjectTableSO（任意）
- encounterTable: EncounterTableSO（任意）
- exits: ExitCandidate[]
- exitSpawn: ExitSpawnRule
- onEnter/onExit: EventDefinitionSO（任意）

### EdgeSO（Phase 0は最小）
- fromNodeId: string
- toNodeId: string
- conditions: ConditionSO[]（Phase 0は空で可）
- weight: int（Weighted用、Phase 0は未使用でも可）

### ExitSpawnRule
- mode: Steps / Probability
- steps: int（Steps時のみ）
- rate: float（Probability時のみ）

### ExitCandidate
- id: string
- toNodeId: string
- uiLabel: string
- conditions: ConditionSO[]（任意）

### SideObjectTableSO
- entries: SideObjectEntry[]
- varietyBias: float
- cooldown: int（任意）

### SideObjectEntry / SideObjectSO
- SideObjectEntry: sideObject, weight, conditions
- SideObjectSO: id, prefabLeft, prefabRight, eventDefinition

### EncounterTableSO / EncounterSO
- EncounterTableSO: baseRate, entries, cooldown/grace/pity
- EncounterSO: id, eventDefinition（中でLaunchBattleEffectを呼ぶ）

### Event Kernel
- EventDefinitionSO: steps: EventStep[]
- EventStep: dialogue/choices/effects（最小構成）
- ConditionSO: IsMet(GameContext)
- EffectSO: Apply(GameContext)

### GameContext / WalkCounters
- GameContext: PlayersStates参照 + WalkState + flags/counters
- WalkCounters: globalSteps, nodeSteps, trackProgress
- WalkState: currentNodeId, lastExitId など最小情報

## サンプル最小フロー（動作確認用）
### Phase 0用
- Node_A（exitSpawn: Steps=3, exits: Node_Bのみ）
- Node_B（終端）
- 3歩で出口UIが出ることを確認

### Phase 1用
- Node_AにSideObject（石碑）を追加
- EventDefinition: Message表示→SetFlag
- クリックでイベントが実行されることを確認

### Phase 2用
- Node_AのEncounterTableをbaseRate=1.0で固定
- EncounterSOがLaunchBattleEffectを持つ
- 戦闘→復帰ができることを確認

## 既存コード差し替えポイント（最小）
- Walking.cs: WalkStepの起点をAreaControllerに置き換える。
- Stages.cs: 旧データ参照をSO参照に置き換える（移行はPhase 5）。
- WatchUIUpdate: 変更なし（publicメソッドを呼ぶ）。
- PlayersStates: 変更なし（GameContextから参照）。

## 既存データとの関係（差し替えと再利用）
### ステージデータ（Stages.cs / StageData / StageCut / AreaDate）
- 新歩行システムではFlowGraphSO/NodeSO/EdgeSOに置き換える。
- 旧データはPhase 5で移行ツールを作る前提で残す。
- 旧データに依存するUI（MapLine等）は、将来的にNodeのuiHintsに移す。

### サイドオブジェクト（StageCutの左右Prefab）
- 既存Prefabはそのまま再利用できる。
- `_sideObject_Lefts/_sideObject_Rights`はSideObjectTableSOのentriesに移す。
- SideObjectSO側で「左Prefab/右Prefab + EventDefinition」を持たせる。

### 遭遇データ
- StageCutのEncounterRate/EscapeRateはEncounterTableSOへ移す。
- 既存の敵リスト（EnemyList）はEncounterSOの候補へ変換可能。

### 移行の基本方針
- Phase 0〜2は新SOのみで動作確認を進める。
- 旧データは壊さず保持し、移行ツールで段階的に置き換える。

## 追加で具体化が必要な項目
- ID命名規則（nodeId/gateId/exitId/encounterId）。
- 乱数シード管理と再現性の扱い。
- cooldown/grace/pityの数式と初期値。
- 歩数なしリフレッシュのトリガと対象範囲。
- 戦闘結果（Victory/Defeat/Escape）とEffectの結び付け。
- Presenterの最小UI構成（Canvas階層/RectTransform/クリック判定）。

### Phase 3: Gate/Exit/Branch/Rewind
- TrackConfigとGateMarkerを実装。
- 門の解除順序、ループ歩数、resetOnSkipの挙動を確定。
- Gateのスルーは即巻き戻しで処理する。
- ExitSpawnとExitCandidateで分岐選択UIを実装。
- RewindToAnchor/JumpToAnchorのフックを実装。

成果物: 門・出口・分岐・巻き戻しが一貫して動作する。

### Phase 4: 保存・検証・デバッグ
- 進捗、門解除状態、cooldown、variety履歴、乱数シードを保存対象にする。
- グラフ整合性のValidatorを追加。
- ロール結果と遷移ログを残す。

成果物: セーブ再現性と検証が担保される。

### Phase 5: 旧データ移行（任意）
- StageData/StageCut/AreaDateからNodeSOへ変換。
- NowProgress依存をWalkCountersへ置換。

成果物: 既存ステージの一部を新方式に移行できる。

## 受け入れ条件
- 歩行サイクルの更新順序が仕様どおりであること。
- BattleManager/WatchUIUpdate/PlayersStatesを変更せず動作すること。
- 入口は同一シーン内で完結し、UIは既存メソッドを通すこと。
- 分岐は出口アプローチで決定し、歩行フローではAuto遷移を使わないこと。

## 決定事項
- GameContextはPlayersStatesを直接参照する。
- Gateのスルーは即巻き戻しで処理する。
- GraphViewは後回しで、当面Inspector運用とする。
- CentralObjectPresenterのUIは新規に作る。
- 最初のプレイ可能ビルドはPhase 2とし、Phase 0/1/2を中間確認地点にする。

## 将来のエディタ拡張（最終目標）
- UnityのGraphViewでノード編集をできるようにする。
- FlowGraph/Node/Edge/イベント配置を視覚的に操作できる状態を目指す。

## リスクと決定が必要な点
- 巻き戻し時に遭遇やcooldownがどう復元されるか。
- WalkCountersの参照範囲（global/node/track）を各機能でどう使い分けるか。
