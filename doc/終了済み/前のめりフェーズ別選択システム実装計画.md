# 前のめりフェーズ別選択システム 実装計画

## 概要

スキルの前のめり（AggressiveCommit）設定を、**3つのフェーズそれぞれに独立したデフォルト状態＋選択権**を持つ構造に拡張する。
これにより、スキルのRPとしての奥行き（なぜこのフェーズで前に出るのか）をシステム上で表現可能にする。

### 動機（鳩の例）

スキル「鳩」：鳩をけしかける。鳩は僕のえさが好きにすぎないんだ。

- **ストック中の前のめり**：鳩を集めるために前に出て呼び声を響かせる。同時に仲間をかばっている。
- **トリガー中の前のめり**：鳩が集まりきる前に飛び出す覚悟。敵を惑わせている。
- **実行時の前のめり**：一斉にけしかける。当然前に出る。

各フェーズで「なぜ前に出るのか」が異なり、選択可能かどうかもフェーズごとに意味が変わる。

---

## 現状のデータ構造

```csharp
// BaseSkill.AggressiveCommit.cs
public bool IsAggressiveCommit = true;               // 実行時のデフォルト＆ランタイム状態
public bool CanSelectAggressiveCommit = false;        // 実行時にプレイヤー選択可能か
public AggressiveCommitPhase AggressiveCommitPhase;   // Trigger/Stockの固定フラグ（選択不可）
```

**問題点：**
- 実行時だけ `IsDefault + CanSelect` の2軸があり、Trigger/Stockは `有/無` の1軸しかない
- Trigger/Stockの前のめりはスキル設計者が固定で決めるしかない（プレイヤー介入不可）
- 3フェーズの構造が非対称

---

## 新データ構造

### PhaseAggressiveSetting（フェーズ別前のめり設定）

```csharp
[Serializable]
public struct PhaseAggressiveSetting
{
    /// <summary>
    /// このフェーズでデフォルトで前のめりするか。
    /// CanSelect=trueの場合、これはプレイヤーがトグルで変更できるランタイム状態も兼ねる。
    /// </summary>
    public bool isAggressiveCommit;

    /// <summary>
    /// このフェーズの前のめりをプレイヤーが切り替えられるか。
    /// trueならUIにトグルボタンが表示される。
    /// </summary>
    public bool canSelect;
}
```

### BaseSkill上のフィールド（新）

```csharp
public partial class BaseSkill
{
    [Header("前のめり設定")]
    public PhaseAggressiveSetting AggressiveOnExecute  = new() { isAggressiveCommit = true,  canSelect = false };
    public PhaseAggressiveSetting AggressiveOnTrigger  = new() { isAggressiveCommit = false, canSelect = false };
    public PhaseAggressiveSetting AggressiveOnStock    = new() { isAggressiveCommit = false, canSelect = false };
}
```

### 旧フィールドとの対応

| 旧フィールド | 新フィールド | 備考 |
|---|---|---|
| `IsAggressiveCommit` | `AggressiveOnExecute.isAggressiveCommit` | デフォルト値・ランタイム状態兼用 |
| `CanSelectAggressiveCommit` | `AggressiveOnExecute.canSelect` | |
| `AggressiveCommitPhase.HasFlag(Trigger)` | `AggressiveOnTrigger.isAggressiveCommit` | 旧: 固定のみ → 新: 選択可能に |
| `AggressiveCommitPhase.HasFlag(Stock)` | `AggressiveOnStock.isAggressiveCommit` | 同上 |
| *(なし)* | `AggressiveOnTrigger.canSelect` | 新規：トリガー中の前のめり選択権 |
| *(なし)* | `AggressiveOnStock.canSelect` | 新規：ストック中の前のめり選択権 |

### 削除されるもの

- `enum AggressiveCommitPhase`（Trigger/Stockフラグ）→ 各structに吸収
- `bool IsAggressiveCommit` → `AggressiveOnExecute.isAggressiveCommit`
- `bool CanSelectAggressiveCommit` → `AggressiveOnExecute.canSelect`

---

## シリアライズ移行

旧フィールドの値は現在すべてデフォルト値（`IsAggressiveCommit=true`, `CanSelectAggressiveCommit=false`, `AggressiveCommitPhase=None(0)`）。

新structのデフォルト値を旧デフォルトに合わせるため：
- `AggressiveOnExecute = { isAggressiveCommit = true, canSelect = false }` ← 旧 `IsAggressiveCommit=true`
- `AggressiveOnTrigger = { isAggressiveCommit = false, canSelect = false }` ← 旧 Trigger未設定
- `AggressiveOnStock = { isAggressiveCommit = false, canSelect = false }` ← 旧 Stock未設定

**注意**: structのデフォルト初期化子はUnityのシリアライズではSerializeFieldのデフォルト値として保存されない場合がある。`[FormerlySerializedAs]` で旧フィールド名を参照しても型が異なるため移行不可。ただし現在のシリアライズ値がすべてデフォルトのため、Unity再シリアライズ時に新structのデフォルト値が適用され**データロスなし**。

---

## コード変更一覧

### Phase 1: データ構造変更

#### `BaseSkill.AggressiveCommit.cs` — 全面書き換え
- `enum AggressiveCommitPhase` を削除
- `PhaseAggressiveSetting` structを定義
- 旧3フィールド → 新3 structフィールドに置換

#### `BaseSkill.Core.cs:172-174` — InitDeepCopy
```csharp
// 旧
dst.IsAggressiveCommit = IsAggressiveCommit;
dst.CanSelectAggressiveCommit = CanSelectAggressiveCommit;
dst.AggressiveCommitPhase = AggressiveCommitPhase;

// 新
dst.AggressiveOnExecute = AggressiveOnExecute;
dst.AggressiveOnTrigger = AggressiveOnTrigger;
dst.AggressiveOnStock = AggressiveOnStock;
```

### Phase 2: 戦闘ロジック変更

#### `SkillExecutor.cs:104` — スキル実行時の前のめり判定
```csharp
// 旧
if (skill != null && skill.IsAggressiveCommit)

// 新
if (skill != null && skill.AggressiveOnExecute.isAggressiveCommit)
```

#### `BattleFlow.cs:258` — トリガーカウント時の前のめり判定
```csharp
// 旧
if (skill != null && skill.AggressiveCommitPhase.HasFlag(AggressiveCommitPhase.Trigger))

// 新
if (skill != null && skill.AggressiveOnTrigger.isAggressiveCommit)
```

#### `ActionSkipExecutor.cs:17` — ストック時の前のめり判定
```csharp
// 旧
if (skill != null && skill.AggressiveCommitPhase.HasFlag(AggressiveCommitPhase.Stock))

// 新
if (skill != null && skill.AggressiveOnStock.isAggressiveCommit)
```

#### `BaseStates.ReactionSkill.cs:59` — 命中ペナルティの公平性ゲート
```csharp
// 旧
if (skill.CanSelectAggressiveCommit)

// 新: 実行フェーズの選択権をチェック（命中ペナルティは実行時のみ関連）
if (skill.AggressiveOnExecute.canSelect)
```

### Phase 3: UI変更

#### `PlayersUIBindings.cs` — トグルリスト拡張

```csharp
public class AllySkillUILists
{
    public List<ButtonAndSkillIDHold> skillButtons = new();
    public List<ButtonAndSkillIDHold> stockButtons = new();

    [Header("前のめり選択トグルボタンリスト（実行時）")]
    public List<ToggleSingleAndSkillIDHold> aggressiveCommitToggles = new();

    [Header("前のめり選択トグルボタンリスト（トリガー時）")]
    public List<ToggleSingleAndSkillIDHold> aggressiveTriggerToggles = new();

    [Header("前のめり選択トグルボタンリスト（ストック時）")]
    public List<ToggleSingleAndSkillIDHold> aggressiveStockToggles = new();
}
```

#### `AllyClass.cs` — コールバック追加

現在の `OnSkillSelectAggressiveCommitBtnCallBack` は実行フェーズ用。
同様のパターンで Trigger/Stock 用のコールバックを追加：

```csharp
public void OnSkillSelectAggressiveCommitBtnCallBack(int toggleIndex, int skillID)
{
    // → AggressiveOnExecute.isAggressiveCommit を変更（既存）
}

public void OnSkillAggressiveTriggerBtnCallBack(int toggleIndex, int skillID)
{
    var skill = SkillList[skillID];
    if (!skill.AggressiveOnTrigger.canSelect) return;
    skill.AggressiveOnTrigger.isAggressiveCommit = (toggleIndex == 0);
}

public void OnSkillAggressiveStockBtnCallBack(int toggleIndex, int skillID)
{
    var skill = SkillList[skillID];
    if (!skill.AggressiveOnStock.canSelect) return;
    skill.AggressiveOnStock.isAggressiveCommit = (toggleIndex == 0);
}
```

**注意**: `PhaseAggressiveSetting` はstructのため、`skill.AggressiveOnTrigger.isAggressiveCommit = ...` は直接代入できない（structのコピーが返る）。以下のいずれかの対処が必要：

- **案A**: `PhaseAggressiveSetting` を `class` にする → 参照型、直接変更可能
- **案B**: `struct` のまま、setter用メソッドを `BaseSkill` に用意 → `skill.SetAggressiveTrigger(bool value)`
- **案C**: `struct` のまま、一度ローカルにコピーして書き戻す → `var s = skill.AggressiveOnTrigger; s.isAggressiveCommit = true; skill.AggressiveOnTrigger = s;`

**推奨: 案A（classにする）**。理由: ランタイムで頻繁に書き換えるフィールドであり、struct特有の「コピーの罠」を避けるため。ただし `[Serializable] class` はUnityシリアライズではnull問題がある（`new()` で初期化しないとnull）。初期化子で対応可能。

#### `PlayersUIService.cs` — バインド・可視性・画面遷移の3箇所を拡張

**バインド（BindSkillButtons 相当）:**
```csharp
// 既存: aggressiveCommitToggles のバインド
foreach (var toggle in uiSet.SkillUILists.aggressiveCommitToggles)
    toggle.AddToggleFunc(actor.OnSkillSelectAggressiveCommitBtnCallBack);

// 追加: aggressiveTriggerToggles
foreach (var toggle in uiSet.SkillUILists.aggressiveTriggerToggles)
    toggle.AddToggleFunc(actor.OnSkillAggressiveTriggerBtnCallBack);

// 追加: aggressiveStockToggles
foreach (var toggle in uiSet.SkillUILists.aggressiveStockToggles)
    toggle.AddToggleFunc(actor.OnSkillAggressiveStockBtnCallBack);
```

**可視性（UpdateSkillButtonVisibility 2メソッド）:**
```csharp
// 既存ループに加え、Trigger/Stockトグルの可視性も制御
foreach (var hold in uiSet.SkillUILists.aggressiveTriggerToggles)
{
    var skill = actor.SkillList[hold.skillID];
    hold.Interactable(activeSkillIds.Contains(hold.skillID) && (skill?.AggressiveOnTrigger.canSelect ?? false));
}
foreach (var hold in uiSet.SkillUILists.aggressiveStockToggles)
{
    var skill = actor.SkillList[hold.skillID];
    hold.Interactable(activeSkillIds.Contains(hold.skillID) && (skill?.AggressiveOnStock.canSelect ?? false));
}
```

**画面遷移（OnSkillSelectionScreenTransition）:**
```csharp
// Trigger用
foreach (var toggle in uiSet.SkillUILists.aggressiveTriggerToggles.Where(t => ally.ValidSkillIDList.Contains(t.skillID)))
{
    BaseSkill skill = ally.SkillList[toggle.skillID];
    if (skill == null) { Debug.LogError("スキルがありません"); continue; }
    if (!skill.AggressiveOnTrigger.canSelect) { toggle.Interactable(false); continue; }
    toggle.Controller.SetOnWithoutNotify(skill.AggressiveOnTrigger.isAggressiveCommit);
}

// Stock用（同様のパターン）
```

### Phase 4: エディタ変更

#### `BaseSkillEditor.cs` — インスペクタ表示
- 前のめりセクションのフィールド配列を更新
- `PhaseAggressiveSetting` が `[Serializable]` structなら、Unity標準の折りたたみで `isAggressiveCommit` / `canSelect` が表示される
- displayName辞書に各フィールドの日本語名を追加

```
AggressiveOnExecute  → 「前のめり設定（実行時）」
AggressiveOnTrigger  → 「前のめり設定（トリガー時）」
AggressiveOnStock    → 「前のめり設定（ストック時）」
```

---

## UI配置方針

スキル1つにつき、`canSelect = true` のフェーズの数だけトグルボタンが並ぶ（最大3つ）。

```
[鳩]              ← スキルボタン
[前のめり: ON ]   ← AggressiveOnExecute (canSelect=true)
[溜め前のめり: ON] ← AggressiveOnTrigger (canSelect=true)
[蓄積前のめり: OFF] ← AggressiveOnStock (canSelect=true)
```

ラベルはスキル設計者がわかりやすい名前をつける（ToggleSingleControllerの子オブジェクト「ラベル」テキスト）。
`canSelect = false` のフェーズはトグルボタン自体を配置しない（または配置してもグレーアウト）。

---

## 影響を受けるファイル一覧

| ファイル | 変更内容 |
|---|---|
| `BaseSkill.AggressiveCommit.cs` | 全面書き換え（struct定義 + フィールド置換） |
| `BaseSkill.Core.cs:172-174` | InitDeepCopyの前のめりコピー更新 |
| `SkillExecutor.cs:104` | `.IsAggressiveCommit` → `.AggressiveOnExecute.isAggressiveCommit` |
| `BattleFlow.cs:258` | `.HasFlag(Trigger)` → `.AggressiveOnTrigger.isAggressiveCommit` |
| `ActionSkipExecutor.cs:17` | `.HasFlag(Stock)` → `.AggressiveOnStock.isAggressiveCommit` |
| `BaseStates.ReactionSkill.cs:59` | `.CanSelectAggressiveCommit` → `.AggressiveOnExecute.canSelect` |
| `PlayersUIBindings.cs:82-86` | トグルリスト2つ追加 |
| `AllyClass.cs:429` | コールバック2つ追加 + 既存更新 |
| `PlayersUIService.cs` | バインド・可視性・画面遷移に Trigger/Stock 追加 |
| `BaseSkillEditor.cs` | フィールド配列・表示名更新 |

---

## struct vs class の判断

`PhaseAggressiveSetting` を **class** にする場合:
- メリット: `skill.AggressiveOnExecute.isAggressiveCommit = true;` が直接書ける
- デメリット: Unityシリアライズでnullになりうる → フィールド初期化子 `= new()` で対処

`PhaseAggressiveSetting` を **struct** にする場合:
- メリット: 値型でnull問題なし、GC圧力なし
- デメリット: `skill.AggressiveOnX.field = value;` がコンパイルエラー → setter/書き戻しが必要

**推奨**: どちらでもよいが、コールバックでの書き換え頻度を考えると **class** が素直。
ただしBaseSkillの他フィールドとの一貫性（他は素のbool/enum）を考えると **struct + setterメソッド** も選択肢。

→ エハトの好みで決定。

---

## 実行順序

1. `BaseSkill.AggressiveCommit.cs` を書き換え（struct/class定義 + フィールド置換）
2. `BaseSkill.Core.cs` のDeepCopy更新
3. 戦闘ロジック4ファイルの参照更新（コンパイル通す）
4. `AllyClass.cs` にコールバック追加
5. `PlayersUIBindings.cs` にリスト追加
6. `PlayersUIService.cs` のバインド・可視性・遷移更新
7. `BaseSkillEditor.cs` のインスペクタ更新
8. コンパイル確認
9. シリアライズ値の確認（旧値がすべてデフォルトなのでデータロスなし確認のみ）
