# 敵グループ逃走構想書

> **ステータス: ✅ コア実装済み**（2026-03-01）
> 連鎖逃走のフロー統合 + グループ逃走コンビ登録は実装完了。詳細は `doc/友情コンビ登録システム仕様書.md` §3.3 を参照。

## 動機

友情コンビ登録システムでは、戦闘結果ごとに登録倍率を設けている（`doc/友情コンビ登録システム仕様書.md` §3.3）。敵が一緒に逃げた場合は「連帯感」として×2.0の倍率を適用する。

### ~~現状の問題~~ → 解決済み

~~敵が逃走すると `EscapeAndRemove()` でグループから即座に除去される。全員が逃げると `EnemyGroupEmpty = true` になるが、この時点で `EnemyGroup.Ours.Count == 0` であり、コンビ登録の前提条件（2人以上）を満たさない。~~ → 連鎖逃走を1ターン即時解決に統合し、除去前にコンビ登録判定を発火する方式で解決。

---

## 現行の敵逃走メカニクス

### 個別逃走（EscapeACT）

敵AIが逃走を選択 → 50%で成功 → `EscapeAndRemove()` で1体ずつグループから除去。

### 連鎖逃走（CollectChainEscapers） ✅フロー統合済み

1体が逃走成功した後、残りの敵に対して連鎖判定:

1. **相性値ベース**: 逃げた敵との相性値 ≥ 77 なら無条件で連鎖
2. **精神属性ベース**: 属性ごとの逃走率で確率判定（Psycho: 100%, Kindergarten: 80%, ... Sacrifaith: 5%）

~~連鎖対象は次ターン開始時に `DominoEscapeACT()` で一括除去される。~~ → 連鎖判定→除去を `EscapeACT()` 内で即時完結。`DominoEscapeACT()` は廃止。

実装: `EscapeHandler.cs`

---

## 構想: 連鎖逃走をグループ逃走として再解釈する

### 方針転換

当初は「グループ逃走」を連鎖逃走とは別の新メカニクスとして構想していたが、検討の結果、**既存の連鎖逃走の結果を「グループ逃走」と見なす**方が自然であるという結論に至った。

理由:
- 連鎖逃走で全員逃げた = 「みんなで逃げ出した」。これはそのままグループ逃走の定義に合致する
- 新メカニクスを作ると、連鎖逃走との機能的な重複が生じる
- 連鎖逃走の「1人が逃げたら仲間もつられて逃げる」という演出は、グループの絆を表現するものとして自然

### グループ逃走の判定

`DominoEscapeACT()` の実行直前が判定ポイント。この時点での状態:

- 最初の1体（A）は既に `EscapeAndRemove()` で除去済み（参照は `VoluntaryRunOutEnemy` に保存）
- 連鎖逃走対象（B, C, ...）は `DominoRunOutEnemies` リストにいて、まだ `Ours` に残っている

```
例: 3体グループ [A, B, C]

A「逃げる」→ 成功 → EscapeAndRemove(A)
  ↓
GetRunOutEnemies(A) → 連鎖判定
  ↓
┌──────────────────────────────────────────────────┐
│ DominoEscapeACT() 直前の状態:                      │
│   Ours = [B, C]                                   │
│   DominoRunOutEnemies = [B, C]  ← 全員連鎖        │
│   VoluntaryRunOutEnemy = A                         │
│                                                    │
│   → DominoRunOutEnemies == Ours → グループ逃走！    │
│   → コンビ登録判定（×2.0）を挟める                    │
└──────────────────────────────────────────────────┘
  ↓
DominoEscapeACT() → B, C を除去 → Ours.Count == 0 → EnemyGroupEmpty
```

### パターン別の判定

グループ逃走の条件: **連鎖逃走者が2人以上**。全員が逃げたかどうかは問わない。

| 状況 | 連鎖者 | 残存 | グループ逃走？ | 戦闘 |
|---|---|---|---|---|
| A逃走 → B,C連鎖 | [B, C] | 0 | **Yes**（×2.0） | 終了 |
| A逃走 → B,C連鎖、D残る | [B, C] | D | **Yes**（×2.0） | 続行 |
| A逃走 → Bのみ連鎖 | [B] | C残る | No | 続行 |
| A逃走 → 連鎖なし | [] | B,C残る | No | 続行 |
| 2体: A逃走 → B連鎖 | [B] | 0 | **微妙** | 下記で議論 |

**戦闘続行ケースでの登録**: 連鎖者が2人以上いても全員が逃げたわけではない場合、戦闘は続行する。しかし逃げた敵は除去されて戻らないため、**逃げた瞬間にコンビ登録する**しかない。従来の `OnBattleEnd` での登録とは異なり、**戦闘中にコンビ登録が発生する**新しいパターンとなる。

### コンビ登録対象は誰か

**案1: 連鎖逃走者のみ（推奨）**

最初に逃げたA = 「自分の判断で逃げた」個人行動。
連鎖で逃げたB, C = 「仲間が逃げたからつられて逃げた」連帯行動。

「一緒に逃げた」の絆はB, Cに生まれる。Aは含めない。

- メリット: 「連帯感」の意味が明確
- デメリット: 2体グループの場合、連鎖者が1人しかいないのでコンビにならない（Count < 2）

**案2: 最初の逃走者も含める**

A, B, C 全員が「このグループで一緒に逃げた」と見なす。

- メリット: 2体グループでも成立する
- デメリット: Aは自発的に逃げただけで「連帯」とは言いにくい

### 2体グループ問題

案1だと2体グループ [A, B] で A逃走 → B連鎖 のケースで、連鎖者はBだけ（1人）なのでコンビ登録できない。

対処案:
- **2体の場合は最初の逃走者も含める**（2体で全員逃げた = 一緒に逃げた、と特例で見なす）
- **2体は諦める**（3体以上でないとグループ逃走は成立しない）
- **案2を採用する**（常に全員含める）

---

## 実装に必要な変更

### 最大の変更: 連鎖逃走のフロー統合

現在の連鎖逃走は **2ターンに分裂** している:

```
【現行: 2ターン分裂】
ターンN:   Aの行動 → 逃走成功 → A除去 → 連鎖リスト作成 → ターン終了
ターンN+1: DominoEscapeACT() → 連鎖者を除去 → ターン終了
```

これを **1ターン内で一気に解決** する形に変更する:

```
【目標: ひとつなぎ】
ターンN: Aの行動 → 逃走成功 → 連鎖判定 →
  残り全員が連鎖した？
    → Yes → グループ逃走: [コンビ登録判定(×2.0)] → A含む全員を一括除去
    → No  → A除去 + 連鎖者も即除去 → 残った敵で戦闘続行
```

#### 必要な変更

1. **`EscapeACT()` の統合**: 個別逃走成功後、連鎖判定→連鎖除去を同一メソッド内で完結させる
2. **`DominoEscapeACT()` の廃止**: 別ターンでの連鎖処理を廃止。`DominoRunOutEnemies` キューも不要に
3. **`BattleFlow` の分岐削除**: `DominoRunOutEnemies.Count > 0` で次ターンに飛ばすフロー（`BattleFlow.cs:208-211`, `TurnExecutor.cs:47-49`）を削除
4. **最初の逃走者の除去タイミング変更**: Aも連鎖判定が終わるまで除去を遅延させる（グループ逃走判定に含めるため）

#### EscapeACT の新フロー

```csharp
// EscapeHandler.EscapeACT() — 敵逃走の場合
if (逃走成功)
{
    // 1. 連鎖判定（除去はまだしない）
    var chainEscapers = GetRunOutEnemies(逃走者);

    // 2. グループ逃走判定: 連鎖者が2人以上いれば発動
    if (chainEscapers.Count >= 2)
    {
        // グループ逃走！ コンビ登録判定（×2.0）
        // 連鎖者はまだ Ours にいるのでシグナル収集・GUID取得が可能
        TriggerGroupEscapeComboRegistration(chainEscapers);
    }

    // 3. 逃走者 + 連鎖者を一括除去
    EscapeAndRemove(逃走者);
    foreach (var enemy in chainEscapers)
        EscapeAndRemove(enemy);

    // 残りがいれば戦闘続行、いなければ EnemyGroupEmpty
}
```

### コンビ登録の接続

**問題: EscapeHandler は BattleManager / ComboRegistry を知らない**

対処案:
- `BattleActionContext` 経由で `ComboRegistry` を渡す（`EnemyGroup`, `AllyGroup` は既にcontextにある）
- または: `EscapeHandler` にコールバック `Action<List<NormalEnemy>> OnGroupEscape` を追加し、`BattleManager` 側でフックする（疎結合）

### `GetOutcomeMultiplier()` との関係

グループ逃走のコンビ登録は `EscapeACT` 内で**逃走と同時に**処理される。通常の `OnBattleEnd → TryRegisterFriendshipCombo` のフローとは別経路。

`GetOutcomeMultiplier()` の `EnemyGroupEmpty` 分岐（現在×1.3）は、グループ逃走実装後は不要。削除するか、グループ逃走実装までの暫定として残す。

---

## 未決事項

- [x] コンビ登録対象に最初の逃走者を含めるか → **全逃走者（自発+連鎖）を含める**。「一緒に逃げた全員」がコンビ対象
- [x] 2体グループの扱い → 条件を「連鎖者≥1（合計2人以上逃走）」に変更し解決。2体でも成立
- [x] `ComboRegistry` の渡し方 → **コールバック方式採用**: `EscapeHandler` に `Action<List<NormalEnemy>> onGroupEscape` を注入
- [ ] 連鎖逃走の確率バランス（全連鎖の発生頻度が適切か）
- [ ] グループ逃走時の演出（メッセージ差し替え等）
- [x] 最初の逃走者の除去タイミング → 最初の逃走者は先に除去。連鎖者は除去前にコンビ登録判定

---

## 備考

- 新メカニクスの追加ではなく、**既存の連鎖逃走を再解釈する**アプローチ。コード変更量は最小限
- 連鎖逃走で全員（or 2人以上）が逃げること自体が稀なので、グループ逃走→コンビ登録は貴重なイベントになる。×2.0倍率の価値がある
- 実装優先度は友情コンビシステムの基本フロー完成後
