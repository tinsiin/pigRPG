# 中央オブジェクト抽選システム実装計画

**ステータス: ✅ 完了**

## 概要

現在の中央オブジェクトは NodeSO に固定で埋め込まれているが、サイドオブジェクトと同様に**テーブルから抽選する方式**に変更する。

## 背景・動機

### 現状の問題

```
現在のNodeSO:
├── sideObjectTable: SideObjectTableSO  ← 抽選テーブル（複数候補から選ぶ）
├── centralVisual: CentralObjectVisual  ← 固定（1つだけ）
└── centralEvent: EventDefinitionSO     ← 固定（1つだけ）
```

**問題点:**
- 1つのNodeで1つの中央オブジェクトしか設定できない
- ステージで常に同じイベントしか発生しない
- サイドオブジェクトは抽選なのに、中央オブジェクトだけ固定は設計の不整合

### 期待する状態

```
修正後のNodeSO:
├── sideObjectTable: SideObjectTableSO    ← 抽選テーブル
├── centralObjectTable: CentralObjectTableSO  ← 抽選テーブル（新規）
└── fixedCentralObject: CentralObjectSO   ← ノード入場時固定（オプション）
```

### 関連機能：3者会話構図

この抽選システムは [3者会話構図設計.md](../ノベルパート/3者会話構図設計.md) の前提となる。

```
抽選で中央オブジェクトが選ばれる
    ↓
ユーザーがアプローチ
    ↓
ズームイン（演出ズーム）
    ↓
ノベルパート開始（3者会話構図）
    ↓
会話中に中央オブジェクトのスプライト変更可能  ← 3者会話構図設計の範囲
```

つまり:
- **本計画**: 「どの中央オブジェクトが出現するか」の抽選
- **3者会話構図**: 「会話中に中央オブジェクトの見た目をどう変えるか」

---

## 設計方針

### サイドオブジェクトとの構造対比

| 項目 | サイドオブジェクト | 中央オブジェクト（新規） |
|------|------------------|------------------------|
| テーブルSO | SideObjectTableSO | CentralObjectTableSO |
| エントリ | SideObjectEntry | CentralObjectEntry |
| オブジェクトSO | SideObjectSO | CentralObjectSO |
| 抽選ロジック | SideObjectSelector | CentralObjectSelector |
| 出現数 | 左右ペア（2個） | 単体（1個） |
| Prefab | prefabLeft/prefabRight | なし（Visual構造体で表現） |

### 中央オブジェクト固有の特性

サイドオブジェクトと異なる点:
1. **単体抽選**: 左右ペアではなく1つだけ選ぶ
2. **Visual構造体**: Prefabではなく `CentralObjectVisual` で見た目を定義（Sprite方式を維持）
3. **ズーム連携**: 選ばれた中央オブジェクトにズームしてノベルパートを開始できる
4. **アニメーション方向**: サイドは左右から登場/退場、中央はその場で登場/真上へ退場

### サイドオブジェクトとの見た目定義の違い

| 項目 | サイドオブジェクト | 中央オブジェクト |
|------|------------------|----------------|
| 見た目定義 | Prefab (GameObject) | Visual構造体 (Sprite) |
| 描画方式 | UILineRenderer（プログラム描画） | Image（Sprite表示） |
| 配置情報 | SideObjectMove内に埋め込み | Visual構造体で直接指定 |
| アニメーション | SideObjectMove（左右から登場、左右へ退場） | CentralObjectMove（中央で登場、**左右へ退場**） |

**→ Sprite + Visual構造体方式を維持し、アニメーションは専用MonoBehaviour（CentralObjectMove）で実装**

---

## データ構造

### 1. CentralObjectSO（新規）

```csharp
[CreateAssetMenu(menuName = "Walk/CentralObject")]
public sealed class CentralObjectSO : ScriptableObject
{
    [SerializeField] private string id;
    [SerializeField] private string uiLabel;
    [SerializeField] private CentralObjectVisual visual;
    [SerializeField] private EventDefinitionSO eventDefinition;

    public string Id => id;
    public string UILabel => string.IsNullOrEmpty(uiLabel) ? id : uiLabel;
    public CentralObjectVisual Visual => visual;
    public EventDefinitionSO EventDefinition => eventDefinition;
}
```

### 2. CentralObjectTableSO（新規）

```csharp
[CreateAssetMenu(menuName = "Walk/CentralObject Table")]
public sealed class CentralObjectTableSO : ScriptableObject
{
    [SerializeField] private CentralObjectEntry[] entries;
    [SerializeField] private float varietyBias = 0.5f;
    [Tooltip("Number of recent picks to track for variety bias. 0 = disabled.")]
    [SerializeField] private int varietyDepth;

    public CentralObjectEntry[] Entries => entries;
    public float VarietyBias => varietyBias;
    public int VarietyDepth => varietyDepth;
}
```

### 3. CentralObjectEntry（新規）

```csharp
[Serializable]
public sealed class CentralObjectEntry
{
    [SerializeField] private CentralObjectSO centralObject;
    [SerializeField] private float weight = 1f;
    [SerializeField] private ConditionSO[] conditions;
    [Tooltip("Steps before this can appear again after selection. 0 = no cooldown.")]
    [SerializeField] private int cooldownSteps;

    public CentralObjectSO CentralObject => centralObject;
    public float Weight => weight;
    public ConditionSO[] Conditions => conditions;
    public int CooldownSteps => cooldownSteps;
}
```

### 4. NodeSO の変更

```csharp
// 削除
// [SerializeField] private EventDefinitionSO centralEvent;
// [SerializeField] private CentralObjectVisual centralVisual;

// 追加
[SerializeField] private CentralObjectTableSO centralObjectTable;
[SerializeField] private CentralObjectSO fixedCentralObject;  // ノード入場時固定（オプション）

public CentralObjectTableSO CentralObjectTable => centralObjectTable;
public CentralObjectSO FixedCentralObject => fixedCentralObject;
```

---

## 抽選ロジック

### CentralObjectSelector（新規）

サイドオブジェクトの `SideObjectSelector` をベースに、単体抽選版を実装。

```csharp
public sealed class CentralObjectSelector
{
    private readonly VarietyHistory varietyHistory = new();
    private readonly CentralObjectCooldownTracker cooldownTracker = new();

    public void Configure(int varietyDepth)
    {
        varietyHistory.MaxDepth = varietyDepth;
    }

    /// <summary>
    /// 中央オブジェクトを1つ抽選する。
    /// </summary>
    public CentralObjectEntry Roll(
        CentralObjectTableSO table,
        NodeSO node,
        GameContext context,
        bool isNodeEntry = false)
    {
        if (table == null) return null;

        // ノード入場時の固定中央オブジェクト
        if (isNodeEntry && node?.FixedCentralObject != null)
        {
            return FindEntryByCentralObject(table, node.FixedCentralObject);
        }

        // 通常の重み付き抽選
        return PickWithFilters(table, context);
    }

    public void OnCentralObjectSelected(CentralObjectEntry selected, int cooldownSteps)
    {
        if (selected?.CentralObject == null) return;

        var id = selected.CentralObject.Id;
        varietyHistory.Record(id);

        if (cooldownSteps > 0)
        {
            cooldownTracker.StartCooldown(id, cooldownSteps);
        }
    }

    public void AdvanceStep()
    {
        cooldownTracker.AdvanceStep();
    }

    public void Reset()
    {
        varietyHistory.Clear();
        cooldownTracker.Clear();
    }

    // 状態保存/復元メソッド（省略）

    private CentralObjectEntry PickWithFilters(CentralObjectTableSO table, GameContext context)
    {
        // SideObjectSelector.PickWithFilters と同じロジック
        // - 条件評価
        // - クールダウンチェック
        // - バラエティバイアス適用
        // - 重み付き抽選
    }
}
```

---

## AreaController の変更

### 変更前

```csharp
var centralEvent = currentNode.CentralEvent;
var hasCentral = centralEvent != null || currentNode.CentralVisual.HasVisual;
```

### 変更後

```csharp
// 中央オブジェクト抽選
var centralEntry = centralObjectSelector.Roll(
    currentNode.CentralObjectTable,
    currentNode,
    context,
    isNodeEntry: isNodeEntry);

var centralEvent = centralEntry?.CentralObject?.EventDefinition;
var centralVisual = centralEntry?.CentralObject?.Visual ?? default;
var hasCentral = centralEntry != null;
```

### ShowApproachObjects の変更

```csharp
private void ShowApproachObjects(SideObjectEntry[] sidePair, CentralObjectEntry centralEntry)
{
    sidePresenter?.Show(sidePair);

    if (centralEntry != null)
    {
        centralPresenter?.Show(centralEntry.CentralObject.Visual, forceShow: true);
    }
    else
    {
        centralPresenter?.Hide();
    }
}
```

---

## アニメーション

サイドオブジェクトと同様にLitMotionを使用したアニメーションを実装する。

### サイドオブジェクトとの比較

| 項目 | サイドオブジェクト | 中央オブジェクト |
|------|------------------|----------------|
| 登場方向 | 左右から画面内へスライド | **その場で**（位置移動なし） |
| 登場演出 | 位置+透明度+スケール+回転 | **透明度+スケール**のみ |
| 退場方向 | 左右へ捌ける（2段階移動） | **左右へ**捌ける（2段階移動、ランダム方向） |
| 退場演出 | 位置移動のみ | 位置移動+透明度フェード |

### フェードアウト方向（最終仕様）

**仕様:**
- 方向はランダム（右下 or 左下）
- 終了位置：現在位置から斜め下へ移動（X方向±480px、Y方向-240px）
- 透明度：**移動開始と同時にフェードアウト開始**（早めに消える）
- フェード完了：移動完了より先に透明になる

### CentralAnimConfig（修正）

```csharp
[Serializable]
public struct CentralAnimConfig
{
    [Header("フェードイン")]
    public float FadeInDuration;      // 0.3f
    public float FadeInStartScale;    // 0.8f
    public Ease FadeInEase;           // OutBack

    [Header("フェードアウト")]
    public float FadeOutDuration;     // 0.3f（1段階あたり）
    public float FadeOutMidX;         // 200f（中間点X距離）
    public float FadeOutMidY;         // 50f（中間点Y距離）
    public float FadeOutEndX;         // 200f（終点X距離、中間点からの追加）
    public float FadeOutEndY;         // 50f（終点Y距離、中間点からの追加）
    public Ease FadeOutEase;          // InQuad

    public static CentralAnimConfig Default => new CentralAnimConfig
    {
        FadeInDuration = 0.3f,
        FadeInStartScale = 0.8f,
        FadeInEase = Ease.OutBack,
        FadeOutDuration = 0.25f,
        FadeOutMidX = 320f,     // 横に移動
        FadeOutMidY = -160f,    // 下に移動（負の値）
        FadeOutEndX = 160f,     // さらに横に
        FadeOutEndY = -80f,     // さらに下に
        FadeOutEase = Ease.InQuad
    };
}
```

### CentralObjectMove（MonoBehaviour）

SideObjectMoveと同じMonoBehaviourパターンを採用。
- Start()でフェードインが自動開始
- FadeOut()でフェードアウト→Destroy

```csharp
using Cysharp.Threading.Tasks;
using LitMotion;
using LitMotion.Extensions;
using RandomExtensions;
using UnityEngine;
using UnityEngine.UI;

public class CentralObjectMove : MonoBehaviour
{
    // フェードイン設定
    private float fadeInDuration = 0.3f;
    private float fadeInStartScale = 0.8f;
    private Ease fadeInEase = Ease.OutBack;

    // フェードアウト設定（2段階移動、左右ランダム）
    private float fadeOutDuration = 0.3f;
    private float fadeOutMidX = 200f;
    private float fadeOutMidY = 50f;
    private float fadeOutEndX = 200f;
    private float fadeOutEndY = 50f;
    private Ease fadeOutEase = Ease.InQuad;

    private int fadeInEndCount = 0;
    private int direction; // 1 = 右, -1 = 左

    public void Configure(CentralAnimConfig config) { ... }

    private void Start()
    {
        // 方向をランダムで決定
        direction = RandomEx.Shared.NextBool() ? 1 : -1;

        // フェードイン開始（透明度+スケール）
        // fadeInEndCount++ でフェードイン完了を記録
    }

    public async UniTask FadeOut()
    {
        await UniTask.WaitUntil(() => fadeInEndCount >= 2);

        // 第1段階: 現在位置 → 中間位置
        var midPos = startPos + new Vector2(fadeOutMidX * direction, fadeOutMidY);
        // 位置アニメーション...
        await UniTask.WaitUntil(() => end);

        // 第2段階: 中間位置 → 終了位置（フェードアウト付き）
        var endPos = midPos + new Vector2(fadeOutEndX * direction, fadeOutEndY);
        // 位置+透明度アニメーション...
        await UniTask.WaitUntil(() => end);

        Destroy(gameObject);
    }
}
```

### 視覚的イメージ

```
【フェードイン】
    ○ スケール0.8 + 透明
    ↓ (徐々に大きく＋不透明に、OutBackでポップに)
    ● スケール1.0 + 不透明

【フェードアウト】（右下 or 左下へ移動、早めにフェードアウト）
    ● 現在位置 (0, 0)
    ↘ or ↙ (ランダムで右下/左下どちらかへ移動開始)
    ○ (移動と同時にフェードアウト開始)
    × 終了位置 (±480, -240) → Destroy

【タイミング】
- 移動: 0.5秒かけて終了位置まで移動
- フェード: 0.25秒で透明に（移動完了より先に消える）
```

### CentralObjectPresenter への統合

SideObjectPresenterと同じパターンを採用:
- FadeOutCurrent(): 古いオブジェクトをフェードアウト開始（待たない）
- CreateAnimatedViewObject(): 新しいオブジェクトを作成（CentralObjectMoveを追加）

```csharp
public sealed class CentralObjectPresenter
{
    private CentralAnimConfig animConfig = CentralAnimConfig.Default;

    public void ShowWithAnimation(CentralObjectVisual visual, bool forceShow)
    {
        // 1. 古いオブジェクトをフェードアウト（待たない）
        FadeOutCurrent();

        if (!forceShow) return;

        // 2. 新しいオブジェクトを作成
        viewObject = CreateAnimatedViewObject(visual);
    }

    private void FadeOutCurrent()
    {
        if (viewObject == null) return;

        var mover = viewObject.GetComponent<CentralObjectMove>();
        var oldRect = viewObject.GetComponent<RectTransform>();

        // 参照をクリア
        viewObject = null;

        if (mover != null)
        {
            // 最前面に移動（新しいオブジェクトの上に表示）
            oldRect?.SetAsLastSibling();
            // Fire-and-forget
            mover.FadeOut().Forget();
        }
    }

    private GameObject CreateAnimatedViewObject(CentralObjectVisual visual)
    {
        // GameObjectを作成
        var obj = new GameObject("CentralObject", ...);
        // ...設定...

        // CentralObjectMoveを追加（Start()で自動フェードイン）
        if (useAnimation && animConfig.IsValid)
        {
            var mover = obj.AddComponent<CentralObjectMove>();
            mover.Configure(animConfig);
        }

        return obj;
    }
}
```

---

## 状態管理

### CentralObjectState（新規）

```csharp
[Serializable]
public sealed class CentralObjectState
{
    public List<string> VarietyHistory;
    public Dictionary<string, int> Cooldowns;

    // コンストラクタ、Import/Export省略
}
```

### GameContext への追加

```csharp
// GameContext.cs に追加
public CentralObjectSelector CentralObjectSelector { get; } = new CentralObjectSelector();
```

### WalkProgressData への追加

```csharp
// 保存/復元対象に追加
public CentralObjectState CentralObjectState { get; set; }
```

---

## 実装フェーズ

### Phase 1: データ構造 ✅

- [x] CentralObjectSO 作成
- [x] CentralObjectEntry 作成（CentralObjectTableSO.cs 内に定義）
- [x] CentralObjectTableSO 作成
- [x] NodeSO 変更（centralEvent/centralVisual を削除、centralObjectTable/fixedCentralObject を追加）

### Phase 2: 抽選ロジック ✅

- [x] CentralObjectCooldownTracker 作成（SideObjectCooldownTracker を参考）
- [x] CentralObjectSelector 作成
- [x] CentralObjectState 作成

### Phase 3: アニメーション ✅

- [x] CentralAnimConfig 構造体作成
- [x] CentralObjectAnimator クラス作成
- [x] CentralObjectPresenter に ShowAsync/HideAsync 追加
- [x] CentralObjectPresenter に Animator 統合

### Phase 4: AreaController 統合 ✅

- [x] AreaController に centralObjectSelector 追加
- [x] WalkStep() で中央オブジェクト抽選処理追加
- [x] ShowApproachObjects() シグネチャ変更
- [x] HandleEncounterOutcome() 変更
- [x] 旧方式（centralEvent/centralVisual直接参照）を完全削除

### Phase 5: 状態保存/復元 ✅

- [x] WalkProgressData に CentralObjectState 追加
- [x] GameContext に CentralObjectSelector 追加
- [x] 保存/復元処理追加

---

## テスト項目

- [x] 中央オブジェクトが抽選で出現すること
- [x] 条件付き中央オブジェクトが正しくフィルタリングされること
- [x] クールダウンが機能すること
- [x] バラエティバイアスが機能すること
- [x] ノード入場時の固定中央オブジェクトが機能すること
- [x] アプローチ→イベント実行→ズームの一連の流れが動作すること
- [x] 状態の保存/復元が正しく動作すること
- [x] フェードインアニメーションが正しく再生されること（透明度+スケール）
- [x] フェードアウト（右下/左下ランダムへ移動、早めにフェードアウト）アニメーションが正しく再生されること
- [x] 連続で歩行ボタンを押したとき、古いオブジェクトが捌けながら新しいオブジェクトが出現すること
- [x] ゲート/出口表示時の即座切替（アニメーションなし）が動作すること

---

## 関連ドキュメント

- [ゼロトタイプ歩行システム設計書.md](./ゼロトタイプ歩行システム設計書.md) - 歩行システム全体設計
- [3者会話構図設計.md](../ノベルパート/3者会話構図設計.md) - ノベルパート中のスプライト変更
- [ノベルパート設計.md](../ノベルパート/ノベルパート設計.md) - ノベルパート全体設計

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-30 | 初版作成 |
| 2026-01-30 | アニメーションセクション追加（LitMotion使用、フェードイン/フェードアウト） |
| 2026-01-30 | 実装完了、Phase 6（データ移行）を計画から削除、後方互換性なし |
| 2026-01-30 | フェードアウト方向を「真上へ」から「左右ランダムへ」に変更（サイドオブジェクトと統一） |
| 2026-01-30 | CentralObjectAnimatorクラスを削除、CentralObjectMove（MonoBehaviour）に統合 |
| 2026-01-30 | フェードアウトを「右下/左下へ移動＋早めにフェードアウト」に変更、全テスト項目完了 |
| 2026-01-30 | **✅ 実装完了、終了済みフォルダへ移動** |
