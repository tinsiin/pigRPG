# 新キャラクター追加システム設計

> **ステータス: 実装完了** (2026-01-28)

## 実装完了サマリー

| Phase | 内容 | 状態 |
|-------|------|------|
| A | CharacterDataSO / CharacterDataRegistry | ✅ 完了 |
| B | CharacterUnlockEffect | ✅ 完了 |
| C | PlayersRuntime CharacterDataRegistry対応 + 初回OnEnter自動発火 | ✅ 完了 |
| D | UI層のCharacterId対応 | ✅ 完了 |
| E | CharaconfigController対応 | ✅ 完了 |
| F | セーブ/ロード対応 | ✅ 完了 |
| G | ノベルパート主人公設定のCharacterId化 | ✅ 完了 |
| H | クリーンアップ（段階的廃止） | ✅ 完了 |

### 主要な実装ファイル

**新規作成:**
- `Assets/Script/Players/CharacterDataSO.cs` - キャラクターデータ定義SO
- `Assets/Script/Players/CharacterDataRegistry.cs` - SO管理レジストリ
- `Assets/Script/Walk/Effects/CharacterUnlockEffect.cs` - キャラクター解放Effect
- `Assets/Script/Walk/Effects/PartySetEffect.cs` - パーティー一括設定Effect
- `Assets/Script/Players/UI/CharacterUIRegistry.cs` - CharacterId→UI参照マッピング

**修正:**
- `Assets/Script/Players/PlayersRuntime.cs` - CharacterDataRegistry対応
- `Assets/Script/Walk/AreaController.cs` - 新規ゲーム時OnEnter自動発火
- `Assets/Script/Walk/WalkingSystemManager.cs` - 初回OnEnter発火処理
- `Assets/Script/Players/PlayersUIService.cs` - CharacterId対応
- `Assets/Script/Battle/UI/BattleUIBridge.cs` - CharacterId対応
- `Assets/Script/Toggle/TabCharaStateContent.cs` - CharacterId対応
- `Assets/Script/USERUI/CharaconfigController.cs` - CharacterId対応
- `Assets/Script/Players/PlayersSaveService.cs` - 新キャラ復元対応
- `Assets/Script/Walk/Dialogue/DialogueContext.cs` - ProtagonistCharacterId追加
- `Assets/Script/Walk/EventKernel/Steps/NovelDialogueStep.cs` - CharacterId対応
- `Assets/Script/UIStateHub.cs` - SelectedCharacterId追加
- `Assets/Script/Toggle/TabContents.cs` - SkillUICharaState Obsolete化

---

## 1. 現状の課題

パーティー管理システム（方針C）は実装済みだが、以下が未定義/未対応：

| 項目 | 状態 |
|------|------|
| 新キャラのデータ定義 | ✅ CharacterDataSO |
| 新キャラの解放タイミング | ✅ CharacterUnlockEffect |
| 新キャラの初期化処理 | ✅ CharacterDataRegistry経由 |
| **UI層の動的対応** | ✅ CharacterUIRegistry + CharacterId対応 |

---

## 2. 現状のUI構造と問題点

### 2.1 SkillObject（バトル中スキルUI）

```
USERUI/PlayerContent/SkillObject (TabCharaStateContent)
├── geino    ← Geino専用UI（GameObject）
├── sites    ← Sites専用UI（GameObject）
└── normalia ← Noramlia専用UI（GameObject）
```

**問題:** 3人分のGameObjectがハードコードされており、新キャラ用の枠がない。

```csharp
// TabCharaStateContent.cs（現状）
public class TabCharaStateContent : MonoBehaviour
{
    [SerializeField] GameObject geino;
    [SerializeField] GameObject sites;
    [SerializeField] GameObject normalia;

    public void SwitchContent(SkillUICharaState state)
    {
        switch (state)
        {
            case SkillUICharaState.geino:
                geino.SetActive(true);
                sites.SetActive(false);
                normalia.SetActive(false);
                break;
            // ...
        }
    }
}
```

### 2.2 AllyUISet（キャラごとのUI参照）

```csharp
// PlayersUIRefs.cs（現状）
public AllyUISet[] AllyUISets = new AllyUISet[PlayersConstants.AllyCount]; // 3固定
```

**問題:** 配列サイズが3固定。

### 2.3 SkillUICharaState

```csharp
// TabContents.cs（現状）
public enum SkillUICharaState { geino, sites, normalia }
```

**問題:** enumで固定3人を定義。新キャラを追加できない。

### 2.4 CharaconfigController

```csharp
// CharaconfigController.cs（現状）
private AllyClass GetActor(int index)
{
    return playersRoster.GetAllyById((AllyId)index) as AllyClass;
}
```

**問題:** `AllyId`（0,1,2）でアクセス。新キャラは`AllyId`に存在しない。

---

## 3. Effectシステムの現状

### 3.1 構造

```
EffectSO (abstract ScriptableObject)
└─ Apply(GameContext) : UniTask
```

### 3.2 既存Effect一覧

| Effect | 説明 |
|--------|------|
| SetFlagEffect | フラグ設定 |
| SetCounterEffect | カウンター設定 |
| AddTagEffect / RemoveTagEffect | タグ追加/削除 |
| LaunchBattleEffect | バトル開始 |
| RestPartyEffect | パーティー回復 |
| ApplyStageBonusEffect | ステージボーナス適用 |
| ShowMessageEffect | メッセージ表示 |
| CreateAnchorEffect / RewindToAnchorEffect | アンカー作成/巻き戻し |
| PushEncounterOverlayEffect / RemoveEncounterOverlayEffect | エンカウント倍率変更 |
| ShowPortraitEffect / HidePortraitEffect | 立ち絵表示/非表示 |
| ShowBackgroundEffect / HideBackgroundEffect | 背景表示/非表示 |
| PlayNoiseEffect | ノイズ再生 |
| SwitchDisplayModeEffect | 表示モード切替 |
| **PartyMemberEffect** | パーティー追加/除外（実装済み） |
| **CharacterUnlockEffect** | キャラクター解放（新規実装） |
| **PartySetEffect** | パーティー一括設定（新規実装） |

### 3.3 Effectの発火タイミング

```
┌─────────────────────────────────────────────────────────┐
│ EventDefinitionSO                                       │
│  ├─ steps: IEventStep[]                                 │
│  │   ├─ EffectStep.effects[]      ← ステップ内で即時   │
│  │   ├─ MessageStep.effects[]     ← メッセージ後      │
│  │   ├─ DialogueStep.effects[]    ← ダイアログ後      │
│  │   └─ EventChoice.effects[]     ← 選択肢選択時      │
│  └─ terminalEffects[]             ← イベント完了後    │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ GateMarker（ノード内ゲート）                            │
│  ├─ onPass[]                      ← ゲート通過時       │
│  └─ onFail[]                      ← ゲート失敗時       │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ NodeSO.onEnterEvent               ← ノード進入時       │
│  ※ 新規ゲーム開始時は自動発火                          │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 新キャラクター追加の設計

### 4.1 データ定義: CharacterDataSO

固定3人も新キャラも同じ `CharacterDataSO` で定義する。

```csharp
[CreateAssetMenu(menuName = "pigRPG/Character Data")]
public class CharacterDataSO : ScriptableObject
{
    [Header("基本情報")]
    [SerializeField] private string characterId;       // "geino", "newchar1" etc.
    [SerializeField] private string characterName;     // 表示名
    // ※ isOriginalMember フィールドは不要
    // → CharacterId.IsOriginalMember で判定（ID文字列で自動判定）

    [Header("初期ステータス")]
    [SerializeField] private float initialHP;
    [SerializeField] private float initialMaxHP;
    [SerializeField] private float initialMentalHP;
    [SerializeField] private int initialP;
    [SerializeField] private int initialMaxP;
    [SerializeField] private SpiritualProperty defaultImpression;
    [SerializeField] private ThePower initialPower;

    [Header("スキル")]
    [SerializeField] private List<AllySkill> skills;
    [SerializeField] private List<int> initialValidSkillIds;
    [SerializeField] private int emotionalAttachmentSkillId;

    [Header("十日能力初期値")]
    [SerializeField] private List<TenDayValueEntry> tenDayValues;

    [Header("ビジュアル設定")]
    [SerializeField] private Sprite portrait;               // 立ち絵
    [SerializeField] private Sprite bannerBackground;       // StatesBanner背景

    // ※ UI参照（SkillUIObject, AllyUISet）はここに持たない
    // → CharacterUIRegistry（シーン側MonoBehaviour）で管理

    // === プロパティ ===

    public CharacterId CharacterId => new CharacterId(characterId);
    public string CharacterName => characterName;
    /// <summary>
    /// 固定3人かどうか（CharacterId.IsOriginalMember で自動判定）
    /// </summary>
    public bool IsOriginalMember => CharacterId.IsOriginalMember;
    public Sprite Portrait => portrait;
    public Sprite BannerBackground => bannerBackground;
    // ... 他のプロパティ

    /// <summary>
    /// AllyClassインスタンスを生成
    /// </summary>
    public AllyClass CreateInstance()
    {
        var ally = new AllyClass();
        ally.SetCharacterId(CharacterId);
        ally.HP = initialHP;
        ally.MaxHP = initialMaxHP;
        ally.MentalHP = initialMentalHP;
        ally.P = initialP;
        ally.MAXP = initialMaxP;
        ally.SetImpressions(defaultImpression, defaultImpression);
        ally.NowPower = initialPower;
        // スキル、十日能力などの初期化...
        return ally;
    }
}

[Serializable]
public struct TenDayValueEntry
{
    public TenDayAbility Ability;
    public float Value;
}
```

### 4.2 解放Effect: CharacterUnlockEffect

**具体型依存について:** このEffectは `IPlayersRoster` ではなく `PlayersRoster` に直接依存します。
理由: `RegisterAlly()` は新規キャラ登録という実装固有の操作であり、インターフェースに含めると
抽象化が過剰になるため。テスト時はPlayersRosterをモック/スタブで差し替えてください。

```csharp
[CreateAssetMenu(menuName = "Walk/Effects/Character Unlock")]
public sealed class CharacterUnlockEffect : EffectSO
{
    [SerializeField] private CharacterDataSO characterData;
    [SerializeField] private bool addToPartyImmediately = true;

    public override UniTask Apply(GameContext context)
    {
        // 戦闘中チェック
        if (BattleContextHub.Current != null)
        {
            Debug.LogWarning("CharacterUnlockEffect: 戦闘中は解放できません");
            return UniTask.CompletedTask;
        }

        var players = context?.Players;
        // 具体型に依存（RegisterAllyはIPlayersRosterに含めない設計）
        var roster = players?.Roster as PlayersRoster;
        var composition = players?.Composition;

        if (roster == null || characterData == null)
        {
            Debug.LogWarning("CharacterUnlockEffect: 必要な参照がありません");
            return UniTask.CompletedTask;
        }

        var id = characterData.CharacterId;

        // 既に解放済みなら何もしない
        if (roster.IsUnlocked(id))
        {
            Debug.Log($"CharacterUnlockEffect: {id} は既に解放済みです");
            return UniTask.CompletedTask;
        }

        // AllyClassインスタンスを生成してRosterに登録
        var ally = characterData.CreateInstance();
        roster.RegisterAlly(id, ally);
        Debug.Log($"キャラクター {id} を解放しました");

        // パーティーに即追加（オプション）
        if (addToPartyImmediately && composition != null && !composition.IsFull)
        {
            composition.AddMember(id);
            Debug.Log($"キャラクター {id} をパーティーに追加しました");
        }

        return UniTask.CompletedTask;
    }
}
```

---

## 5. UI層の設計

### 5.1 概要

**CharacterDataSO と UI参照を分離する。**

- **CharacterDataSO**: キャラクターデータのみ（Addressables対応可能）
- **CharacterUIRegistry**: シーン配置済みUI参照（シーン側MonoBehaviour）

```
【現状】
SkillObject
├── geino (GameObject, コードでハードコード参照)
├── sites (GameObject, コードでハードコード参照)
└── normalia (GameObject, コードでハードコード参照)

【変更後】
CharacterDataSO（データのみ、Addressables可）
├── characterId, stats, skills...
└── ※ UI参照は持たない

CharacterUIRegistry（シーン側MonoBehaviour）
├── Dictionary<CharacterId, GameObject> skillUIs
└── Dictionary<CharacterId, AllyUISet> allyUISets
```

**ポイント:**
- 新キャラ追加時はシーンにUIを手動配置 → CharacterUIRegistry で参照を設定
- CharacterDataSO は Addressables / Resources で管理可能
- 動的生成（Instantiate）はしない

### 5.2 CharacterUIRegistry（シーン側UI参照）

**ID正規化ルール:** CharacterId は内部で小文字に正規化されます（CharacterId構造体のコンストラクタで実施）。
CharacterDataRegistry と CharacterUIRegistry は同じ CharacterId 構造体を使用するため、正規化は自動的に統一されます。

```csharp
/// <summary>
/// シーンに配置済みのキャラUI参照を管理（シーン側MonoBehaviour）
/// CharacterDataSO とは分離してシーン参照問題を回避
/// </summary>
public class CharacterUIRegistry : MonoBehaviour
{
    public static CharacterUIRegistry Instance { get; private set; }

    [Serializable]
    public class UIEntry
    {
        public string CharacterId;      // "geino", "newchar1" etc.（大小文字は正規化される）
        public GameObject SkillUIObject;
        public AllyUISet AllyUISet;
    }

    [SerializeField] private List<UIEntry> entries = new();

    private Dictionary<CharacterId, UIEntry> _map;

    private void Awake()
    {
        Instance = this;
        BuildMap();
    }

    private void BuildMap()
    {
        _map = new Dictionary<CharacterId, UIEntry>();
        foreach (var entry in entries)
        {
            if (string.IsNullOrEmpty(entry.CharacterId)) continue;
            // CharacterId構造体が小文字正規化を行う
            var id = new CharacterId(entry.CharacterId);
            if (_map.ContainsKey(id))
            {
                Debug.LogWarning($"CharacterUIRegistry: ID重複 '{id}'");
                continue;
            }
            _map[id] = entry;
        }
    }

#if UNITY_EDITOR
    /// <summary>
    /// エディタ用: 空ID/重複を検証
    /// </summary>
    [ContextMenu("Validate Entries")]
    private void ValidateEntries()
    {
        var seen = new HashSet<string>();
        foreach (var entry in entries)
        {
            if (string.IsNullOrWhiteSpace(entry.CharacterId))
            {
                Debug.LogError($"CharacterUIRegistry: 空のCharacterIdがあります");
                continue;
            }
            var normalized = entry.CharacterId.ToLowerInvariant();
            if (!seen.Add(normalized))
            {
                Debug.LogError($"CharacterUIRegistry: ID重複 '{entry.CharacterId}'");
            }
        }
        if (seen.Count == entries.Count)
        {
            Debug.Log("CharacterUIRegistry: 検証OK");
        }
    }
#endif

    public GameObject GetSkillUI(CharacterId id)
    {
        return _map.TryGetValue(id, out var e) ? e.SkillUIObject : null;
    }

    public AllyUISet GetAllyUISet(CharacterId id)
    {
        return _map.TryGetValue(id, out var e) ? e.AllyUISet : null;
    }

    public IEnumerable<CharacterId> RegisteredIds => _map.Keys;
}
```

### 5.3 TabCharaStateContent の変更

**前提条件:** 新キャラのUIは「シーンに事前配置」する設計です。CharacterUnlockEffectはキャラデータを解放するだけで、UIを動的生成しません。
したがって、Start()時点で全キャラのUIがシーンに存在している必要があります。

**UI更新契機:** Start()で一度だけ構築します。ゲーム中に新キャラUIを追加する場合は、
シーン遷移（シーンリロード）を契機とするか、`RebuildSkillUIMap()`を明示的に呼び出してください。

```csharp
// TabCharaStateContent.cs（変更後）
public class TabCharaStateContent : MonoBehaviour
{
    // ハードコード参照を廃止
    // [SerializeField] GameObject geino;   ← 削除

    // CharacterUIRegistry 経由で参照を取得
    private Dictionary<CharacterId, GameObject> _skillUIs;

    private void Start()
    {
        BuildSkillUIMap();
    }

    private void BuildSkillUIMap()
    {
        _skillUIs = new Dictionary<CharacterId, GameObject>();
        var registry = CharacterUIRegistry.Instance;
        if (registry == null) return;

        foreach (var id in registry.RegisteredIds)
        {
            var ui = registry.GetSkillUI(id);
            if (ui != null)
            {
                _skillUIs[id] = ui;
            }
        }
    }

    /// <summary>
    /// UIマップを再構築（シーン遷移なしで新キャラUI追加時に呼び出す）
    /// </summary>
    public void RebuildSkillUIMap() => BuildSkillUIMap();

    public void SwitchContent(CharacterId id)
    {
        foreach (var kvp in _skillUIs)
        {
            kvp.Value.SetActive(kvp.Key == id);
        }
    }
}
```

### 5.4 AllyUISet の取得方法

```csharp
// PlayersUIService.cs などで AllyUISet を取得する場合
public AllyUISet GetUISet(CharacterId id)
{
    return CharacterUIRegistry.Instance?.GetAllyUISet(id);
}
```

### 5.5 CharacterDataRegistry（SOデータ管理）

```csharp
/// <summary>
/// 全 CharacterDataSO を管理するレジストリ（データのみ）
/// </summary>
public class CharacterDataRegistry : MonoBehaviour
{
    public static CharacterDataRegistry Instance { get; private set; }

    [Header("初期キャラ（固定3人）")]
    [SerializeField] private CharacterDataSO[] initialCharacters;

    [Header("全キャラデータ（Addressables可）")]
    [SerializeField] private CharacterDataSO[] allCharacters;

    private readonly Dictionary<CharacterId, CharacterDataSO> _registry = new();

    private void Awake()
    {
        Instance = this;
        RegisterAll();
    }

    private void RegisterAll()
    {
        _registry.Clear();
        foreach (var data in allCharacters)
        {
            if (data == null) continue;
            var id = data.CharacterId;

            if (_registry.ContainsKey(id))
            {
                Debug.LogError($"CharacterDataRegistry: ID重複 '{id.Value}'");
                continue;
            }

            _registry[id] = data;
        }
    }

    public CharacterDataSO Get(CharacterId id)
    {
        return _registry.TryGetValue(id, out var data) ? data : null;
    }

    public IEnumerable<CharacterDataSO> InitialCharacters => initialCharacters;
    public IEnumerable<CharacterDataSO> AllCharacters => allCharacters;

#if UNITY_EDITOR
    /// <summary>
    /// エディタ用: 重複IDを検証
    /// </summary>
    [ContextMenu("Validate Duplicate IDs")]
    private void ValidateDuplicateIds()
    {
        var seen = new Dictionary<string, CharacterDataSO>();
        foreach (var data in allCharacters)
        {
            if (data == null) continue;
            var idStr = data.CharacterId.Value;
            if (seen.TryGetValue(idStr, out var existing))
            {
                Debug.LogError($"ID重複: '{idStr}' が {existing.name} と {data.name} で使われています");
            }
            else
            {
                seen[idStr] = data;
            }
        }
        if (seen.Count == allCharacters.Length)
        {
            Debug.Log("重複なし");
        }
    }
#endif
}
```

**重複ID対策:**
- 登録時に重複チェック → エラーログ出力
- 先勝ち方式（最初に登録されたものを優先）
- エディタ用のバリデーションメニューも提供

### 5.5 CharaconfigController の変更

```csharp
// CharaconfigController.cs（変更後）
public class CharaconfigController : MonoBehaviour, IPlayersContextConsumer
{
    private IPlayersRoster playersRoster;
    private IPartyComposition composition;

    // インデックスではなく CharacterId で管理
    private List<CharacterId> _partyMemberIds = new();
    private int _currentIndex = 0;

    public void InjectPlayersContext(PlayersContext context)
    {
        playersRoster = context?.Roster;
        composition = context?.Composition;
        RefreshPartyMemberIds();
    }

    private void RefreshPartyMemberIds()
    {
        _partyMemberIds.Clear();
        if (composition != null)
        {
            _partyMemberIds.AddRange(composition.ActiveMemberIds);
        }
    }

    private AllyClass GetActor(int index)
    {
        if (index < 0 || index >= _partyMemberIds.Count) return null;
        var id = _partyMemberIds[index];
        return playersRoster?.GetAlly(id);
    }

    private int GetAllyCount() => _partyMemberIds.Count;
}
```

---

## 6. 固定3人との分岐

### 6.1 判定方法

```csharp
// CharacterId.cs（実装済み）- 唯一の判定元
public bool IsOriginalMember =>
    this == Geino || this == Noramlia || this == Sites;

// CharacterDataSO.cs - CharacterId に委譲するだけ
public bool IsOriginalMember => CharacterId.IsOriginalMember;
// ※ 別フィールドは持たない（ID文字列で自動判定）
```

**ポイント:** 固定3人かどうかは `characterId` の文字列値（"geino", "noramlia", "sites"）で自動判定。
CharacterDataSO に別途フラグを持つ必要はない。

### 6.2 パーティー属性決定の分岐（実装済み）

**詳細仕様:** [パーティ属性仕様書.md](./パーティ属性仕様書.md)

```
GetPartyImpression()
       ↓
CountOriginalMembers() で固定メンバー数をカウント
       ↓
┌──────────────────────────────────────────┐
│ 固定3人 → HP比較（決定論的）              │
│ 固定2人 → 2人マッピング（決定論的）        │
│ 固定1人以下/新キャラ含む → 共通ロジック    │
│                         （ランダムあり）  │
└──────────────────────────────────────────┘
```

> **Note**: 「固定1人以下/新キャラ含む」のケースでランダム要素があるのは**意図的な設計**。
> 新キャラクターの場合、精神属性相性計算（敵と同じロジック）を使用する。

### 6.3 固定3人の初期化統一

```csharp
// PlayersRuntime.cs（変更後）
public void Init()
{
    // CharacterDataRegistry から初期キャラを取得
    var registry = CharacterDataRegistry.Instance;
    foreach (var data in registry.InitialCharacters)
    {
        var ally = data.CreateInstance();
        roster.RegisterAlly(data.CharacterId, ally);
        composition.AddMember(data.CharacterId);
    }
    // ...
}
```

---

## 7. セーブ/ロードへの影響

### 7.1 現状（実装済み）

```csharp
// PlayersSaveData.cs
public List<PlayersAllySaveData> Allies;      // 全キャラのデータ
public List<string> ActivePartyIds;           // パーティー編成
```

### 7.2 追加で必要なもの

```csharp
// PlayersSaveData.cs に追加
public List<string> UnlockedCharacterIds;     // 解放済みキャラID一覧
```

### 7.3 ロード時の流れ

```
1. UnlockedCharacterIds を読み込む
2. 各IDに対応する CharacterDataSO を CharacterDataRegistry から検索
3. CharacterDataSO.CreateInstance() で AllyClass を生成
4. Roster に登録
5. Allies からステータスを復元
6. ActivePartyIds から編成を復元
7. UI表示を更新（CharacterUIRegistry 経由で配置済みUIを参照）
```

### 7.4 データ整合性ルール

**UnlockedCharacterIds と Allies の不整合時の復旧優先順位:**

| 状況 | 復旧方法 |
|------|----------|
| UnlockedにあるがAlliesにない | CharacterDataSO.CreateInstance()で初期状態を生成 |
| AlliesにあるがUnlockedにない | Alliesのデータを採用し、Unlockedにも追加 |
| ActivePartyIdsに未解放キャラ | そのIDをスキップ（パーティーから除外） |
| CharacterDataSOが見つからない | エラーログ出力、そのキャラをスキップ |

**優先順位:** `Allies > UnlockedCharacterIds`
（ステータスデータが存在するなら、解放済みとみなす）

```csharp
// PlayersSaveService.cs（復旧ロジック例）
private void ReconcileData(PlayersSaveData data)
{
    var unlockedSet = new HashSet<string>(data.UnlockedCharacterIds ?? new List<string>());

    // Alliesに存在するがUnlockedにないIDを追加
    foreach (var ally in data.Allies)
    {
        if (!unlockedSet.Contains(ally.CharacterId))
        {
            Debug.LogWarning($"整合性復旧: {ally.CharacterId} をUnlockedに追加");
            unlockedSet.Add(ally.CharacterId);
        }
    }

    data.UnlockedCharacterIds = unlockedSet.ToList();
}
```

---

## 8. 使用例

### 8.1 ストーリーイベントで新キャラ解放

```
EventDefinitionSO "新キャラ加入イベント"
├─ steps:
│   ├─ NovelDialogueStep (会話)
│   └─ EffectStep
│       └─ effects:
│           └─ CharacterUnlockEffect (characterData: NewChar1)
└─ terminalEffects: (なし)
```

### 8.2 選択肢で解放キャラが変わる

```
EventDefinitionSO "分岐イベント"
├─ steps:
│   └─ MessageStep
│       ├─ message: "誰を仲間にする？"
│       └─ choices:
│           ├─ "キャラA" → CharacterUnlockEffect (CharA)
│           └─ "キャラB" → CharacterUnlockEffect (CharB)
└─ terminalEffects: (なし)
```

### 8.3 キャラ一時離脱

```
EventDefinitionSO "離脱イベント"
├─ steps:
│   ├─ NovelDialogueStep (「ここで待っている」)
│   └─ EffectStep
│       └─ PartyMemberEffect (id: "sites", action: Remove)
└─ terminalEffects: (なし)
```

### 8.4 ゲーム開始時のパーティー設定

```
NodeSO（開始ノード）
└─ onEnterEvent:
    └─ EventDefinitionSO
        └─ terminalEffects:
            └─ PartySetEffect (memberIds: ["geino", "noramlia", "sites"])
```

---

## 9. 実装タスク

### Phase A: CharacterDataSO + Registry ✅

| ファイル | 説明 |
|----------|------|
| `CharacterDataSO.cs` | キャラクターデータ定義SO |
| `CharacterDataRegistry.cs` | SO管理レジストリ |
| `TenDayValueEntry.cs` | 十日能力エントリ |

### Phase B: CharacterUnlockEffect ✅

| ファイル | 説明 |
|----------|------|
| `CharacterUnlockEffect.cs` | キャラクター解放Effect |

### Phase C: PlayersRuntime 統一 ✅

| ファイル | 説明 |
|----------|------|
| `PlayersRuntime.cs` | 初期化を CharacterDataSO 経由に変更 |
| `PlayersBootstrapper.cs` | InitialCharacters をSO参照に変更 |
| `AreaController.cs` | 新規ゲーム時OnEnter自動発火 |
| `WalkingSystemManager.cs` | 初回OnEnter発火処理 |

### Phase D: UI参照方式変更 ✅

| ファイル | 説明 |
|----------|------|
| `CharacterUIRegistry.cs` | シーン側UI参照レジストリ（新規作成） |
| `TabCharaStateContent.cs` | ハードコード参照 → CharacterUIRegistry経由に変更 |
| `PlayersUIRefs.cs` | 固定AllyUISet配列を廃止 |
| `PlayersUIService.cs` | CharacterId ベースに変更、CharacterUIRegistry経由でUI取得 |
| `UIStateHub.cs` | `SkillState` を `ReactiveProperty<CharacterId>` に変更 |
| `ToggleButtons.cs` | SkillState購読部分を CharacterId 対応に変更 |
| `TabContents.cs` | `CharaStateSwitch(CharacterId)` に変更 |
| `BattleUIBridge.cs` | AllyId依存を廃止、CharacterId直接使用に変更 |
| `PlayersStatesInterfaces.cs` | `IPlayersSkillUI` のメソッドを CharacterId 対応に |
| `PlayersUIFacade.cs` | イベント型を CharacterId に変更 |

#### BattleUIBridge の変更詳細

**現状の問題:**
```csharp
// BattleUIBridge.cs - AllyIdでしか切り替えられない
public void SwitchAllySkillUiState(BaseStates acter, ...)
{
    if (!TryGetAllyId(acter, out var allyId))  // ← 固定3人のみ対応
        return;
    SetSkillUiState(ToSkillUiState(allyId));   // ← enum変換
}
```

**変更後:**
```csharp
// BattleUIBridge.cs（変更後）
public void SwitchAllySkillUiState(BaseStates acter, bool hasSingleTargetReservation)
{
    if (acter == null) return;

    // AllyClass から CharacterId を直接取得
    if (acter is not AllyClass ally || !ally.CharacterId.IsValid)
    {
        Debug.LogWarning("SwitchAllySkillUiState: CharacterId が無効です");
        return;
    }

    var characterId = ally.CharacterId;

    // スキルフィルター処理（既存ロジック維持）
    // ...

    skillUi.OnSkillSelectionScreenTransition(characterId);  // AllyId → CharacterId
    SetSkillUiState(characterId);  // 直接CharacterIdを設定
}

public void SetSkillUiState(CharacterId id)
{
    var skillState = UIStateHub.SkillState;
    if (skillState != null)
    {
        skillState.Value = id;  // ReactiveProperty<CharacterId>
    }
}
```

**呼び出し経路（変更後）:**
```
BattleManager.Acter の順番が来た
    ↓
BattleUIBridge.SwitchAllySkillUiState(Acter)
    ↓
ally.CharacterId を直接使用（AllyId変換不要）
    ↓
UIStateHub.SkillState.Value = characterId
    ↓
ToggleButtons（R3購読）
    ↓
TabContents.CharaStateSwitch(characterId)
    ↓
TabCharaStateContent.SwitchContent(characterId)
    ↓
CharacterUIRegistry から該当UIを取得してSetActive
```

**Note:** BattleManager / PartyBuilder 側は既に CharacterId ベースで実装済み。
`composition.ActiveMemberIds` → `roster.GetAlly(id)` の流れで新キャラにも対応している。

### Phase E: CharaconfigController 対応 ✅

| ファイル | 説明 |
|----------|------|
| `CharaconfigController.cs` | CharacterId ベースに変更 |
| `StatesBannerController.cs` | CharacterId 対応 |

### Phase F: セーブ/ロード対応 ✅

| ファイル | 説明 |
|----------|------|
| `PlayersSaveData.cs` | UnlockedCharacterIds 追加 |
| `PlayersSaveService.cs` | 解放状態の保存/復元 |

### Phase G: ノベルパート主人公設定のCharacterId化 ✅

ノベルパートの精神属性連携で使用している `AllyId` を `CharacterId` に変更。

| ファイル | 変更内容 |
|----------|----------|
| `NovelDialogueStep.cs` | `AllyId protagonist` → `CharacterId protagonist` |
| `DialogueContext.cs` | `AllyId? Protagonist` → `CharacterId? Protagonist` |
| `DialogueContext.cs` | `GetAllyById()` → `GetAlly(CharacterId)` |

```csharp
// NovelDialogueStep.cs（変更後）
[Header("主人公設定（精神属性連携用）")]
[SerializeField] private bool hasProtagonist;
[SerializeField] private CharacterId protagonist;  // AllyId → CharacterId

public CharacterId? GetProtagonist() => hasProtagonist ? protagonist : null;
```

```csharp
// DialogueContext.cs（変更後）
public CharacterId? Protagonist { get; set; }  // AllyId? → CharacterId?

public SpiritualProperty? GetProtagonistImpression()
{
    if (Protagonist == null || Roster == null) return null;
    var ally = Roster.GetAlly(Protagonist.Value);  // GetAllyById → GetAlly
    return ally?.GetImpressions().Now;
}
```

### Phase H: クリーンアップ ✅

| ファイル | 説明 |
|----------|------|
| `TabContents.cs` | SkillUICharaState enum Obsolete化 |
| `UIStateHub.cs` | SelectedCharacterId追加、SkillState Obsolete化 |
| `AllyId.cs` | 将来的に廃止（互換性維持中） |

---

## 10. 固定3人と新キャラの設定場所まとめ

### 10.1 データ初期化

| キャラ種別 | 設定場所 | 備考 |
|------------|----------|------|
| **固定3人** | `PlayersBootstrapper` (Inspector) | `Init_geino`, `Init_noramlia`, `Init_sites` (AllyClass SO参照) |
| **新キャラ** | `CharacterDataSO` | Resources/Characters/ に配置 |

```
PlayersBootstrapper (シーン上のGameObject)
├── Init_geino      : AllyClass (ScriptableObject)
├── Init_noramlia   : AllyClass (ScriptableObject)
├── Init_sites      : AllyClass (ScriptableObject)
└── ...
```

**Note:** `PlayersRuntimeConfig.UseCharacterDataRegistry = true` にすると、固定3人もCharacterDataSO経由になる（オプション）。

### 10.2 UI設定

| キャラ種別 | 設定場所 | 備考 |
|------------|----------|------|
| **固定3人** | `PlayersUIRefs` (Inspector) | `AllyUISet[]` で固定3人分のUI参照 |
| **新キャラ** | `CharacterUIRegistry` (Inspector) | `UIEntry[]` でCharacterId→UI参照マッピング |

### 10.3 内部ID（共通）

固定3人も新キャラも、内部的には全て `CharacterId` で統一されている。

```csharp
// 固定3人
CharacterId.Geino      // "geino"
CharacterId.Noramlia   // "noramlia"
CharacterId.Sites      // "sites"

// 新キャラ
new CharacterId("newchar1")
```

### 10.4 ノベルパート主人公指定

`NovelDialogueStep` の `protagonistCharacterId` フィールドで指定。
固定3人も新キャラも同じ方法で指定可能。

```
// Inspector設定例
protagonistCharacterId: "geino"     // 固定3人もOK
protagonistCharacterId: "newchar1"  // 新キャラもOK
```

`DialogueContext.GetProtagonistCharacterId()` で取得し、精神属性連携に使用。

---

## 11. 注意事項

- **戦闘中の解放禁止**: `CharacterUnlockEffect` でも戦闘中チェックを入れる
- **重複解放防止**: 既に解放済みなら何もしない
- **CharacterDataSO の管理**: Addressables or Resources で管理可能（UI参照を持たないため）
- **UI参照の分離**: CharacterDataSO にシーンオブジェクト参照を持たせない
  - 理由: ScriptableObjectにシーン参照を持つとAddressables/Resources管理ができなくなる
  - UI参照は `CharacterUIRegistry`（シーン側MonoBehaviour）で管理
- **新キャラ追加時**:
  1. CharacterDataSO を作成（データのみ）
  2. シーンにUIを手動配置
  3. CharacterUIRegistry にUI参照を設定
- **ID重複禁止**: CharacterDataSO の `characterId` は一意でなければならない
  - CharacterDataRegistry が起動時に重複チェック
  - 重複があればエラーログ出力、先勝ち方式で登録
  - エディタで事前検証可能（ContextMenu）
- **ID正規化ルール**: CharacterId 構造体が自動的に小文字正規化を行う（実装済み）
  - コンストラクタ: `ToLowerInvariant()` で正規化
  - デシリアライズ時: `OnAfterDeserialize()` で正規化
  - CharacterDataRegistry / CharacterUIRegistry は同じ CharacterId を使用するため自動的に統一
  - 例: "Geino", "GEINO", "geino" は全て同じIDとして扱われる
- **固定3人の判定**: CharacterDataSO に別フラグは持たない
  - `CharacterId.IsOriginalMember` で自動判定（ID文字列が "geino", "noramlia", "sites" かどうか）
