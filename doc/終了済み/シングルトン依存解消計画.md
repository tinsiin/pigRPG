# シングルトン依存解消計画

## 概要

プロジェクト全体でシングルトンパターン（`.Instance`）が多用されており、テスタビリティと依存関係の明示性に問題がある。
本計画では段階的にDI（依存性注入）パターンへ移行する。

---

## 現状分析

### シングルトン使用状況（2026-01-24調査）

| シングルトン | 使用箇所数 | 主な用途 |
|-------------|-----------|----------|
| `WatchUIUpdate.Instance` | 12箇所 | UI制御、ズーム、ActionMark |
| `SchizoLog.Instance` | 4箇所 | ログ表示 |
| `EnemyCollectManager.Instance` | 15箇所 | 敵データ管理 |
| `PassiveManager.Instance` | 4箇所 | パッシブスキル管理 |
| `WeaponManager.Instance` | 1箇所 | 武器管理 |
| `CharaconfigController.Instance` | 2箇所 | キャラ設定UI |
| `BattleSystemArrowManager.Instance` | 3箇所 | バトル矢印表示 |
| `SelectTargetButtons.Instance` | 1箇所 | ターゲット選択UI |
| `SelectRangeButtons.Instance` | 1箇所 | 範囲選択UI |
| `EyeAreaManager.Instance` | 0箇所 | 新規作成（まだ未使用） |

### 主な依存箇所

```
BattleInitializer
    └→ WatchUIUpdate.Instance

BattleUIBridge
    ├→ WatchUIUpdate.Instance
    ├→ SchizoLog.Instance
    ├→ CharaconfigController.Instance
    └→ BattleSystemArrowManager.Instance

UIController（アイコンタップ）
    └→ WatchUIUpdate.Instance

WalkingSystemManager
    └→ WatchUIUpdate.Instance

Walking
    └→ WatchUIUpdate.Instance

BaseStates
    └→ WatchUIUpdate.Instance（wuiプロパティ）
```

---

## 問題点

### 1. 暗黙的な依存
```csharp
// 現状: 依存関係がコンストラクタに現れない
public class BattleUIBridge
{
    public void ShowActionMark()
    {
        WatchUIUpdate.Instance.ShowActionMark();  // 暗黙的
    }
}
```

### 2. テスト困難
```csharp
// モックに差し替えられない
[Test]
public void TestBattleUI()
{
    // WatchUIUpdate.Instanceをモックにできない
    // シーン全体が必要になる
}
```

### 3. 初期化順序の問題
```csharp
// Instance取得時にnullの可能性
var wui = WatchUIUpdate.Instance;
if (wui == null) throw new Exception("初期化順序の問題");
```

---

## 解決方針

### DIパターンへの移行

```csharp
// After: 依存関係が明示的
public class BattleUIBridge
{
    private readonly IActionMarkController _actionMark;

    public BattleUIBridge(IActionMarkController actionMark)
    {
        _actionMark = actionMark;
    }

    public void ShowActionMark()
    {
        _actionMark.Show();
    }
}
```

### Unityでの実現方法

| 方法 | 説明 | 適用場面 |
|------|------|----------|
| **コンストラクタ注入** | 非MonoBehaviourクラス向け | BattleUIBridge, Controllers |
| **メソッド注入** | 初期化時に渡す | MonoBehaviourのAwake後 |
| **SerializeField注入** | Inspectorで設定 | シーン上の参照 |
| **Service Locator** | 軽量DIの代替 | 段階的移行時の中間策 |

---

## 実装フェーズ

### Phase 0: 準備（影響なし）

**目標:** DIの基盤を整備

**作業内容:**
1. `IServiceProvider`的な軽量コンテナを作成（任意）
2. 既存インターフェースの確認（IActionMarkController等は既にある）

**成果物:**
```csharp
// 任意: 軽量Service Locator（段階的移行用）
public static class Services
{
    public static IActionMarkController ActionMark { get; set; }
    public static IKZoomController KZoom { get; set; }
    public static IViewportController Viewport { get; set; }
    // ...
}
```

---

### Phase 1: WatchUIUpdate依存の解消（中規模）

**目標:** `WatchUIUpdate.Instance`への直接アクセスを削減

**対象ファイル:**
| ファイル | 現状 | 変更内容 |
|----------|------|----------|
| `BattleInitializer.cs` | `_watchUIUpdate = WatchUIUpdate.Instance` | コンストラクタ注入 |
| `BattleUIBridge.cs` | 4箇所でInstance参照 | インターフェース注入 |
| `UIController.cs` | KZoom用にInstance参照 | IKZoomController注入 |
| `Walking.cs` | ForceExitKImmediate呼び出し | IKZoomController注入 |
| `WalkingSystemManager.cs` | ApplyNodeUI等 | IWalkingUIController注入 |

**変更例（BattleUIBridge）:**
```csharp
// Before
public class BattleUIBridge
{
    public void ShowActionMark()
    {
        var ui = WatchUIUpdate.Instance;
        ui?.ShowActionMark();
    }
}

// After
public class BattleUIBridge
{
    private readonly IActionMarkController _actionMark;
    private readonly IKZoomController _kZoom;

    public BattleUIBridge(
        IActionMarkController actionMark,
        IKZoomController kZoom)
    {
        _actionMark = actionMark;
        _kZoom = kZoom;
    }

    public void ShowActionMark()
    {
        _actionMark.Show();
    }
}
```

**初期化（BattleOrchestrator等で）:**
```csharp
var wui = WatchUIUpdate.Instance;  // ここだけInstanceを使う
var bridge = new BattleUIBridge(
    wui.ActionMarkCtrl,
    wui.KZoomCtrl
);
```

**効果:**
- WatchUIUpdate.Instance参照が12箇所 → 2-3箇所に削減
- 各クラスが必要なインターフェースのみに依存

---

### Phase 2: BaseStates依存の解消（簡単〜中規模）

#### Phase 2a: BaseStates.wui削除（簡単・即対応可能）

**調査結果（2026-01-24）:** `wui`は**定義されているが使われていない**

```csharp
// BaseStates.cs:27
WatchUIUpdate wui => WatchUIUpdate.Instance;  // ← 定義のみ、参照箇所なし
```

**対応:** 1行削除するだけ

**作業:**
- [ ] `Assets/Script/BaseStates/BaseStates.cs:27` の `wui` プロパティ削除
- [ ] コンパイル確認

**難易度:** 簡単（1行削除）

---

#### Phase 2b: BaseStates.schizoLog整理（中規模）

**現状:**
```csharp
// BaseStates.cs:29
protected SchizoLog schizoLog => SchizoLog.Instance;
```

**使用状況:** `AddBattleLog`メソッド内でフォールバックとして使用

```csharp
protected void AddBattleLog(string message, bool important = false)
{
    var bridge = BattleUIBridge.Active;
    if (bridge != null)
    {
        bridge.AddLog(message, important);
        return;
    }
    schizoLog?.AddLog(message, important);  // ← フォールバック
}
```

**対応案:** BattleUIBridge経由に統一済みなので、schizoLogプロパティは将来的に削除可能
- BattleUIBridge.Activeがnullにならない設計にすれば削除可能

**難易度:** 中

---

### Phase 3: その他シングルトンの整理（中〜大規模）

#### Phase 3a: SchizoLog.Instance（8箇所）

**使用箇所:**
| ファイル | 箇所数 | 用途 |
|----------|--------|------|
| `BattleUIBridge.cs` | 3 | ログ追加、クリア |
| `BaseStates.cs` | 1 | schizoLogプロパティ定義 |
| `BaseSkill.Core.cs` | 1 | schizoLogプロパティ定義 |
| `Stages.cs` | 1 | ログ表示 |
| `WatchUIUpdate.cs` | 2 | KZoom用の表示制御 |

**対応方針:**
1. BattleUIBridge経由でログ操作を統一
2. ISchizoLogインターフェース化（任意）
3. KZoom用の表示制御はKZoomController内で完結させる

**作業:**
- [ ] BattleUIBridge.csのSchizoLog直接参照を整理
- [ ] BaseStates/BaseSkillのschizoLogプロパティ削除検討
- [ ] WatchUIUpdate.csのSchizoLog参照をKZoomController内に移動

**難易度:** 中

---

#### Phase 3b: PassiveManager.Instance（6箇所）

**使用箇所:**
| ファイル | 箇所数 | 用途 |
|----------|--------|------|
| `BattleAIBrain.cs` | 1 | パッシブ効果判定（IsBad確認） |
| `BaseStates.PassiveManager.cs` | 3 | パッシブ適用（GetAtID） |
| `BaseStates.ReactionSkill.cs` | 2 | リアクションスキル処理 |

**対応方針:**
```csharp
// IPassiveProviderインターフェース化
public interface IPassiveProvider
{
    PassiveStatus GetAtID(int id);
}

// BaseStatesにプロパティ追加
public partial class BaseStates
{
    public IPassiveProvider PassiveProvider { get; set; }
}
```

**作業:**
- [ ] IPassiveProviderインターフェース作成
- [ ] PassiveManagerにIPassiveProvider実装
- [ ] BaseStatesにPassiveProviderプロパティ追加
- [ ] 各参照箇所をProvider経由に変更

**難易度:** 中

---

#### Phase 3c: EnemyCollectManager.Instance（20箇所以上）

**現状（2026-01-24調査）:**

| ファイル | 箇所数 | 用途 | 状態 |
|----------|--------|------|------|
| `Archive/Stages.cs` | 16 | 敵相性計算 | **古いコード（対象外）** |
| `EncounterEnemySelector.cs` | 17 | 敵遭遇時のグループ選択 | **要対応** |

**基盤整備（完了）:**
- [x] `IEnemyMatchCalculator` インターフェース作成（`Assets/Script/Enemies/`）
- [x] `EnemyCollectManager` に `IEnemyMatchCalculator` 実装

**EncounterEnemySelector.cs 詳細分析:**

```
構造: staticクラス
呼び出し元: BattleInitializer.cs:36 の1箇所のみ

EnemyCollectManager.Instance 使用箇所（17箇所）:
├─ EnemyLonelyPartyImpression[] ... 6箇所（辞書アクセス）
├─ LonelyMatchUp() ................ 3箇所
├─ calculatePartyProperty() ....... 5箇所
├─ TypeMatchUp() .................. 1箇所
├─ ImpressionMatchUp() ............ 1箇所
└─ GetImpressionMatchPercent() .... 2箇所
```

**実装案の比較:**

| 案 | 概要 | メリット | デメリット | 推奨度 |
|----|------|----------|------------|--------|
| **A** | staticメソッドに引数追加 | 既存互換、変更最小 | 引数が増える | ★★★ |
| **B** | インスタンスクラスに変更 | 完全DI、テスト容易 | 呼び出し元変更必要 | ★★☆ |
| **C** | メソッド内でローカル変数化 | 変更最小 | 完全DIにならない | ★☆☆ |

**推奨: 案A（オプショナル引数追加）**

```csharp
// Before
public static class EncounterEnemySelector
{
    public static BattleGroup SelectGroup(
        IReadOnlyList<NormalEnemy> enemies,
        int globalSteps,
        int number = -1)
    {
        // EnemyCollectManager.Instance を直接参照
    }
}

// After
public static class EncounterEnemySelector
{
    public static BattleGroup SelectGroup(
        IReadOnlyList<NormalEnemy> enemies,
        int globalSteps,
        int number = -1,
        IEnemyMatchCalculator matchCalc = null)  // 追加
    {
        // フォールバック付きで参照
        var calc = matchCalc ?? EnemyCollectManager.Instance;
        // 以降 calc を使用
    }
}
```

**呼び出し元の変更（BattleInitializer.cs）:**
```csharp
// Before
var enemyGroup = EncounterEnemySelector.SelectGroup(enemies, globalSteps, enemyNumber);

// After（オプション）
var enemyGroup = EncounterEnemySelector.SelectGroup(
    enemies, globalSteps, enemyNumber,
    EnemyCollectManager.Instance);  // 明示的に注入
```

**作業チェックリスト（Phase 3c 残り）:**
- [ ] EncounterEnemySelector.SelectGroupに`IEnemyMatchCalculator`引数を追加
- [ ] メソッド内の17箇所を`calc`変数経由に変更
- [ ] BuildCompatibilityDataにも引数追加（privateメソッド）
- [ ] BattleInitializer.csの呼び出し元を必要に応じて変更
- [ ] コンパイル確認
- [ ] 動作確認

**難易度:** 中（構造変更なし、17箇所の置換のみ）

**見積もり工数:** 小〜中（メソッド内の置換作業）

---

#### Phase 3d: BattleSystemArrowManager.Instance（3箇所）

**使用箇所:**
| ファイル | 箇所数 | 用途 |
|----------|--------|------|
| `BattleUIBridge.cs` | 3 | 矢印キュー操作 |

**対応方針:** BattleUIBridgeにIArrowManager注入

**難易度:** 低（3箇所のみ）

---

### Phase 3 まとめ

| シングルトン | 箇所数 | 難易度 | 優先度 | 備考 |
|-------------|--------|--------|--------|------|
| SchizoLog | 8 | 中 | 中 | BattleUIBridge統一で削減可能 |
| PassiveManager | 6 | 中 | 低 | データ参照用、影響小 |
| EnemyCollectManager | 20+ | 大 | 低 | 古いコード含む、要検討 |
| BattleSystemArrowManager | 3 | 低 | 低 | BattleUIBridge内で完結 |

---

## 移行戦略

### 段階的アプローチ

```
現状:
各所で WatchUIUpdate.Instance を直接参照
    ↓
Phase 1:
コンストラクタ/初期化時に注入、Instanceは初期化箇所のみ
    ↓
Phase 2:
BaseStatesの依存を整理
    ↓
Phase 3（将来）:
完全なDI（DIコンテナ導入検討）
```

### 後方互換性

```csharp
// 移行期間中は両方サポート
public class WatchUIUpdate
{
    public static WatchUIUpdate Instance { get; private set; }  // 既存コード用

    // 新規コードはインターフェース経由
    public IActionMarkController ActionMarkCtrl => _actionMarkCtrl;
    public IKZoomController KZoomCtrl => _kZoomCtrl;
}
```

---

## リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| 初期化順序の問題 | 高 | 初期化チェーン明確化、null安全 |
| 参照漏れでNullRef | 中 | 段階的移行、テスト追加 |
| 変更範囲が広い | 中 | Phase分割、1ファイルずつ |

---

## 作業チェックリスト

### Phase 1: WatchUIUpdate依存解消 ✅ 完了
- [x] BattleInitializer.csの注入化
- [x] BattleUIBridge.csの注入化
- [x] UIController.csの注入化
- [x] Walking.csの注入化
- [x] WalkingSystemManager.csの注入化
- [x] コンパイル確認
- [ ] 動作確認

### Phase 2a: BaseStates.wui削除 ✅ 完了
- [x] `Assets/Script/BaseStates/BaseStates.cs:27` の `wui` プロパティ削除
- [x] コンパイル確認

### Phase 2b: BaseStates.schizoLog整理 ✅ 完了
- [x] schizoLogプロパティ削除（BaseStates, BaseSkill.Core両方）
- [x] AddBattleLogメソッドはBattleUIBridge経由のみに統一

### Phase 3a: SchizoLog整理 ✅ 完了
- [x] BattleUIBridge.csのSchizoLog直接参照をDI注入化
- [x] BaseStates/BaseSkillのschizoLogプロパティ削除
- [x] WatchUIUpdate.csのSchizoLog参照は初期化箇所のみに限定（KZoom用コールバック）

### Phase 3b: PassiveManager整理 ✅ 完了
- [x] IPassiveProviderインターフェース作成
- [x] PassiveManagerにIPassiveProvider実装
- [x] BaseStatesにPassiveProviderプロパティ追加
- [x] 各参照箇所をProvider経由に変更（フォールバック付き）

### Phase 3c: EnemyCollectManager整理 ✅ 完了

- [x] IEnemyMatchCalculatorインターフェース作成
- [x] EnemyCollectManagerにIEnemyMatchCalculator実装
- [x] Archive/Stages.csは古いコードのため対象外と判断
- [x] SelectGroupメソッドに`IEnemyMatchCalculator`引数を追加
- [x] メソッド内の17箇所を`calc`変数経由に変更
- [x] BuildCompatibilityData, CreateBattleGroupにも引数追加
- [ ] 動作確認

### Phase 3d: BattleSystemArrowManager整理 ✅ 完了
- [x] IArrowManagerインターフェース作成
- [x] BattleSystemArrowManagerにIArrowManager実装
- [x] BattleUIBridgeにIArrowManager注入
- [x] BaseStatesにArrowManagerプロパティ追加
- [x] WalkingSystemManagerにIArrowManager注入

### Phase 3e: IntroOrchestrator Facade分離 ✅ 完了

**背景:**
Phase 1で`IViewportController`に`RestoreZoomViaOrchestrator`を追加したが、`ViewportController`はOrchestratorを持たないため不完全な実装を強いられた。これは設計上の問題であり、根本的な解決が必要だった。

**解決策: ファサード + プロバイダー分離**

```
IIntroOrchestratorFacade（新規）
    └── IntroOrchestratorFacade
        ├── IIntroOrchestrator（実行）
        ├── IIntroContextProvider（文脈生成）
        └── IEnemyPlacementContextProvider（配置文脈）
```

**作業:**
- [x] `IIntroContextProvider`インターフェース作成（`Assets/Script/Orchestration/`）
- [x] `IEnemyPlacementContextProvider`インターフェース作成
- [x] `IIntroOrchestratorFacade`インターフェース作成
- [x] `IntroOrchestratorFacade`実装（Orchestrator + Provider を束ねる）
- [x] `WatchUIUpdate`が`IIntroContextProvider`/`IEnemyPlacementContextProvider`を実装
- [x] `WatchUIUpdate.IntroOrchestrator`プロパティで`IIntroOrchestratorFacade`を公開
- [x] `IViewportController`から`RestoreZoomViaOrchestrator`を削除
- [x] `ViewportController`の不完全な復帰実装を撤去
- [x] `BattleUIBridge`は`IIntroOrchestratorFacade`を注入
- [x] `BattleManager`で`wui?.IntroOrchestrator`を渡す
- [x] `EyeAreaManager`に`IntroOrchestrator`プロパティ追加
- [x] 動作確認（ズームアウト正常動作）

**設計のポイント:**

| インターフェース | 責務 |
|------------------|------|
| `IViewportController` | ビューポート参照のみ（Zoom, ZoomBackContainer等） |
| `IIntroOrchestratorFacade` | イントロ演出（Prepare, Play, PlaceEnemies, Restore） |
| `IIntroContextProvider` | IntroContext構築 |
| `IEnemyPlacementContextProvider` | PlacementContext構築 |

**効果:**
- インターフェース分離原則（ISP）に準拠
- 各クラスが明確な責務を持つ
- `ViewportController`が無理にOrchestratorを持つ必要がなくなった
- テスト時にProviderをモックに差し替え可能

---

## 関連ドキュメント

- [UI構造の問題点.md](./UI構造の問題点.md) - 背景と課題
- [WatchUIUpdateリファクタリング.md](../終了済み/WatchUIUpdateリファクタリング.md) - 責務分離（完了）

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-24 | 初版作成 |
| 2026-01-24 | Phase 0〜3d 実装完了。インターフェース作成・DI注入化・フォールバック対応 |
| 2026-01-24 | Phase 3e 追加。IIntroOrchestratorFacade分離によりズーム復帰の設計問題を根本解決 |
