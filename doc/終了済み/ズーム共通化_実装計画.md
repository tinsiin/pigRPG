# ズーム共通化 実装計画

**状態: ✅ 完了（2026-01-24）**

## 目的
- 「ズーム操作（IZoomController）」と「ズーム演出（文脈込み）」を分離し、
  バトル/ノベル/歩行など**どこからでも同じ入口でズームイン/アウトを使える**ようにする。

## 現状整理（前提）
- ズーム操作は IZoomController として共通化済み。
- ただし「CaptureOriginal / Context / Restore」の前後文脈が
  バトル（IntroOrchestrator）に偏っているため、他システムが手動実装になっている。

## ゴール
- **演出ズームの共通入口**を 1 つに統一（IntroOrchestrator Facade 経由）。
- ノベル等の呼び出しは「1行」で完結できる。

## 仕様（使う側の理想形）
```csharp
// ノベル/歩行/バトル共通
await EyeAreaManager.Instance.IntroOrchestrator.PlayAsync();
await EyeAreaManager.Instance.IntroOrchestrator.RestoreAsync(true, 0.4f);
```

## 実装方針（現在の指定方法を維持）
### 1) 共通入口（IntroOrchestrator Facade）を正式採用
- 既存の IntroOrchestrator Facade を**唯一の演出ズーム入口**にする。
- 各システムは `Viewport.Zoom` を直接触らず、Facade 経由で演出ズームを呼ぶ。

### 2) 文脈生成（Context Provider）を WatchUIUpdate に集約
- `IIntroContextProvider` / `IEnemyPlacementContextProvider` は WatchUIUpdate 実装に統一。
- ズーム対象の RectTransform / カーブ / gotoPos / gotoScale を常に同じ手順で供給。

### 3) EyeAreaManager に簡易ラッパーを追加（任意・低コスト）
- 呼び出し側が Facade を意識しなくても良いようにショートカットを追加。

例:
```csharp
public UniTask PlayZoomAsync()
    => IntroOrchestrator?.PlayAsync() ?? UniTask.CompletedTask;

public UniTask RestoreZoomAsync(bool animated = false, float duration = 0f)
    => IntroOrchestrator?.RestoreAsync(animated, duration) ?? UniTask.CompletedTask;
```

## 実装ステップ

### Phase A: 入口統一（必須） ✅ 完了
1. **Facade 経由が唯一の演出ズーム入口**であることをドキュメント化。
2. バトル／ノベル／歩行のズーム呼び出しを Facade に統一。

対象ファイル:
- `Assets/Script/Battle/UI/BattleUIBridge.cs` → `IIntroOrchestratorFacade`経由に変更済み
- `Assets/Script/BattleManager.cs` → Facade注入済み

### Phase B: EyeAreaManager ラッパー追加（推奨） ✅ 完了
- `EyeAreaManager` に `PrepareZoomAsync` / `PlayZoomAsync` / `RestoreZoomAsync` を追加。
- 呼び出し側が `IntroOrchestrator` を知らなくて済むようにする。

対象ファイル:
- `Assets/Script/EyeArea/EyeAreaManager.cs`

追加したメソッド:
```csharp
PrepareZoomAsync(ct)                        // 原状キャプチャ
PlayZoomAsync(ct)                           // ズームイン
RestoreZoomAsync(animated, duration, ct)    // ズームアウト
```

### Phase C: 不要分岐の削除（安定化） ✅ 完了
- `Viewport.Zoom` を演出用途で直接使っている箇所なし（確認済み）
- 例外: KZoom のみ別系統（KZoom は独自仕様）。

## 受け入れ条件 ✅ すべて達成
- [x] バトル終了のズームアウトが Facade 経由で正常復帰する。
- [x] ノベルパートでも同じ呼び出しでズームイン/アウトできる。
- [x] CaptureOriginal の呼び忘れが起きない（Facade 内で管理）。

## リスクと対策
- **リスク:** Facade 経由を徹底できず、呼び方が分岐する。
  - **対策:** ドキュメントに「Facade 以外禁止」を明記し、レビュー時に確認。

- **リスク:** 複数の IZoomController が同時に存在して状態がズレる。
  - **対策:** Orchestrator は必ず `Viewport.Zoom` を使用する。

## 補足: KZoomとの違い（共通化対象外）

本計画の対象は **IZoomController（IntroOrchestrator経由）** のみ。
**KZoom（EnterK/ExitK）** は完全に別の仕組みであり、共通化の対象外。

### 2つのズーム機構の比較

| 項目 | IZoomController（本計画の対象） | KZoom（対象外） |
|------|-------------------------------|----------------|
| **対象** | ZoomBack + ZoomFront（個別） | ViewportArea全体（kZoomRoot） |
| **MiddleFixed** | **ズームしない** | 全体と一緒にズーム |
| **ActionMark** | 表示されたまま | **非表示化** |
| **他UI** | そのまま | **非表示化** |
| **用途** | バトルイントロ、ノベルパート、歩行演出 | アイコンタップ詳細（バトル専用） |

### なぜKZoomは共通化しないか

KZoomはバトル中のアイコンタップ詳細表示という**特殊な要件**に特化:
- 親（ViewportArea）ごとズーム → 全子要素が一緒に動く
- 他キャラUIの非表示化 → `SetActive(false)`
- ActionMarkの非表示化
- K専用テキスト（名前、パッシブ）のスライド表示

これらはKZoom固有の仕様であり、汎用化する必要がない。

### ズーム要件の拡張性

現在のIntroContextは以下のパラメータを持つ:
- `gotoScaleXY` - ズーム先の倍率
- `gotoPos` - ズーム先の位置
- `ZoomDuration` - アニメーション時間
- `ZoomCurve` - イージングカーブ

これらは現状バトルイントロ用の値だが、**後から別のContext Providerを追加**すれば、
ノベルパート固有のズーム要件（倍率・位置など）にも対応可能。

```csharp
// 将来の拡張例（必要になったら）
public class NovelZoomContextProvider : IIntroContextProvider
{
    public IIntroContext BuildIntroContext()
    {
        return new IntroContext(
            gotoScaleXY: new Vector2(1.3f, 1.3f),  // ノベル用の倍率
            gotoPos: Vector2.zero,                 // 中央
            // ...
        );
    }
}
```

現時点では既存のContext Providerで十分。必要になったら拡張する。

---

## 参考（何が足りなかったか）
- 足りなかったのは**「文脈込みの共通入口」**。
- IZoomController は操作層だけなので、
  CaptureOriginal / Restore を統一できず呼び方が分岐した。

---

## 更新履歴
- 2026-01-24: 初版作成（ズーム共通化の実装計画を追加）
- 2026-01-24: KZoomとの違い・共通化対象外の理由を追記。ズーム要件の拡張性について記載
- 2026-01-24: **実装完了**。Phase A〜C すべて完了、動作確認済み
