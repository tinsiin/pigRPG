# ノベルパート実装計画

## 概要

ノベルパート設計書を満たすための実装計画。
歩行システムの設計思想に則り、既存のEvent Kernel基盤を拡張する形で実装する。

## 関連ドキュメント

- [ノベルパート設計.md](./ノベルパート設計.md) - 設計本体
- [ゼロトタイプ歩行システム設計書](../歩行システム設計/ゼロトタイプ歩行システム設計書.md) - 歩行システム基盤
- [HTMLモック](./novel_part_mock.html) - 技術デモ

---

## 現状分析

### 既存の実装基盤

| コンポーネント | ファイル | 状態 |
|---------------|---------|------|
| EventDefinitionSO | `Walk/EventKernel/EventDefinitionSO.cs` | ✅ 実装済み |
| EventRunner | `Walk/EventKernel/EventRunner.cs` | ✅ 実装済み |
| EventHost | `Walk/EventKernel/EventHost.cs` | ✅ 実装済み |
| IEventUI | `Walk/EventKernel/EventRunner.cs` | ✅ 最小実装 |
| WalkingEventUI | `Walk/EventKernel/WalkingEventUI.cs` | ✅ 最小実装 |
| MessageDropper | `MessageDropper.cs` | ✅ 実装済み |
| DialogueDefinitionSO | `Walk/Dialogue/DialogueDefinitionSO.cs` | ⚠️ プレースホルダ |
| DialogueNode | `Walk/Dialogue/DialogueNode.cs` | ⚠️ プレースホルダ |

### 現在のIEventUIインターフェース

```csharp
public interface IEventUI
{
    void ShowMessage(string message);
    UniTask<int> ShowChoices(string[] labels, string[] ids);
}
```

→ 立ち絵表示、背景制御、雑音システムの機能がない

### イベント発火タイミング（全て実装済み）

| タイミング | 実装場所 |
|-----------|---------|
| ノード入場 | AreaController.cs:130 |
| サイドオブジェクト選択 | AreaController.cs:614/626 |
| 中央オブジェクト選択 | AreaController.cs:629 |
| ゲート出現/通過/失敗 | AreaController.cs:325-375 |
| 遭遇結果 | AreaController.cs:681-685 |
| ノード退出 | AreaController.cs:494 |
| 歩数/確率トリガー | ❌ 未実装 |

---

## 互換性戦略

### IEventUI拡張の移行方針

既存の`IEventUI`と`WalkingEventUI`を破壊せず、段階的に拡張する。

#### 方針: インターフェース継承 + アダプタパターン

```csharp
// ===== Step 1: 既存インターフェースは維持 =====
public interface IEventUI
{
    void ShowMessage(string message);
    UniTask<int> ShowChoices(string[] labels, string[] ids);
}

// ===== Step 2: 新規インターフェースを追加継承 =====
public interface INovelEventUI : IEventUI
{
    // 立ち絵
    UniTask ShowPortrait(PortraitState left, PortraitState right);
    UniTask HidePortrait(PortraitPosition position);

    // 背景
    UniTask ShowBackground(string backgroundId);
    UniTask HideBackground();

    // 雑音
    void PlayNoise(NoiseEntry[] entries);
    void AccelerateNoises();

    // テキストボックス
    UniTask ShowText(string speaker, string text);
    UniTask SwitchTextBox(DisplayMode mode);

    // モード
    DisplayMode CurrentDisplayMode { get; }
}

// ===== Step 3: 既存実装はそのまま動く =====
public class WalkingEventUI : IEventUI
{
    // 変更なし - 既存コードはコンパイル通る
}

// ===== Step 4: 新規実装は拡張版 =====
public class NovelPartEventUI : INovelEventUI
{
    // 全機能を実装
}
```

#### 移行フロー

```
Phase 1: INovelEventUI定義、NovelPartEventUI骨格
    ↓
Phase 2-4: Presenter実装、INovelEventUI実装完了
    ↓
Phase 5: DialogueRunnerはINovelEventUIを使用
         EventRunnerは既存IEventUIを維持
    ↓
将来: 必要に応じてEventRunnerをINovelEventUI対応に更新
```

#### コンパイル破断リスク

| シナリオ | リスク | 対策 |
|---------|-------|------|
| IEventUIに新メソッド追加 | **高** | ❌ やらない。INovelEventUIを別定義 |
| INovelEventUI新規追加 | **なし** | ✅ 既存コードに影響なし |
| WalkingEventUI変更 | **なし** | ✅ 変更しない |

---

## IDialogueRunner設計

### IBattleRunnerパターンに倣う

既存の`IBattleRunner`と同じパターンで`IDialogueRunner`を設計し、GameContextに統合する。

#### 既存パターン（参考: IBattleRunner）

```csharp
// Assets/Script/Walk/Battle/IBattleRunner.cs
public interface IBattleRunner
{
    UniTask<BattleResult> RunBattleAsync(EncounterContext context);
}

// GameContext.cs:18
public IBattleRunner BattleRunner { get; set; }
```

#### 新規: IDialogueRunner

```csharp
// Assets/Script/Walk/Dialogue/IDialogueRunner.cs（新規）
public interface IDialogueRunner
{
    UniTask<DialogueResult> RunDialogueAsync(DialogueContext context);
}

public class DialogueContext
{
    public GameContext GameContext { get; set; }
    public FieldDialogueSO Dialogue { get; set; }
    public DisplayMode InitialMode { get; set; }
    public bool AllowSkip { get; set; } = true;
}

public struct DialogueResult
{
    public bool Completed { get; set; }
    public int SelectedChoiceIndex { get; set; }  // 選択肢がある場合
    public SpiritualProperty? ChangedSpirit { get; set; }  // 精神属性変化
}
```

#### GameContextへの統合

```csharp
// GameContext.cs に追加
public IDialogueRunner DialogueRunner { get; set; }
```

#### 実装クラス

```csharp
// Assets/Script/Walk/Dialogue/NovelPartDialogueRunner.cs（新規）
public sealed class NovelPartDialogueRunner : IDialogueRunner
{
    private readonly INovelEventUI ui;

    public NovelPartDialogueRunner(INovelEventUI ui)
    {
        this.ui = ui;
    }

    public async UniTask<DialogueResult> RunDialogueAsync(DialogueContext context)
    {
        if (context?.Dialogue == null)
            return new DialogueResult { Completed = false };

        var result = new DialogueResult { Completed = true };

        foreach (var step in context.Dialogue.Steps)
        {
            await ExecuteStep(step, context);

            if (step.choices?.Length > 0)
            {
                result.SelectedChoiceIndex = await HandleChoices(step);
            }
        }

        return result;
    }

    private async UniTask ExecuteStep(DialogueStep step, DialogueContext context)
    {
        // 実行シーケンスに従って処理
        // 1. 背景変更
        // 2. 立ち絵変更
        // 3. テキストボックス切り替え
        // 4. テキスト表示 + 雑音発火
        // 5. ユーザー入力待ち
        // 6. 選択肢表示
        // 7. Effect実行
    }
}
```

#### 強制イベントからの呼び出し

```csharp
// AreaController.cs（修正）
private async UniTask CheckForcedEvents()
{
    forcedEventStateManager.IncrementSteps();

    var triggers = currentNode.ForcedEventTriggers;
    foreach (var trigger in triggers)
    {
        if (!forcedEventStateManager.CanTrigger(trigger)) continue;
        if (!CheckConditions(trigger.conditions)) continue;

        bool shouldTrigger = trigger.type switch
        {
            ForcedEventType.Steps => CheckStepsTrigger(trigger),
            ForcedEventType.Probability => CheckProbabilityTrigger(trigger),
            _ => false
        };

        if (shouldTrigger)
        {
            forcedEventStateManager.RecordTrigger(trigger.triggerId, trigger.consumeOnTrigger);

            // IBattleRunnerと同じパターンでDialogueRunnerを呼び出す
            var dialogueContext = new DialogueContext
            {
                GameContext = context,
                Dialogue = trigger.dialogue,
                InitialMode = DisplayMode.Dinoid
            };
            await context.DialogueRunner.RunDialogueAsync(dialogueContext);

            return;  // 1歩で1件のみ
        }
    }
}
```

---

## アーキテクチャ方針

### 1. SO設計

```
EventDefinitionSO（既存）
    ↓ 拡張
FieldDialogueSO（新規）  ← フィールド会話用
EventDialogueSO（新規）  ← イベント会話用（将来）
```

- 内部のデータ構造は共通化
- 歩行システム上では別SOとして明示的に区別

### 2. レイヤー構造

```
┌─────────────────────────────────────────┐
│  Presentation層（新規）                  │
│  ├─ PortraitPresenter（立ち絵表示）      │
│  ├─ BackgroundPresenter（背景制御）      │
│  ├─ NoisePresenter（雑音システム）       │
│  └─ TextBoxPresenter（テキストボックス） │
├─────────────────────────────────────────┤
│  IEventUI（拡張）                        │
│  ├─ ShowPortrait()                      │
│  ├─ ShowBackground()                    │
│  ├─ PlayNoise()                         │
│  └─ 既存: ShowMessage(), ShowChoices()  │
├─────────────────────────────────────────┤
│  Event Kernel（既存）                    │
│  ├─ EventRunner                         │
│  ├─ EventHost                           │
│  └─ EffectSO群                          │
├─────────────────────────────────────────┤
│  歩行システム（既存）                    │
│  └─ AreaController.WalkStep()           │
└─────────────────────────────────────────┘
```

---

## 実行シーケンス

### DialogueRunnerのステップ処理順序

各DialogueStepは**固定順序**で処理する。並列実行は明示的に定義された箇所のみ。

```
┌─────────────────────────────────────────────────────────┐
│  DialogueRunner.ExecuteStep(step)                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. [await] 背景変更                                     │
│     └─ step.hasBackground が前回と異なる場合のみ         │
│                                                         │
│  2. [await] 立ち絵変更                                   │
│     └─ left/right それぞれ変更があれば遷移               │
│     └─ 左右同時変更は並列実行可                          │
│                                                         │
│  3. [await] テキストボックス切り替え                     │
│     └─ displayMode が前回と異なる場合のみ                │
│                                                         │
│  4. [並列] テキスト表示 + 雑音発火                       │
│     ├─ ui.ShowText(speaker, text)                       │
│     └─ ui.PlayNoise(noises)  ← 待機しない               │
│                                                         │
│  5. [await] ユーザー入力待ち                             │
│     └─ クリック or タップ                                │
│     └─ スキップ時: AccelerateNoises() 呼び出し          │
│                                                         │
│  6. [await] 選択肢表示（あれば）                         │
│     └─ ui.ShowChoices(labels, ids)                      │
│     └─ 選択結果を記録                                    │
│                                                         │
│  7. [await] Effect実行                                   │
│     └─ step.effects を順次実行                          │
│     └─ 選択肢がある場合: 選択されたchoice.effectsも実行  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### シーケンス図

```
DialogueRunner    INovelEventUI    PortraitPresenter    NoisePresenter
     │                 │                   │                   │
     │ ShowBackground  │                   │                   │
     │────────────────>│                   │                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
     │ ShowPortrait    │                   │                   │
     │────────────────>│ Show(left,right)  │                   │
     │                 │──────────────────>│                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
     │ SwitchTextBox   │                   │                   │
     │────────────────>│                   │                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
     │ ShowText ───────┼───────────────────┼───────────────────│
     │ PlayNoise ──────┼───────────────────┼──────────────────>│
     │   (並列)        │                   │       (fire&forget)
     │                 │                   │                   │
     │ WaitForInput    │                   │                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
     │ ShowChoices     │                   │                   │
     │────────────────>│                   │                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
     │ ApplyEffects    │                   │                   │
     │    <await>      │                   │                   │
     │                 │                   │                   │
```

### 状態差分検出

無駄な遷移を避けるため、前回状態との差分を検出する。

```csharp
public class DialogueRunner
{
    private DialogueStep previousStep;

    private bool ShouldUpdateBackground(DialogueStep current)
    {
        if (previousStep == null) return current.hasBackground;
        return previousStep.hasBackground != current.hasBackground
            || previousStep.backgroundId != current.backgroundId;
    }

    private bool ShouldUpdatePortrait(PortraitState prev, PortraitState curr, PortraitPosition pos)
    {
        if (prev == null && curr == null) return false;
        if (prev == null || curr == null) return true;
        return prev.characterId != curr.characterId
            || prev.expression != curr.expression;
    }
}
```

---

## データ構造拡張

### DialogueStep（EventStep拡張）

```csharp
[Serializable]
public class DialogueStep
{
    // 基本
    public string speaker;
    public string text;

    // 表示モード
    public DisplayMode displayMode;  // Dinoid / Portrait

    // 立ち絵
    public PortraitState leftPortrait;
    public PortraitState rightPortrait;

    // 背景
    public bool hasBackground;
    public string backgroundId;

    // 雑音
    public NoiseEntry[] noises;

    // 選択肢
    public DialogueChoice[] choices;

    // Effect
    public EffectSO[] effects;
}

[Serializable]
public class PortraitState
{
    public string characterId;
    public string expression;      // 表情ID
    public Sprite portraitSprite;  // 直接指定も可
    public PortraitTransition transitionType;  // None/Rockman/SlideTop/SlideBottom
}

[Serializable]
public class NoiseEntry
{
    public string speaker;
    public string text;

    [Header("再生ルール")]
    public float delaySeconds;            // 発火からの遅延（0〜）
    public float speedMultiplier = 1f;    // 速度倍率（0.5〜2.0）
    public float verticalOffset;          // Y位置オフセット（散らし用）
}

// NoisePresenterでの再生ルール
// - 各NoiseEntryは delaySeconds 後に発火
// - 速度 = baseSpeed * speedMultiplier
// - Y位置 = baseY + verticalOffset + Random(-scatterRange, +scatterRange)
// - Accelerate()呼び出し時: 残り時間を1/3に短縮
// - 滞留防止: 画面外に出たら即destroy

public enum DisplayMode { Dinoid, Portrait }
public enum PortraitTransition { None, Rockman, SlideTop, SlideBottom }
```

### FieldDialogueSO

```csharp
[CreateAssetMenu(menuName = "Walk/Field Dialogue")]
public class FieldDialogueSO : ScriptableObject
{
    [SerializeField] private DialogueStep[] steps;
    public DialogueStep[] Steps => steps;
}
```

### EventDialogueSO（将来）

```csharp
[CreateAssetMenu(menuName = "Walk/Event Dialogue")]
public class EventDialogueSO : ScriptableObject
{
    [SerializeField] private DialogueStep[] steps;
    [SerializeField] private bool allowBacktrack;  // 戻る機能
    public DialogueStep[] Steps => steps;
    public bool AllowBacktrack => allowBacktrack;
}
```

---

## INovelEventUI詳細

> **注**: インターフェース定義は「互換性戦略」セクションを参照。
> ここでは各メソッドの責務と引数設計を詳述する。

### メソッド一覧と責務

```csharp
public interface INovelEventUI : IEventUI
{
    // ===== 立ち絵 =====
    // PortraitStateにtransitionTypeが含まれるため、別引数は不要
    UniTask ShowPortrait(PortraitState left, PortraitState right);
    UniTask HidePortrait(PortraitPosition position);

    // ===== 背景 =====
    UniTask ShowBackground(string backgroundId);
    UniTask HideBackground();

    // ===== 雑音 =====
    // NoiseEntryに再生ルール（delay, speed, offset）が含まれる
    void PlayNoise(NoiseEntry[] entries);
    void AccelerateNoises();

    // ===== テキスト =====
    // speakerを受け取ることでディノイドモードでのアイコン表示にも対応
    UniTask ShowText(string speaker, string text);
    UniTask SwitchTextBox(DisplayMode mode);

    // ===== 状態 =====
    DisplayMode CurrentDisplayMode { get; }
}
```

### 引数設計の根拠

| メソッド | 引数 | 根拠 |
|---------|------|------|
| ShowPortrait | PortraitState left/right | transitionTypeはState内に含むため重複排除 |
| ShowText | speaker, text | DialogueStepのspeakerを直接渡す。モードに応じて表示方法が変わる |
| PlayNoise | NoiseEntry[] | 再生ルール（delay/speed/offset）はEntry内に含む |

### モード別ShowTextの挙動

| DisplayMode | speaker の扱い | text の扱い |
|-------------|---------------|-------------|
| Dinoid | アイコン表示（PortraitDBから取得） | MessageDropper + テキストボックス |
| Portrait | 話者名ラベルに表示 | テキストボックスのみ |

---

## 新規Presenter一覧

### PortraitPresenter

```csharp
public class PortraitPresenter : MonoBehaviour
{
    [SerializeField] private Image leftImage;
    [SerializeField] private Image rightImage;
    [SerializeField] private PortraitDatabase portraitDB;

    [Header("トランジション設定")]
    [SerializeField] private float transitionDuration = 0.3f;
    [SerializeField] private float rainBarDuration = 0.35f;  // ロックマン案用

    /// <summary>
    /// 立ち絵を表示する。
    /// transitionTypeはPortraitState内に含まれるため、別引数は不要。
    /// </summary>
    public async UniTask Show(PortraitState left, PortraitState right)
    {
        // left/right それぞれのtransitionTypeを参照
        var leftTask = left != null ? ShowSingle(left, PortraitPosition.Left) : UniTask.CompletedTask;
        var rightTask = right != null ? ShowSingle(right, PortraitPosition.Right) : UniTask.CompletedTask;
        await UniTask.WhenAll(leftTask, rightTask);
    }

    private async UniTask ShowSingle(PortraitState state, PortraitPosition pos)
    {
        // state.transitionType に基づいてアニメーション選択
        switch (state.transitionType)
        {
            case PortraitTransition.Rockman:
                await PlayRockmanTransition(state, pos);
                break;
            case PortraitTransition.SlideTop:
                await PlaySlideFromTop(state, pos);
                break;
            case PortraitTransition.SlideBottom:
                await PlaySlideFromBottom(state, pos);
                break;
            default:
                await PlayFadeIn(state, pos);
                break;
        }
    }

    public async UniTask Hide(PortraitPosition position);
    public async UniTask Exit(PortraitPosition position);  // 捌ける（横にスライドアウト）
}
```

### BackgroundPresenter

```csharp
public class BackgroundPresenter : MonoBehaviour
{
    [SerializeField] private Image backgroundImage;
    [SerializeField] private BackgroundDatabase backgroundDB;

    public async UniTask Show(string backgroundId);
    public async UniTask Hide();
    public async UniTask SlideIn(string backgroundId);
}
```

### NoisePresenter

```csharp
public class NoisePresenter : MonoBehaviour
{
    [SerializeField] private RectTransform noiseContainer;
    [SerializeField] private GameObject noisePrefab;

    [Header("再生設定")]
    [SerializeField] private float baseSpeed = 200f;        // px/sec
    [SerializeField] private float scatterRange = 50f;      // Y散らし範囲
    [SerializeField] private float accelerateMultiplier = 3f;

    private List<NoiseInstance> activeNoises = new();

    /// <summary>
    /// 雑音を再生する。各NoiseEntryの再生ルールに従う。
    /// </summary>
    public void Play(NoiseEntry[] entries)
    {
        foreach (var entry in entries)
        {
            // delaySeconds後に発火
            StartCoroutine(SpawnAfterDelay(entry));
        }
    }

    private IEnumerator SpawnAfterDelay(NoiseEntry entry)
    {
        if (entry.delaySeconds > 0)
            yield return new WaitForSeconds(entry.delaySeconds);

        var instance = Instantiate(noisePrefab, noiseContainer);
        var yPos = entry.verticalOffset + NRandom.Float(-scatterRange, scatterRange);
        instance.transform.localPosition = new Vector3(Screen.width, yPos, 0);

        var noise = new NoiseInstance
        {
            gameObject = instance,
            speed = baseSpeed * entry.speedMultiplier,
            text = entry.text,
            speaker = entry.speaker
        };
        activeNoises.Add(noise);
    }

    /// <summary>
    /// 全ての雑音を加速する（セリフ飛ばし時）。
    /// </summary>
    public void Accelerate()
    {
        foreach (var noise in activeNoises)
        {
            noise.speed *= accelerateMultiplier;
        }
    }

    private void Update()
    {
        // 画面外に出たら削除
        for (int i = activeNoises.Count - 1; i >= 0; i--)
        {
            var noise = activeNoises[i];
            if (noise.gameObject.transform.localPosition.x < -noise.width)
            {
                Destroy(noise.gameObject);
                activeNoises.RemoveAt(i);
            }
        }
    }
}

public class NoiseInstance
{
    public GameObject gameObject;
    public float speed;
    public string text;
    public string speaker;
    public float width;
}
```

### TextBoxPresenter

```csharp
public class TextBoxPresenter : MonoBehaviour
{
    [SerializeField] private GameObject dinoidTextBox;
    [SerializeField] private GameObject portraitTextBox;
    [SerializeField] private Image dinoidIcon;
    [SerializeField] private TMP_Text dinoidText;
    [SerializeField] private TMP_Text portraitSpeakerName;
    [SerializeField] private TMP_Text portraitText;

    public async UniTask SwitchMode(DisplayMode mode);
    public void SetText(string speaker, string text, DisplayMode mode);
}
```

---

## Effect拡張一覧

| Effect | 用途 | ファイル |
|--------|------|---------|
| ShowPortraitEffect | 立ち絵表示 | 新規 |
| HidePortraitEffect | 立ち絵非表示 | 新規 |
| ShowBackgroundEffect | 背景表示 | 新規 |
| HideBackgroundEffect | 背景非表示 | 新規 |
| PlayNoiseEffect | 雑音再生 | 新規 |
| SwitchDisplayModeEffect | モード切り替え | 新規 |
| SetSpiritualPropertyEffect | 精神属性変更 | 既存確認 |

---

## 強制イベント（歩数/確率トリガー）

### NodeSOへの追加

```csharp
// NodeSO.cs に追加
[Serializable]
public class ForcedEventTrigger
{
    [Header("識別")]
    public string triggerId;              // 消費済み管理用の一意ID

    [Header("発火条件")]
    public ForcedEventType type;          // Steps / Probability
    public int stepCount;                 // 歩数条件（type=Steps時）
    public float probability;             // 確率条件 0-1（type=Probability時）
    public ConditionSO[] conditions;      // 追加条件（フラグ等）

    [Header("発火制御")]
    public bool consumeOnTrigger;         // true: 1回限り、false: 繰り返し可
    public int cooldownSteps;             // 再発火までの歩数（0=即再発火可）
    public int maxTriggerCount;           // 最大発火回数（0=無制限）

    [Header("内容")]
    public FieldDialogueSO dialogue;
}

public enum ForcedEventType { Steps, Probability }
```

### 発火状態の管理

```csharp
// ForcedEventState.cs（新規）
[Serializable]
public class ForcedEventState
{
    public string triggerId;
    public bool consumed;                 // 消費済みか
    public int triggerCount;              // 発火回数
    public int stepsSinceLastTrigger;     // 前回発火からの歩数
}

// ForcedEventStateManager.cs（新規）
public class ForcedEventStateManager
{
    private Dictionary<string, ForcedEventState> states = new();

    public bool CanTrigger(ForcedEventTrigger trigger)
    {
        if (!states.TryGetValue(trigger.triggerId, out var state))
        {
            return true;  // 初回は発火可能
        }

        // 消費済みチェック
        if (trigger.consumeOnTrigger && state.consumed)
            return false;

        // 最大回数チェック
        if (trigger.maxTriggerCount > 0 && state.triggerCount >= trigger.maxTriggerCount)
            return false;

        // クールダウンチェック
        if (state.stepsSinceLastTrigger < trigger.cooldownSteps)
            return false;

        return true;
    }

    public void RecordTrigger(string triggerId, bool consume)
    {
        if (!states.TryGetValue(triggerId, out var state))
        {
            state = new ForcedEventState { triggerId = triggerId };
            states[triggerId] = state;
        }

        state.triggerCount++;
        state.stepsSinceLastTrigger = 0;
        if (consume) state.consumed = true;
    }

    public void IncrementSteps()
    {
        foreach (var state in states.Values)
        {
            state.stepsSinceLastTrigger++;
        }
    }
}
```

### AreaControllerへの組み込み

```csharp
// AreaController.cs
private ForcedEventStateManager forcedEventStateManager;

// WalkStep() 内、遭遇判定の前に追加
private async UniTask CheckForcedEvents()
{
    // 歩数カウント更新
    forcedEventStateManager.IncrementSteps();

    var triggers = currentNode.ForcedEventTriggers;
    foreach (var trigger in triggers)
    {
        // 発火可能かチェック
        if (!forcedEventStateManager.CanTrigger(trigger))
            continue;

        // 条件チェック
        if (!CheckConditions(trigger.conditions))
            continue;

        // 発火判定
        bool shouldTrigger = trigger.type switch
        {
            ForcedEventType.Steps => CheckStepsTrigger(trigger),
            ForcedEventType.Probability => CheckProbabilityTrigger(trigger),
            _ => false
        };

        if (shouldTrigger)
        {
            // 状態記録
            forcedEventStateManager.RecordTrigger(
                trigger.triggerId,
                trigger.consumeOnTrigger
            );

            // 会話実行
            await TriggerFieldDialogue(trigger.dialogue);

            // 1歩で1件のみ発火
            return;
        }
    }
}

private bool CheckStepsTrigger(ForcedEventTrigger trigger)
{
    // 現在ノードでの歩数が条件を満たすか
    return currentNodeSteps >= trigger.stepCount;
}

private bool CheckProbabilityTrigger(ForcedEventTrigger trigger)
{
    // 毎歩確率判定
    return NRandom.Float() < trigger.probability;
}
```

### 発火制約まとめ

| 制約 | 実装 |
|------|------|
| 1歩で最大1件 | `CheckForcedEvents()`内でreturn |
| 1回限り発火 | `consumeOnTrigger=true` + `consumed`フラグ |
| 最大N回発火 | `maxTriggerCount` + `triggerCount` |
| 再発火クールダウン | `cooldownSteps` + `stepsSinceLastTrigger` |
| 条件付き発火 | `conditions[]`でフラグ等を確認 |

---

## WalkStep統合詳細

### 現在のWalkStep処理順序（AreaController.cs:105-220）

```
WalkStep()
├── 1. RefreshWithoutStep処理（巻き戻し後）
├── 2. onEnterイベント発火（ノード初回入場時）
├── 3. カウンタ進行（Counters.Advance）
├── 4. トラック進捗更新
├── 5. サイドオブジェクトクールダウン進行
├── 6. 遭遇オーバーレイ進行
├── 7. サイドオブジェクト抽選（RollPair）
├── 8. 中央オブジェクトチェック
├── 9. アプローチオブジェクト表示
├── 10. ゲートチェック ← ゲート発生時はここでreturn
├── 11. 遭遇判定（EncounterResolver.Resolve）
├── 12. 戦闘実行（BattleRunner.RunBattleAsync）
├── 13. アプローチ処理（HandleApproach）← ユーザー選択
└── 14. 出口チェック
```

### 強制イベント挿入位置

**ゲートと遭遇の間（10と11の間）に挿入**

```csharp
// AreaController.WalkStep() 修正案

// 10. ゲートチェック（既存）
var gateHandled = await CheckGates();
if (gateHandled) return;

// 10.5 強制イベントチェック（新規）
var forcedEventHandled = await CheckForcedEvents();
if (forcedEventHandled) return;

// 11. 遭遇判定（既存）
var encounterResult = encounterResolver.Resolve(...);
```

### 強制イベント発火時の挙動

| 項目 | ゲート発火時 | 強制イベント発火時 | 備考 |
|------|-------------|-------------------|------|
| サイドオブジェクト | 表示済み（選択不可） | 表示済み（選択不可） | 同じ挙動 |
| 中央オブジェクト | 表示済み（選択不可） | 表示済み（選択不可） | 同じ挙動 |
| 遭遇判定 | スキップ | スキップ | 同じ挙動 |
| アプローチ処理 | スキップ | スキップ | 同じ挙動 |
| 出口チェック | スキップ | スキップ | 同じ挙動 |

### 競合しない理由

1. **IBattleRunner との競合なし**
   - `BattleRunner.RunBattleAsync()` は遭遇判定の後に呼ばれる
   - 強制イベントは遭遇判定の前に処理され、発火時は遭遇判定をスキップ
   - 両者は排他的に動作

2. **IEventUI との競合なし**
   - 既存の `IEventUI` は変更しない
   - `INovelEventUI` は `IEventUI` を継承し、追加機能のみ
   - `WalkingEventUI`（既存実装）はそのまま動作

3. **ゲートとの競合なし**
   - ゲートチェックの後に強制イベントチェックを行う
   - ゲートが発火したら強制イベントチェックは実行されない

4. **サイドオブジェクト/中央オブジェクトとの競合なし**
   - 抽選・表示は強制イベントチェックの前に完了
   - 強制イベント発火時はアプローチ処理がスキップされるだけ

### GameContext統合

```csharp
// GameContext.cs 修正
public sealed class GameContext
{
    // 既存
    public IBattleRunner BattleRunner { get; set; }
    public IEventUI EventUI { get; set; }

    // 新規追加
    public IDialogueRunner DialogueRunner { get; set; }
    public ForcedEventStateManager ForcedEventStateManager { get; set; }
}
```

### CheckForcedEvents の戻り値

```csharp
// bool を返すように修正（ゲートと同じパターン）
private async UniTask<bool> CheckForcedEvents()
{
    // ... 判定処理 ...

    if (shouldTrigger)
    {
        // DialogueRunner経由で会話実行
        var dialogueContext = new DialogueContext
        {
            GameContext = context,
            Dialogue = trigger.dialogue
        };
        await context.DialogueRunner.RunDialogueAsync(dialogueContext);

        return true;  // 発火したらtrue
    }

    return false;  // 発火しなかったらfalse
}
```

---

## 実装フェーズ

### Phase 1: 基盤整備 ✅ 完了

**目標**: インターフェース定義とデータ構造の確立

| タスク | 状態 |
|--------|------|
| IDialogueRunner定義（IBattleRunnerパターン） | ✅ |
| DialogueContext/DialogueResult定義 | ✅ |
| DialogueStep構造体定義 | ✅ |
| FieldDialogueSO作成 | ✅ |
| INovelEventUI定義（IEventUI継承） | ✅ |
| NovelPartEventUI骨格 | ✅ |
| GameContext.DialogueRunner追加 | ✅ |

### Phase 2: Presenter層 ✅ 完了

**目標**: 視覚要素の表示システム

| タスク | 状態 |
|--------|------|
| TextBoxPresenter | ✅ |
| PortraitPresenter | ✅ |
| BackgroundPresenter | ✅ |
| NoisePresenter | ✅ |
| PortraitDatabase / BackgroundDatabase | ✅ |

### Phase 3: トランジション ✅ 完了

**目標**: 演出システム（LitMotion統合）

| タスク | 状態 |
|--------|------|
| 立ち絵登場3案実装（None/Rockman/SlideTop/SlideBottom） | ✅ |
| 立ち絵退場（捌ける） | ✅ |
| テキストボックス切り替え（ダンロン風） | ✅ |
| 背景フェード/スライドイン | ✅ |

### Phase 4: Effect実装 ✅ 完了

**目標**: 歩行システムからの呼び出し

| タスク | 状態 |
|--------|------|
| ShowPortraitEffect | ✅ |
| HidePortraitEffect | ✅ |
| ShowBackgroundEffect | ✅ |
| HideBackgroundEffect | ✅ |
| PlayNoiseEffect | ✅ |
| SwitchDisplayModeEffect | ✅ |

### Phase 5: 統合 ✅ 完了

**目標**: 歩行システムとの完全統合（IBattleRunnerパターンに準拠）

| タスク | 状態 |
|--------|------|
| NovelPartDialogueRunner実装 | ✅ |
| ForcedEventTrigger定義 | ✅ |
| ForcedEventState/StateManager実装 | ✅ |
| NodeSO.ForcedEventTriggers追加 | ✅ |
| GameContext.ForcedEventStateManager追加 | ✅ |
| AreaController.CheckForcedEvents()追加 | ✅ |
| WalkingSystemManager初期化修正 | ✅ |

### Phase 6: イベント会話 ✅ 完了

**目標**: 戻る機能、バックログシステム

| タスク | 状態 |
|--------|------|
| EventDialogueSO | ✅ |
| DialogueBacklog（バックログシステム） | ✅ |
| DialogueStateSnapshot（状態スナップショット） | ✅ |
| NovelPartDialogueRunner戻る機能統合 | ✅ |
| INovelEventUI/NovelPartEventUI拡張 | ✅ |
| Presenter即座復元メソッド追加 | ✅ |

---

## ファイル構成

```
Assets/Script/Walk/
├── EventKernel/
│   ├── EventDefinitionSO.cs      （既存：変更なし）
│   ├── EventRunner.cs            （既存：変更なし）
│   ├── EventHost.cs              （既存：変更なし）
│   ├── WalkingEventUI.cs         （既存：変更なし）
│   ├── IEventUI.cs               （既存：EventRunner.csから分離、内容変更なし）
│   ├── INovelEventUI.cs          （新規：拡張インターフェース）
│   └── NovelPartEventUI.cs       （新規：INovelEventUI実装）
│
├── Dialogue/
│   ├── DialogueDefinitionSO.cs   （既存→廃止予定）
│   ├── DialogueNode.cs           （既存→廃止予定）
│   ├── IDialogueRunner.cs        （新規：IBattleRunnerパターン）
│   ├── DialogueContext.cs        （新規）
│   ├── DialogueResult.cs         （新規）
│   ├── NovelPartDialogueRunner.cs（新規：IDialogueRunner実装）
│   ├── DialogueStep.cs           （新規）
│   ├── NoiseEntry.cs             （新規）
│   ├── PortraitState.cs          （新規）
│   ├── FieldDialogueSO.cs        （新規）
│   └── EventDialogueSO.cs        （新規：将来）
│
├── ForcedEvent/
│   ├── ForcedEventTrigger.cs     （新規）
│   ├── ForcedEventState.cs       （新規）
│   └── ForcedEventStateManager.cs（新規）
│
├── Presentation/
│   ├── CentralObjectPresenter.cs （既存）
│   ├── SideObjectPresenter.cs    （既存）
│   ├── PortraitPresenter.cs      （新規）
│   ├── BackgroundPresenter.cs    （新規）
│   ├── NoisePresenter.cs         （新規）
│   ├── NoiseInstance.cs          （新規）
│   └── TextBoxPresenter.cs       （新規）
│
├── Effects/
│   ├── ShowMessageEffect.cs      （既存）
│   ├── ShowPortraitEffect.cs     （新規）
│   ├── HidePortraitEffect.cs     （新規）
│   ├── ShowBackgroundEffect.cs   （新規）
│   ├── HideBackgroundEffect.cs   （新規）
│   ├── PlayNoiseEffect.cs        （新規）
│   └── SwitchDisplayModeEffect.cs（新規）
│
└── Data/
    ├── PortraitDatabase.cs       （新規）
    └── BackgroundDatabase.cs     （新規）
```

---

## 既存システムとの共存

### MessageDropper

- フィールド会話（ディノイドモード）で継続使用
- ログが流れていく動作はそのまま維持
- IEventUI.ShowMessage()経由で呼び出し

### CentralObjectPresenter

- 中央オブジェクトのズーム時に使用
- ノベルパートUIとは別レイヤー（Z-order管理）

### WalkApproachUI

- サイドオブジェクト/ゲート選択は既存のまま
- ノベルパート発火後はTextBoxPresenterに切り替え

---

## テスト計画

### Phase 1-2 完了時

- [ ] ディノイドモードでテキスト表示
- [ ] 立ち絵モードでテキスト表示
- [ ] モード切り替えアニメーション
- [ ] 左右立ち絵の表示/非表示

### Phase 3 完了時

- [ ] 立ち絵登場3案のアニメーション
- [ ] 立ち絵退場（捌ける）
- [ ] 背景スライドイン
- [ ] テキストボックス切り替え演出

### Phase 4 完了時

- [ ] Effectからの立ち絵制御
- [ ] Effectからの背景制御
- [ ] 雑音の発生と流れ
- [ ] 雑音の加速（セリフ飛ばし時）

### Phase 5 完了時

- [ ] サイドオブジェクトからのフィールド会話起動
- [ ] 中央オブジェクトからのフィールド会話起動
- [ ] OnEnterイベントでのフィールド会話
- [ ] 強制イベント（歩数トリガー）
- [ ] 精神属性の変化

### 負系テスト（全Phase共通）

#### 互換性・移行

- [ ] 既存WalkingEventUIがコンパイル通ること
- [ ] 既存EventDefinitionSOが動作すること
- [ ] 既存EventRunnerがIEventUI経由で動作すること
- [ ] NovelPartEventUI未設定時のフォールバック

#### スキップ・連打

- [ ] セリフ送り連打時の雑音Accelerate動作
- [ ] トランジション中のスキップ処理
- [ ] 選択肢表示中のスキップ無効化
- [ ] 立ち絵登場中のスキップでアニメ完了まで待機

#### 強制イベント多重発火防止

- [ ] 1歩で複数トリガー条件を満たしても1件のみ発火
- [ ] consumeOnTrigger=true のイベントが2回発火しないこと
- [ ] cooldownSteps=5 設定時、5歩以内に再発火しないこと
- [ ] maxTriggerCount=3 設定時、4回目が発火しないこと

#### 確率トリガーの再現性

- [ ] 同一シード値で同一結果が得られること（NRandom使用時）
- [ ] probability=0 で絶対に発火しないこと
- [ ] probability=1 で確実に発火すること（他条件満たす場合）

#### 状態不整合

- [ ] ノード移動後も強制イベント状態が維持されること
- [ ] セーブ/ロード後も強制イベント状態が復元されること
- [ ] 会話中にアプリ終了→再開で状態が壊れないこと

#### UI重複・Z-order

- [ ] 立ち絵表示中に別の立ち絵登場でz-indexが正しいこと
- [ ] 雑音が立ち絵より前面に表示されること
- [ ] テキストボックスが最前面に表示されること
- [ ] 複数雑音が重ならず散らばること

---

## リスクと対策

### リスク1: 既存EventDefinitionSOとの互換性

**対策**: FieldDialogueSOは新規作成、既存SOは段階的に移行

### リスク2: パフォーマンス（立ち絵表示）

**対策**:
- Sprite Atlasで立ち絵をまとめる
- ObjectPoolでPrefab再利用

### リスク3: トランジションの調整工数

**対策**:
- HTMLモックで事前検証済み
- LitMotionでイージング調整を容易に

---

## 備考

- 全Phase (1-6) 実装完了
- 使い方は [ノベルパート使い方ガイド.md](./ノベルパート使い方ガイド.md) を参照
- 各Phaseの完了時にHTMLモックとの動作比較を行う
- Prefab作成とUI配置は手動で行う必要あり
