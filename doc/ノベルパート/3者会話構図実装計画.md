# 3者会話構図実装計画

## 概要

「3者会話構図設計」を実現するための実装計画。
歩行システムの中央オブジェクトを会話相手として扱い、ノベルパート中にスプライトを変更可能にする。

## 関連ドキュメント

- [3者会話構図設計.md](./3者会話構図設計.md) - 設計本体
- [ノベルパート設計.md](./ノベルパート設計.md) - ノベルパート基盤設計
- [ノベルパート実装計画.md](../終了済み/ノベルパート実装計画.md) - 基盤実装（完了済み）

---

## 現状分析

### 調査結果サマリ

| ファイル | 必要な追加 | 現状 |
|----------|-----------|------|
| CentralObjectPresenter | `UpdateSprite()`, `GetCurrentSprite()` | ❌ 未実装 |
| DialogueStep | `centralObjectSprite` フィールド | ❌ 未実装 |
| INovelEventUI | `UpdateCentralObjectSprite()` | ❌ 未実装 |
| NovelPartEventUI | CentralObjectPresenter統合 | ❌ 未実装 |
| NovelPartDialogueRunner | 中央オブジェクト更新処理 | ❌ 未実装 |
| DialogueStateSnapshot | `CentralObjectSprite` フィールド | ❌ 未実装 |
| DialogueContext | CentralObjectPresenter参照 | ❌ 未実装（CentralObjectRTのみ） |

### 既存ファイルパス

```
Assets/Script/Walk/
├── Presentation/
│   └── CentralObjectPresenter.cs
├── Dialogue/
│   ├── DialogueStep.cs
│   ├── DialogueContext.cs
│   ├── DialogueStateSnapshot.cs
│   └── NovelPartDialogueRunner.cs
└── EventKernel/
    ├── INovelEventUI.cs
    └── NovelPartEventUI.cs
```

---

## 実装タスク

### Task 1: CentralObjectPresenter拡張

**ファイル**: `Assets/Script/Walk/Presentation/CentralObjectPresenter.cs`

```csharp
// 追加メソッド

/// <summary>
/// スプライトのみを変更する（位置・サイズは維持）。
/// ノベルパート中の中央オブジェクト変更用。
/// </summary>
public void UpdateSprite(Sprite sprite)
{
    if (image == null) return;
    image.sprite = sprite ?? GetFallbackSprite();
}

/// <summary>
/// 現在のスプライトを取得する。
/// 状態復元用。
/// </summary>
public Sprite GetCurrentSprite()
{
    return image?.sprite;
}
```

**依存**: なし（最初に実装）

---

### Task 2: DialogueStep拡張

**ファイル**: `Assets/Script/Walk/Dialogue/DialogueStep.cs`

```csharp
// 追加フィールド

[Header("中央オブジェクト")]
[SerializeField] private Sprite centralObjectSprite;

public Sprite CentralObjectSprite => centralObjectSprite;
public bool HasCentralObjectChange => centralObjectSprite != null;
```

**設計方針**:
- `null` = 変更なし（前の状態維持）
- 値あり = 変更
- 左右立ち絵と同じパターン

---

### Task 3: DialogueStateSnapshot拡張

**ファイル**: `Assets/Script/Walk/Dialogue/DialogueStateSnapshot.cs`

```csharp
// 追加フィールド
public Sprite CentralObjectSprite { get; set; }
```

**ApplyStepメソッド修正**:
```csharp
// ApplyStep内に追加
if (step.HasCentralObjectChange)
{
    this.CentralObjectSprite = step.CentralObjectSprite;
}
```

---

### Task 4: INovelEventUI拡張

**ファイル**: `Assets/Script/Walk/EventKernel/INovelEventUI.cs`

```csharp
// 追加メソッド

/// <summary>
/// 中央オブジェクトのスプライトを変更する。
/// ズーム中の会話でのみ有効。
/// </summary>
void UpdateCentralObjectSprite(Sprite sprite);
```

---

### Task 5: NovelPartEventUI実装

**ファイル**: `Assets/Script/Walk/EventKernel/NovelPartEventUI.cs`

```csharp
// 追加フィールド（UIレイヤーで完結する方針B）
private CentralObjectPresenter centralObjectPresenter;

/// <summary>
/// CentralObjectPresenterを設定する。
/// WalkingSystemManager初期化時に呼び出す。
/// </summary>
public void SetCentralObjectPresenter(CentralObjectPresenter presenter)
{
    centralObjectPresenter = presenter;
}

// INovelEventUI実装
public void UpdateCentralObjectSprite(Sprite sprite)
{
    centralObjectPresenter?.UpdateSprite(sprite);
}
```

**RestoreState修正**:
```csharp
// RestoreState内に追加
if (snapshot.CentralObjectSprite != null)
{
    UpdateCentralObjectSprite(snapshot.CentralObjectSprite);
}
```

---

### Task 6: NovelPartDialogueRunner統合

**ファイル**: `Assets/Script/Walk/Dialogue/NovelPartDialogueRunner.cs`

**ExecuteStep内に追加**:
```csharp
private async UniTask ExecuteStep(DialogueStep step, DialogueContext context, int index)
{
    // 既存の処理...
    // 1. 背景変更
    // 2. 立ち絵変更

    // 3. 中央オブジェクト変更（新規追加）
    if (step.HasCentralObjectChange && context.CentralObjectRT != null)
    {
        ui.UpdateCentralObjectSprite(step.CentralObjectSprite);
    }

    // 4. テキストボックス切り替え
    // 5. テキスト表示 + 雑音発火
    // ... 残りの処理
}
```

**スナップショット作成時の追加**:
```csharp
// CreateSnapshot内に追加
snapshot.CentralObjectSprite = centralObjectPresenter?.GetCurrentSprite();
```

---

### Task 7: WalkingSystemManager初期化

**ファイル**: `Assets/Script/Walk/WalkingSystemManager.cs`（または初期化担当）

```csharp
// NovelPartEventUI初期化時にCentralObjectPresenterを設定
novelPartEventUI.SetCentralObjectPresenter(centralObjectPresenter);
```

---

## 実装フェーズ

### Phase 1: 基盤（単体で動作確認可能）

| タスク | 内容 | 依存 |
|--------|------|------|
| Task 1 | CentralObjectPresenter.UpdateSprite/GetCurrentSprite | なし |
| Task 2 | DialogueStep.centralObjectSprite | なし |
| Task 3 | DialogueStateSnapshot.CentralObjectSprite | なし |

### Phase 2: UI層

| タスク | 内容 | 依存 |
|--------|------|------|
| Task 4 | INovelEventUI.UpdateCentralObjectSprite | Task 1 |
| Task 5 | NovelPartEventUI実装 | Task 1, 4 |

### Phase 3: 統合

| タスク | 内容 | 依存 |
|--------|------|------|
| Task 6 | NovelPartDialogueRunner統合 | Task 2, 3, 4 |
| Task 7 | WalkingSystemManager初期化 | Task 5 |

---

## 変更検出ロジック

既存の立ち絵変更検出と同じパターンを採用。

```csharp
// NovelPartDialogueRunner.cs に追加
private Sprite previousCentralObjectSprite;

private bool ShouldUpdateCentralObject(DialogueStep current)
{
    if (!current.HasCentralObjectChange) return false;
    if (previousCentralObjectSprite == null) return true;
    return previousCentralObjectSprite != current.CentralObjectSprite;
}
```

---

## テスト計画

### Phase 1 完了時

- [ ] CentralObjectPresenter.UpdateSprite()でスプライトが変わること
- [ ] CentralObjectPresenter.GetCurrentSprite()で現在のスプライトが取得できること
- [ ] DialogueStep.HasCentralObjectChangeがnull時false、値あり時trueを返すこと

### Phase 2 完了時

- [ ] NovelPartEventUI.UpdateCentralObjectSprite()が動作すること
- [ ] CentralObjectPresenter未設定時にNullRefが発生しないこと

### Phase 3 完了時

- [ ] ノベルパート中に中央オブジェクトのスプライトが変更されること
- [ ] centralObjectSprite未指定時は前の状態が維持されること
- [ ] 「戻る」機能で中央オブジェクトのスプライトが復元されること
- [ ] ノベルパート終了後も変更されたスプライトが維持されること

### 構図バリエーションテスト

| 構図 | 左立ち絵 | 右立ち絵 | 中央オブジェクト | テスト内容 |
|------|---------|---------|----------------|-----------|
| 左右対話 | ✅ | ✅ | - | 既存動作に影響なし |
| 三者会話 | ✅ | ✅ | ✅ 変更可能 | 中央が変化しながら会話 |
| 問い詰め | ✅ | ✅ | ✅ 固定 | 中央は変化なし |
| 中央のみ | - | - | ✅ 変更可能 | 左右立ち絵なしで中央のみ |

---

## 制約事項

1. **ズーム中のみ有効**: 中央オブジェクトが表示されていない状態では変更しても意味がない
2. **位置・サイズは変更不可**: 歩行システムで決定された位置にズームしているため
3. **ノベルパート終了時は変更維持**: 左右立ち絵と同様、元に戻さない

---

## 備考

- 設計方針Bを採用: NovelPartEventUIがCentralObjectPresenterを内部保持（UIレイヤーで完結）
- 実装順序: Phase 1 → Phase 2 → Phase 3 の順で進める
- 各Phase完了時に動作確認を行う
