# ノベルパート仕様書

ノベルパートシステムの技術的な仕様を定義する。
設計（何を作るか）は [ノベルパート設計.md](./ノベルパート設計.md) を参照。
演出仕様（トランジション、モード切替、ズーム等）は [ノベルパート演出総合.md](./ノベルパート演出総合.md) を参照。

---

## 状態ライフサイクル

### 概要

ノベルパートは複数のPresenter（立ち絵、背景、テキストボックス、雑音、中央オブジェクト）が状態を保持する。
これらの状態は「ダイアログ1回分」を単位としてライフサイクルが管理される。

### 三層の役割

| 層 | クラス | 役割 | 状態を持つか |
|----|--------|------|-------------|
| 実行層 | NovelPartDialogueRunner | ステップの順次実行、入力待ち、戻る/バックログ | `previousStep` のみ（セッション内の差分判定用） |
| 統括層 | NovelPartEventUI (INovelEventUI) | Presenterへの委譲、クリーンアップの一括実行 | 持たない（Presenterへの読み通し） |
| 表示層 | 各Presenter | 実際の表示制御と現在の表示状態の保持 | **持つ（唯一の情報源）** |

### 原則

1. **各状態の情報源は1箇所**。同じ情報を複数箇所で持たない
   - DisplayMode → TextBoxPresenter.CurrentMode が唯一の情報源
   - 立ち絵状態 → PortraitPresenter.currentLeftState / currentRightState
   - 背景 → BackgroundPresenter.currentBackgroundId
2. **NovelPartEventUIは状態を複製しない**。Presenterへの読み通しのみ
3. **DialogueRunnerのpreviousStepはセッション内限定**。ダイアログ開始時にnullリセット

### ダイアログのライフサイクル

```
RunDialogueAsync() 開始
│
├── 初期化フェーズ
│   ├── previousStep = null（Runner内部状態リセット）
│   ├── ui.ClearReactions()
│   ├── ui.HideAllAsync()        ← 全Presenterの状態を一括クリア
│   ├── ui.SetProtagonistSpiritualProperty(...)
│   └── ui.SwitchTextBox(initialMode)（必要時）
│
├── ステップ実行ループ（try）
│   └── ExecuteStep()
│       ├── SetTabState()         ← UI可視化（アニメーション前に呼ぶ）
│       ├── 背景変更
│       ├── 立ち絵変更（トランジション再生）
│       ├── テキストボックス切り替え
│       ├── テキスト表示 + 雑音発火
│       └── 入力待ち
│
└── 終了フェーズ（finally — 正常/リアクション/例外いずれでも実行）
    ├── ui.ClearReactions()
    ├── ui.SetBackButtonEnabled(false)
    ├── ui.SetProtagonistSpiritualProperty(null)
    └── ui.SetTabState(TabState.walk)
```

### HideAllAsync() のクリア対象

全Presenterの状態を漏れなくクリアする。新しいPresenterを追加した場合は必ずここに追加すること。

| Presenter | クリア方法 | クリアされる状態 |
|-----------|-----------|----------------|
| PortraitPresenter | ClearAll() | currentLeftState, currentRightState → null |
| BackgroundPresenter | HideImmediate() | currentBackgroundId → null |
| NoisePresenter | ClearAll() | activeNoises → 空、isAccelerated → false |
| TextBoxPresenter | Hide() | テキストクリア、GameObject非アクティブ（currentModeは維持） |
| CentralObjectPresenter | UpdateSprite(null) | スプライトリセット（GameObject自体はWalkingSystem管轄） |
| Reactions | ClearReactions() | currentReactionCallback → null |

### ステップ間の差分判定

各ステップ実行前に「前ステップと変化があるか」を判定し、変化がある場合のみトランジションを再生する。

| 判定 | 情報源 | 判定基準 |
|------|--------|---------|
| 立ち絵更新 | DialogueRunner.previousStep | CharacterId + Expression の一致 |
| 背景更新 | DialogueRunner.previousStep | HasBackground + BackgroundId の一致 |
| モード切替 | DialogueRunner.previousStep | DisplayMode の一致 |

`previousStep` はダイアログ開始時に `null` にリセットされるため、最初のステップでは必ず更新が走る。

**注意**: Presenter側にも「同キャラ同表情ならスキップ」の判定がある（PortraitPresenter.UpdatePortrait）。
HideAllAsync() で Presenter 状態がクリアされていれば、この判定が誤ってスキップすることはない。
つまり HideAllAsync() の漏れは二重にトランジションスキップを引き起こすので、特に注意すること。

---

## 状態復元（戻る機能）

### 復元契約: 部分復元 + ステップ再実行

DialogueStateSnapshotは視覚状態のみを保存する。

| 保存する | 保存しない（再実行で補完） |
|---------|------------------------|
| 立ち絵（LeftPortrait, RightPortrait） | テキスト内容 |
| 背景（HasBackground, BackgroundId） | 雑音（NoiseEntry） |
| DisplayMode | リアクション状態 |
| CentralObject（Sprite, CharacterId, Expression） | |

### 復元フロー

```
戻るリクエスト検出
├── snapshots[currentIndex - 1] を取得
├── ui.RestoreState(snapshot)
│   ├── TextBoxPresenter.SetModeImmediate()    ← トランジションなし
│   ├── PortraitPresenter.RestoreImmediate()   ← トランジションなし
│   ├── BackgroundPresenter.ShowImmediate()     ← トランジションなし
│   └── CentralObjectPresenter.UpdateSprite()
├── previousStep = steps[currentIndex - 1]
└── continue（while ループ先頭へ → 同じステップを再実行）
    └── ExecuteStep() で テキスト・雑音が自然に再発火
```

---

## Presenter一覧と状態管理

| Presenter | 状態フィールド | Initialize() | ClearAll() | 備考 |
|-----------|--------------|-------------|-----------|------|
| PortraitPresenter | currentLeftState, currentRightState, originalPos | あり | あり | |
| BackgroundPresenter | currentBackgroundId, originalPosition | あり | HideImmediate() | ClearAll()メソッドなし、HideImmediateで代用 |
| TextBoxPresenter | currentMode | あり(mode引数) | Clear() + Hide() | DisplayModeの唯一の情報源 |
| NoisePresenter | activeNoises, isAccelerated | あり | あり | OnDisableでもクリア |
| CentralObjectPresenter | viewObject, currentMode, image等 | なし(setter式) | ClearImmediate() | WalkingSystem管轄。ノベルパートからはスプライトのみ操作 |

---

## 責務分離アーキテクチャ

### インターフェース階層

```
IEventUI（基底：ShowMessage, ShowChoices）
│
├── INovelZoomUI（ズーム制御）
│   ├── ZoomToCentralAsync()
│   ├── ExitZoomAsync()
│   ├── RestoreZoomImmediate()
│   ├── UpdateCentralObjectSprite()
│   ├── GetCurrentCentralObjectSprite()
│   ├── GetCurrentCentralObjectCharacterId()
│   └── GetCurrentCentralObjectExpression()
│
├── INovelReactionUI（リアクション制御）
│   ├── SetReactionText()
│   └── ClearReactions()
│
└── INovelEventUI : IEventUI, INovelZoomUI, INovelReactionUI
    ├── Portrait: ShowPortrait, HidePortrait
    ├── Background: ShowBackground, HideBackground
    ├── Text/Noise: ShowText, SwitchTextBox, PlayNoise, AccelerateNoises
    ├── Navigation: ShowBacklog, HideBacklog, ConsumeBackRequest, etc.
    └── State: HideAllAsync, SetTabState, SetProtagonistSpiritualProperty
```

### 実装構造

```
NovelPartEventUI（MonoBehaviour, INovelEventUI）
├── NovelZoomManager（INovelZoomUI実装）
│   ├── NovelZoomController（ズームアニメーション）
│   └── CentralObjectPresenter参照（スプライト操作）
│
├── NovelReactionHandler（INovelReactionUI実装）
│   ├── currentCallback（リアクションコールバック）
│   └── TextBoxPresenter参照（リッチテキスト設定）
│
└── 直接保持
    ├── PortraitPresenter
    ├── BackgroundPresenter
    ├── NoisePresenter
    ├── TextBoxPresenter
    ├── NovelInputHub
    └── 各入力UI（FieldDialogueUI, EventDialogueUI, NovelChoicePresenter）
```

### ファイル配置

| ファイル | 役割 |
|---------|------|
| `Walk/EventKernel/INovelEventUI.cs` | INovelZoomUI, INovelReactionUI, INovelEventUI の3インターフェース定義 |
| `Walk/EventKernel/NovelPartEventUI.cs` | INovelEventUI実装。ズーム/リアクションは委譲 |
| `Walk/Zoom/NovelZoomManager.cs` | INovelZoomUI実装。ZoomControllerとCentralObjectPresenterを内包 |
| `Walk/Presentation/NovelReactionHandler.cs` | INovelReactionUI実装。コールバック管理とTextBoxPresenter連携 |

### 消費者と依存インターフェース

| 消費者 | 使用インターフェース | 備考 |
|--------|-------------------|------|
| NovelPartDialogueRunner | INovelEventUI | 全機能を使用 |
| NovelDialogueStep | INovelEventUI（INovelZoomUI部分） | ZoomToCentralAsync/ExitZoomAsyncのみ使用 |
| 各Effect（ShowPortrait等） | INovelEventUI | プレゼンテーション系メソッドを使用 |
| WalkingSystemManager | NovelPartEventUI（具象型） | SetCentralObjectPresenter注入のみ |

---

## イベント会話のナビゲーション

### 概要

イベント会話（`TabState.EventDialogue`）には3つのナビゲーション機能がある。
これらは完全に独立した機能であり、混同しないこと。

| 機能 | ボタン | 何が起きるか | 状態変化 |
|------|--------|-------------|---------|
| **進む** | SystemRightButton | 次のステップへ進む | あり（通常進行） |
| **戻る（バックトラック）** | SystemLeftButton | 1ステップ巻き戻す | あり（スナップショット復元→再実行） |
| **バックログ** | BackLogButton | ログ一覧パネルを開く | なし（閲覧のみ、閉じたら同じステップに戻る） |

### USERUI側の構造

```
EventDialogueObject (EventDialogueUI)
├── SystemLeftButton   ← prevButton（戻る）
├── SystemRightButton  ← nextButton（進む）
└── BackLogButton      ← backlogButton（バックログ開く）
```

### 入力経路

3つのボタンはすべて `NovelInputHub` を経由してRunnerに通知される。

```
SystemRightButton.onClick → inputHub.NotifyNext()
  → Runner: WaitForNextOrBackAsync() 解決(true) → 次ステップへ

SystemLeftButton.onClick → inputHub.NotifyBack()
  → Runner: WaitForNextOrBackAsync() 解決(false) → backRequested = true
  → ConsumeBackRequest() → スナップショット復元 → 同ステップ再実行

BackLogButton.onClick → inputHub.NotifyBacklog()
  → Runner: ConsumeBacklogRequest() → ui.ShowBacklog(backlog)
  → バックログパネル表示 → 閉じるまで待機 → 同ステップ再表示
```

### SystemLeftButton の表示制御

SystemLeftButton だけ動的に表示/非表示を切り替える。
SystemRightButton と BackLogButton は常に表示。

```csharp
// NovelPartDialogueRunner 内、各ステップ実行前
ui.SetBackButtonEnabled(allowBacktrack && currentIndex > 0);
```

| 条件 | SystemLeftButton |
|------|-----------------|
| `allowBacktrack = false` | **非表示**（戻る機能自体が無効） |
| `allowBacktrack = true` かつ `currentIndex == 0` | **非表示**（最初のステップ、戻る先がない） |
| `allowBacktrack = true` かつ `currentIndex > 0` | **表示** |

**NovelPartEventUI が `backButton` として参照を持つ理由：**
SetActive() による表示/非表示制御が必要なのは Left だけだから。
Right は常に表示、BackLogButton も常に表示なので別途参照は不要。

### 配線マップ

| コンポーネント | フィールド | 配線先 | 用途 |
|--|--|--|--|
| **NovelPartEventUI** | `backlogPageView` | BacklogPanel (FrontFixedContainer/NovelContent内) | バックログUI本体 |
| | `backButton` | SystemLeftButton | 戻るボタンの表示/非表示制御 |
| | `eventDialogueUI` | EventDialogueObject | 入力UIへのハブ設定 |
| **EventDialogueUI** | `prevButton` | SystemLeftButton | 戻るクリック処理 |
| | `nextButton` | SystemRightButton | 進むクリック処理 |
| | `backlogButton` | BackLogButton | バックログ開くクリック処理 |

---

## バックログ

### 概要

バックログは会話の過去セリフを閲覧するためのページ送りUI。
EyeArea全面を覆うオーバーレイとして表示される。
イベント会話（`allowBacktrack = true` または `showBacklog = true`）で有効。

### 仕様

| 項目 | 仕様 |
|------|------|
| 表示形式 | ページ送り（スクロールなし） |
| 表示領域 | EyeArea全面（FrontFixedContainer/NovelContent内） |
| 開く操作 | EventDialogueUI上の BackLogButton |
| 閉じる操作 | パネル上の閉じるボタン（X） |
| 1ページのエントリ数 | BacklogPageView インスペクタで設定（デフォルト8） |
| 最大ページ数 | BacklogPageView インスペクタで設定（デフォルト10） |
| 戻れる範囲 | maxBacktrackPages × linesPerPage ステップまで |
| テキスト折り返し | TMPの自然なワードラップ |

### データ層

```
DialogueBacklog（既存）
├── entries: List<BacklogEntry>（1ステップ = 1エントリ）
├── maxEntries = linesPerPage × maxBacktrackPages（Runner初期化時に計算）
├── Add(stepIndex, step)        ← 各ステップ完了後に記録
├── TruncateTo(stepIndex)       ← 戻る操作時に不要エントリ削除
└── GetRecent(count)            ← 最新N件取得

BacklogEntry
├── StepIndex, Speaker, Text
├── LeftCharacterId, RightCharacterId
├── BackgroundId, DisplayMode
```

### UI層

```
FrontFixedContainer / NovelContent
└── BacklogPanel (BacklogPageView + CanvasGroup + Image半透明黒)
    ├── ContentText (TMP_Text: 全エントリを改行区切りで結合表示)
    ├── Navigation (HorizontalLayoutGroup)
    │   ├── PrevPageButton (<< 古いページへ)
    │   ├── PageIndicator ("3 / 10")
    │   └── NextPageButton (>> 新しいページへ)
    └── CloseButton (X)
```

### ページ計算

- page 0 = 最新ページ（初期表示）
- << = 古いページへ（page++）、>> = 新しいページへ（page--）
- 総ページ数 = min(ceil(totalEntries / linesPerPage), maxBacktrackPages)
- page N のエントリ範囲: `entries[count - (N+1)*linesPerPage .. count - N*linesPerPage - 1]`

### 表示フロー

```
BackLogButton クリック
  → inputHub.NotifyBacklog()
    → backlogRequested = true
    → nextOrBackTcs?.TrySetCanceled()  ← 入力待ちを中断
  → WaitForInput() が OperationCanceledException で終了
  → NovelPartDialogueRunner: ConsumeBacklogRequest() = true
  → await ui.ShowBacklog(backlog)
    → UIBlocker.Acquire(AllContents)  ← USERUI操作ブロック開始
    → BacklogPageView.ShowAsync(backlog)
      → ページ計算・テキスト描画
      → panel.SetActive(true)
      → UniTaskCompletionSource で閉じるまで待機
  → 閉じるボタン or ForceClose()
    → closeTcs.TrySetResult()
    → panel.SetActive(false)
    → UIBlocker解放                   ← USERUI操作ブロック終了
  → continue（同じステップを再表示）
```

### ファイル配置

| ファイル | 役割 |
|---------|------|
| `Walk/Presentation/BacklogPageView.cs` | バックログUI本体。ページ計算・表示・ナビゲーション・閉じる制御 |
| `Walk/Dialogue/DialogueBacklog.cs` | バックログデータ管理（既存） |
| `Walk/Dialogue/DialogueBacklog.cs > BacklogEntry` | 1ステップの履歴データ（既存） |
| `Novel/NovelInputHub.cs` | NotifyBacklog() / ConsumeBacklogRequest()（バックログ通知） |
| `Novel/EventDialogueUI.cs` | BackLogButton のクリック → inputHub.NotifyBacklog() |

### バックログと戻る機能の関係

バックログの保持件数と戻れる範囲は同じ値で制御される。

```csharp
// NovelPartDialogueRunner 初期化時
var maxEntries = ui.BacklogLinesPerPage * ui.BacklogMaxBacktrackPages;
backlog = new DialogueBacklog(maxEntries);

// 戻る範囲のガード
var maxBackSteps = ui.BacklogLinesPerPage * ui.BacklogMaxBacktrackPages;
var earliestAllowed = Math.Max(0, currentIndex - maxBackSteps);
```

例: linesPerPage=8, maxBacktrackPages=10 → 80ステップ分まで遡れる/閲覧可能。
