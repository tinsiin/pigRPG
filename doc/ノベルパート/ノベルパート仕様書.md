# ノベルパート仕様書

ノベルパートシステムの技術的な仕様を定義する。
設計（何を作るか）は [ノベルパート設計.md](./ノベルパート設計.md) を参照。
演出仕様（トランジション、モード切替、ズーム等）は [ノベルパート演出総合.md](./ノベルパート演出総合.md) を参照。

---

## 状態ライフサイクル

### 概要

ノベルパートは複数のPresenter（立ち絵、背景、テキストボックス、雑音、中央オブジェクト）が状態を保持する。
これらの状態は「ダイアログ1回分」を単位としてライフサイクルが管理される。

### 三層の役割

| 層 | クラス | 役割 | 状態を持つか |
|----|--------|------|-------------|
| 実行層 | NovelPartDialogueRunner | ステップの順次実行、入力待ち、戻る/バックログ | `previousStep` のみ（セッション内の差分判定用） |
| 統括層 | NovelPartEventUI (INovelEventUI) | Presenterへの委譲、クリーンアップの一括実行 | 持たない（Presenterへの読み通し） |
| 表示層 | 各Presenter | 実際の表示制御と現在の表示状態の保持 | **持つ（唯一の情報源）** |

### 原則

1. **各状態の情報源は1箇所**。同じ情報を複数箇所で持たない
   - DisplayMode → TextBoxPresenter.CurrentMode が唯一の情報源
   - 立ち絵状態 → PortraitPresenter.currentLeftState / currentRightState
   - 背景 → BackgroundPresenter.currentBackgroundId
2. **NovelPartEventUIは状態を複製しない**。Presenterへの読み通しのみ
3. **DialogueRunnerのpreviousStepはセッション内限定**。ダイアログ開始時にnullリセット

### ダイアログのライフサイクル

```
RunDialogueAsync() 開始
│
├── 初期化フェーズ
│   ├── previousStep = null（Runner内部状態リセット）
│   ├── ui.ClearReactions()
│   ├── ui.HideAllAsync()        ← 全Presenterの状態を一括クリア
│   ├── ui.SetProtagonistSpiritualProperty(...)
│   └── ui.SwitchTextBox(initialMode)（必要時）
│
├── ステップ実行ループ（try）
│   └── ExecuteStep()
│       ├── SetTabState()         ← UI可視化（アニメーション前に呼ぶ）
│       ├── 背景変更
│       ├── 立ち絵変更（トランジション再生）
│       ├── テキストボックス切り替え
│       ├── テキスト表示 + 雑音発火
│       └── 入力待ち
│
└── 終了フェーズ（finally — 正常/リアクション/例外いずれでも実行）
    ├── ui.ClearReactions()
    ├── ui.SetBackButtonEnabled(false)
    ├── ui.SetNextButtonEnabled(true)
    ├── ui.SetCloseButtonVisible(false)
    ├── ui.SetProtagonistSpiritualProperty(null)
    └── ui.SetTabState(TabState.walk)
```

### HideAllAsync() のクリア対象

全Presenterの状態を漏れなくクリアする。新しいPresenterを追加した場合は必ずここに追加すること。

| Presenter | クリア方法 | クリアされる状態 |
|-----------|-----------|----------------|
| PortraitPresenter | ClearAll() | currentLeftState, currentRightState → null |
| BackgroundPresenter | HideImmediate() | currentBackgroundId → null |
| NoisePresenter | ClearAll() | activeNoises → 空、isAccelerated → false |
| TextBoxPresenter | Hide() | テキストクリア、GameObject非アクティブ（currentModeは維持） |
| CentralObjectPresenter | UpdateSprite(null) | スプライトリセット（GameObject自体はWalkingSystem管轄） |
| Reactions | ClearReactions() | currentReactionCallback → null |

### ステップ間の差分判定

各ステップ実行前に「前ステップと変化があるか」を判定し、変化がある場合のみトランジションを再生する。

| 判定 | 情報源 | 判定基準 |
|------|--------|---------|
| 立ち絵更新 | DialogueRunner.previousStep | CharacterId + Expression の一致 |
| 背景更新 | DialogueRunner.previousStep | HasBackground + BackgroundId の一致 |
| モード切替 | DialogueRunner.previousStep | DisplayMode の一致 |

`previousStep` はダイアログ開始時に `null` にリセットされるため、最初のステップでは必ず更新が走る。

**注意**: Presenter側にも「同キャラ同表情ならスキップ」の判定がある（PortraitPresenter.UpdatePortrait）。
HideAllAsync() で Presenter 状態がクリアされていれば、この判定が誤ってスキップすることはない。
つまり HideAllAsync() の漏れは二重にトランジションスキップを引き起こすので、特に注意すること。

---

## 状態復元（戻る機能）

### 復元契約: 部分復元 + ステップ再実行

DialogueStateSnapshotは視覚状態のみを保存する。

| 保存する | 保存しない（再実行で補完） |
|---------|------------------------|
| 立ち絵（LeftPortrait, RightPortrait） | テキスト内容 |
| 背景（HasBackground, BackgroundId） | 雑音（NoiseEntry） |
| DisplayMode | リアクション状態 |
| CentralObject（Sprite, CharacterId, Expression） | |

### 復元フロー

```
戻るリクエスト検出
├── snapshots[currentIndex - 1] を取得
├── ui.RestoreState(snapshot)
│   ├── TextBoxPresenter.SetModeImmediate()    ← トランジションなし
│   ├── PortraitPresenter.RestoreImmediate()   ← トランジションなし
│   ├── BackgroundPresenter.ShowImmediate()     ← トランジションなし
│   └── CentralObjectPresenter.UpdateSprite()
├── previousStep = steps[currentIndex - 1]
└── continue（while ループ先頭へ → 同じステップを再実行）
    └── ExecuteStep() で テキスト・雑音が自然に再発火
```

---

## Presenter一覧と状態管理

| Presenter | 状態フィールド | Initialize() | ClearAll() | 備考 |
|-----------|--------------|-------------|-----------|------|
| PortraitPresenter | currentLeftState, currentRightState, originalPos | あり | あり | |
| BackgroundPresenter | currentBackgroundId, originalPosition | あり | HideImmediate() | ClearAll()メソッドなし、HideImmediateで代用 |
| TextBoxPresenter | currentMode | あり(mode引数) | Clear() + Hide() | DisplayModeの唯一の情報源 |
| NoisePresenter | activeNoises, isAccelerated | あり | あり | OnDisableでもクリア |
| CentralObjectPresenter | viewObject, currentMode, image等 | なし(setter式) | ClearImmediate() | WalkingSystem管轄。ノベルパートからはスプライトのみ操作 |

---

## 責務分離アーキテクチャ

### インターフェース階層

```
IEventUI（基底：ShowMessage, ShowChoices）
│
├── INovelZoomUI（ズーム制御のみ）
│   ├── ZoomToCentralAsync()
│   ├── ExitZoomAsync()
│   └── RestoreZoomImmediate()
│
├── ICentralObjectUI（中央オブジェクトのスプライト管理）
│   ├── UpdateCentralObjectSprite()
│   ├── GetCurrentCentralObjectSprite()
│   ├── GetCurrentCentralObjectCharacterId()
│   ├── GetCurrentCentralObjectExpression()
│   ├── SetTemporaryCentralExpression()
│   └── ClearTemporaryCentralExpression()
│
├── INovelReactionUI（リアクション制御）
│   ├── SetReactionText()
│   └── ClearReactions()
│
└── INovelEventUI : IEventUI, INovelZoomUI, ICentralObjectUI, INovelReactionUI
    ├── Portrait: ShowPortrait, HidePortrait
    ├── Background: ShowBackground, HideBackground
    ├── Text/Noise: ShowText, SwitchTextBox, PlayNoise, AccelerateNoises
    ├── Navigation: ShowBacklog, HideBacklog, ConsumeBackRequest, etc.
    └── State: HideAllAsync, SetTabState, SetProtagonistSpiritualProperty
```

### 実装構造

```
NovelPartEventUI（MonoBehaviour, INovelEventUI）
├── NovelZoomManager（INovelZoomUI実装）
│   └── NovelZoomController（ズームアニメーション）
│
├── CentralObjectManager（ICentralObjectUI実装）
│   └── CentralObjectPresenter参照（スプライト操作）
│
├── NovelReactionHandler（INovelReactionUI実装）
│   ├── currentCallback（リアクションコールバック）
│   └── TextBoxPresenter参照（リッチテキスト設定）
│
└── 直接保持
    ├── PortraitPresenter
    ├── BackgroundPresenter
    ├── NoisePresenter
    ├── TextBoxPresenter
    ├── NovelInputHub
    └── 各入力UI（FieldDialogueUI, EventDialogueUI, NovelChoicePresenter）
```

### ファイル配置

| ファイル | 役割 |
|---------|------|
| `Walk/EventKernel/INovelEventUI.cs` | INovelZoomUI, ICentralObjectUI, INovelReactionUI, INovelEventUI の4インターフェース定義 |
| `Walk/EventKernel/NovelPartEventUI.cs` | INovelEventUI実装。ズーム/中央オブジェクト/リアクションは各マネージャーに委譲 |
| `Walk/Zoom/NovelZoomManager.cs` | INovelZoomUI実装。ズームアニメーション制御のみ |
| `Walk/Zoom/CentralObjectManager.cs` | ICentralObjectUI実装。スプライト管理と一時表情変更 |
| `Walk/Presentation/NovelReactionHandler.cs` | INovelReactionUI実装。コールバック管理とTextBoxPresenter連携 |

### 消費者と依存インターフェース

| 消費者 | 使用インターフェース | 備考 |
|--------|-------------------|------|
| NovelPartDialogueRunner | INovelEventUI | ICentralObjectUI部分（スプライト変更・スナップショット）を使用 |
| NovelDialogueStep | INovelEventUI（INovelZoomUI部分） | ZoomToCentralAsync/ExitZoomAsyncのみ使用 |
| 各Effect（ShowPortrait等） | INovelEventUI | プレゼンテーション系メソッドを使用 |
| WalkingSystemManager | INovelEventUI | SetCentralObjectPresenter注入のみ |

---

## イベント会話のナビゲーション

### 概要

イベント会話（`TabState.EventDialogue`）には3つのナビゲーション機能がある。
これらは完全に独立した機能であり、混同しないこと。

| 機能 | ボタン | 何が起きるか | 状態変化 |
|------|--------|-------------|---------|
| **進む** | SystemRightButton | 次のステップへ進む | あり（通常進行） |
| **戻る（バックトラック）** | SystemLeftButton | 1ステップ巻き戻す | あり（スナップショット復元→再実行） |
| **バックログ** | BackLogButton | ログ一覧パネルを開く | なし（閲覧のみ、閉じたら同じステップに戻る） |
| **閉じる** | CloseButton | 会話を終了する | あり（終了フェーズへ進む） |

### USERUI側の構造

```
EventDialogueObject (EventDialogueUI)
├── SystemLeftButton   ← prevButton（戻る）
├── SystemRightButton  ← nextButton（進む）
├── BackLogButton      ← backlogButton（バックログ開く）
└── CloseButton        ← closeButton（会話を閉じる）
```

### 入力経路

3つのボタンはすべて `NovelInputHub` を経由してRunnerに通知される。

```
SystemRightButton.onClick → inputHub.NotifyNext()
  → Runner: WaitForNextOrBackAsync() 解決(true) → 次ステップへ

SystemLeftButton.onClick → inputHub.NotifyBack()
  → Runner: WaitForNextOrBackAsync() 解決(false) → backRequested = true
  → ConsumeBackRequest() → スナップショット復元 → 同ステップ再実行

BackLogButton.onClick → inputHub.NotifyBacklog()
  → Runner: ConsumeBacklogRequest() → ui.ShowBacklog(backlog)
  → バックログパネル表示 → 閉じるまで待機 → 同ステップ再表示

CloseButton.onClick → inputHub.NotifyNext()
  → 最後のステップでのみ表示される。機能的にはNextと同じだがUIが異なる
  → Runner: ループ脱出 → 終了フェーズへ
```

### ボタンの動的表示制御

```csharp
// NovelPartDialogueRunner 内、各ステップ実行前
ui.SetBackButtonEnabled(allowBacktrack && currentIndex > 0);

var isLastStep = allowBacktrack && currentIndex == steps.Length - 1;
ui.SetNextButtonEnabled(!isLastStep);
ui.SetCloseButtonVisible(isLastStep);
```

| 条件 | SystemLeftButton | SystemRightButton | CloseButton |
|------|-----------------|-------------------|-------------|
| `allowBacktrack = false` | **非表示** | 有効 | 非表示 |
| 最初のステップ (`currentIndex == 0`) | **非表示** | 有効 | 非表示 |
| 途中のステップ (`0 < currentIndex < last`) | **表示** | 有効 | 非表示 |
| 最後のステップ (`currentIndex == steps.Length - 1`) | **表示** | **無効（disable）** | **表示** |

最後のステップでは右ボタン（進む）を無効化し、代わりに閉じるボタンを表示する。
これにより、ユーザーが最後のセリフで誤って右ボタンを押して会話が終了してしまうことを防ぐ。
戻るボタンは引き続き有効なので、過去のセリフを読み返してから閉じるボタンで終了できる。

### 配線マップ

| コンポーネント | フィールド | 配線先 | 用途 |
|--|--|--|--|
| **NovelPartEventUI** | `backlogPageView` | BacklogPanel (FrontFixedContainer/NovelContent内) | バックログUI本体 |
| | `backButton` | SystemLeftButton | 戻るボタンの表示/非表示制御 |
| | `eventDialogueUI` | EventDialogueObject | 入力UIへのハブ設定 |
| **EventDialogueUI** | `prevButton` | SystemLeftButton | 戻るクリック処理 |
| | `nextButton` | SystemRightButton | 進むクリック処理 |
| | `backlogButton` | BackLogButton | バックログ開くクリック処理 |
| | `closeButton` | CloseButton | 会話を閉じるクリック処理 |

---

## 中央オブジェクトのズーム

### 概要

中央オブジェクト（フィールド上のNPC等）に近づいて会話を開始した際、そのオブジェクトを画面中央にズームインする演出。
ズームの制御単位は **NovelDialogueStep（＝会話1本）** であり、Step単位でズームする/しないを決められる。

### ズーム設定の決定フロー

ズーム設定は2つの設定元があり、Step側の `overrideZoom` で切り替える。

| overrideZoom | ズームするか | フォーカス領域 |
|:---:|---|---|
| `false`（デフォルト） | DialogueSO.ZoomOnApproach | DialogueSO.FocusArea |
| `true` | NovelDialogueStep.zoomOnApproach | NovelDialogueStep.focusArea |

```csharp
// NovelDialogueStep.ExecuteAsync() 冒頭
var shouldZoom = overrideZoom ? zoomOnApproach : dialogueData.ZoomOnApproach;
var focus      = overrideZoom ? focusArea      : dialogueData.FocusArea;
var canZoom    = shouldZoom && context.NovelUI != null && context.CentralObjectRT != null;
```

**注意**: `shouldZoom = true` でも `CentralObjectRT` が null（中央オブジェクト文脈でないイベント起動等）の場合、ズームはスキップされ警告ログが出る。

### ズームのタイミング

```
NovelDialogueStep.ExecuteAsync()
│
├── ① ズームイン（会話開始前）
│   └── context.NovelUI.ZoomToCentralAsync(centralObjectRT, focusArea)
│
├── try: ダイアログ実行（RunDialogueAsync）
│   └── ステップ群の順次実行…
│
└── finally: ② ズームアウト（会話終了後 — 正常/中断/例外いずれでも）
    └── context.NovelUI.ExitZoomAsync()
```

- ズームインは **会話全体の開始前に1回**
- ズームアウトは **会話全体の終了後に1回**（finally保証）
- 個々のステップ（セリフ1つ1つ）ではなく、**Step（会話1本）単位**

### 要するに

- **ズームするかどうか**（ON/OFF）→ Step単位で決められる
- **ズームアウトのタイミング** → 決められない。**そのStepが終わったら自動で戻る**

「この会話はズームで見せる」とONにしたら、始まりも終わりも自動。
途中で手動ズームアウトしたり、ズームしたまま次のStepに引き継いだりする制御はない。

```
イベント全体
├── Step1: 村人Aとの会話（ズームON）
│   ├── セリフ1  ← ズーム中
│   ├── セリフ2  ← ズーム中
│   └── セリフ3  ← ズーム中
│   └── 会話おわり → 自動ズームアウト
│
├── Step2: 村人Bとの会話（ズームOFF）
│   ├── セリフ1  ← ズームしてない
│   └── セリフ2  ← ズームしてない
│
└── Step3: また別の会話（ズームON）
    └── ...      ← また自動ズームイン
```

### 二重起動防止

`NovelZoomController._isZooming` フラグにより、ズーム中に再度 `EnterZoom` が呼ばれても無視される。

### フェイルセーフ

| 状況 | 挙動 |
|------|------|
| 正常終了 | `ExitZoom()` でアニメーション付きズームアウト |
| キャンセル（OperationCanceledException） | `RestoreImmediate()` で即座に原状復帰 |
| finally保証 | `canZoom = true` なら必ず `ExitZoomAsync()` が呼ばれる |

### ファイル配置

| ファイル | 役割 |
|---------|------|
| `Walk/EventKernel/Steps/NovelDialogueStep.cs` | ズームのタイミング制御（ExecuteAsync前後） |
| `Walk/Zoom/NovelZoomManager.cs` | INovelZoomUI実装、ZoomControllerへの委譲 |
| `Walk/Zoom/NovelZoomController.cs` | ズームアニメーション実行（EnterZoom/ExitZoom/RestoreImmediate） |
| `Walk/Zoom/NovelZoomConfig.cs` | 設定値（ZoomDuration=0.4秒, ZoomEase=OutQuad, FitBlend=0.5, Margin=0.9） |

---

## バックログ

### 概要

バックログは会話の過去セリフを閲覧するためのページ送りUI。
EyeArea全面を覆うオーバーレイとして表示される。
イベント会話（`allowBacktrack = true` または `showBacklog = true`）で有効。

### 仕様

| 項目 | 仕様 |
|------|------|
| 表示形式 | ページ送り（スクロールなし） |
| 表示領域 | EyeArea全面（FrontFixedContainer/NovelContent内） |
| 開く操作 | EventDialogueUI上の BackLogButton |
| 閉じる操作 | パネル上の閉じるボタン（X） |
| 1ページのエントリ数 | BacklogPageView インスペクタで設定（デフォルト8） |
| 最大ページ数 | BacklogPageView インスペクタで設定（デフォルト10） |
| 戻れる範囲 | maxBacktrackPages × linesPerPage ステップまで |
| テキスト折り返し | TMPの自然なワードラップ |

### データ層

```
DialogueBacklog（既存）
├── entries: List<BacklogEntry>（1ステップ = 1エントリ）
├── maxEntries = linesPerPage × maxBacktrackPages（Runner初期化時に計算）
├── Add(stepIndex, step)        ← 各ステップ完了後に記録
├── TruncateTo(stepIndex)       ← 戻る操作時に不要エントリ削除
└── GetRecent(count)            ← 最新N件取得

BacklogEntry
├── StepIndex, Speaker, Text
├── LeftCharacterId, RightCharacterId
├── BackgroundId, DisplayMode
```

### UI層

```
FrontFixedContainer / NovelContent
└── BacklogPanel (BacklogPageView + CanvasGroup + Image半透明黒)
    ├── ContentText (TMP_Text: 全エントリを改行区切りで結合表示)
    ├── Navigation (HorizontalLayoutGroup)
    │   ├── PrevPageButton (<< 古いページへ)
    │   ├── PageIndicator ("3 / 10")
    │   └── NextPageButton (>> 新しいページへ)
    └── CloseButton (X)
```

### ページ計算

- page 0 = 最新ページ（初期表示）
- << = 古いページへ（page++）、>> = 新しいページへ（page--）
- 総ページ数 = min(ceil(totalEntries / linesPerPage), maxBacktrackPages)
- page N のエントリ範囲: `entries[count - (N+1)*linesPerPage .. count - N*linesPerPage - 1]`

### 表示フロー

```
BackLogButton クリック
  → inputHub.NotifyBacklog()
    → backlogRequested = true
    → nextOrBackTcs?.TrySetCanceled()  ← 入力待ちを中断
  → WaitForInput() が OperationCanceledException で終了
  → NovelPartDialogueRunner: ConsumeBacklogRequest() = true
  → await ui.ShowBacklog(backlog)
    → UIBlocker.Acquire(AllContents)  ← USERUI操作ブロック開始
    → BacklogPageView.ShowAsync(backlog)
      → ページ計算・テキスト描画
      → panel.SetActive(true)
      → UniTaskCompletionSource で閉じるまで待機
  → 閉じるボタン or ForceClose()
    → closeTcs.TrySetResult()
    → panel.SetActive(false)
    → UIBlocker解放                   ← USERUI操作ブロック終了
  → continue（同じステップを再表示）
```

### ファイル配置

| ファイル | 役割 |
|---------|------|
| `Walk/Presentation/BacklogPageView.cs` | バックログUI本体。ページ計算・表示・ナビゲーション・閉じる制御 |
| `Walk/Dialogue/DialogueBacklog.cs` | バックログデータ管理（既存） |
| `Walk/Dialogue/DialogueBacklog.cs > BacklogEntry` | 1ステップの履歴データ（既存） |
| `Novel/NovelInputHub.cs` | NotifyBacklog() / ConsumeBacklogRequest()（バックログ通知） |
| `Novel/EventDialogueUI.cs` | BackLogButton のクリック → inputHub.NotifyBacklog() |

### バックログと戻る機能の関係

バックログの保持件数と戻れる範囲は同じ値で制御される。

```csharp
// NovelPartDialogueRunner 初期化時
var maxEntries = ui.BacklogLinesPerPage * ui.BacklogMaxBacktrackPages;
backlog = new DialogueBacklog(maxEntries);

// 戻る範囲のガード
var maxBackSteps = ui.BacklogLinesPerPage * ui.BacklogMaxBacktrackPages;
var earliestAllowed = Math.Max(0, currentIndex - maxBackSteps);
```

例: linesPerPage=8, maxBacktrackPages=10 → 80ステップ分まで遡れる/閲覧可能。

---

## 背景システム

### 概要

ノベルパートで表示される背景画像の制御システム。
`BackgroundPresenter`が背景の表示/非表示/トランジションを担当。

### 関連ファイル

| ファイル | 役割 |
|----------|------|
| `BackgroundPresenter.cs` | 背景表示制御 |
| `BackgroundDatabase.cs` | 背景画像データベース |
| `NovelPartEventUI.cs` | UI統括（BackgroundPresenterを保持） |
| `NovelPartDialogueRunner.cs` | 会話実行（背景変更タイミング判定） |

### 背景オン/オフ動作

| 操作 | メソッドチェーン | アニメーション |
|------|-----------------|----------------|
| 背景表示 | `ShowBackground()` → `backgroundPresenter.Show()` | フェードイン（0.3秒） |
| 背景非表示 | `HideBackground()` → `backgroundPresenter.Hide()` | フェードアウト（0.3秒） |
| 戻る機能での復元 | `ShowImmediate()` / `HideImmediate()` | なし（即時） |

### 背景変更タイミング

`NovelPartDialogueRunner.ShouldUpdateBackground()`で判定：

```csharp
// 前のステップと比較して変更があれば更新
return previousStep.HasBackground != current.HasBackground
    || previousStep.BackgroundId != current.BackgroundId;
```

### 実装済みアニメーション

| アニメーション | 動作 | 時間 | イージング | 備考 |
|----------------|------|------|-----------|------|
| Show（フェードイン） | alpha: 0→1 | 0.3秒 | OutQuad | デフォルト |
| SlideIn（スライドイン） | 位置: 右端(+1920px)→元の位置、alpha: 最初から1 | 0.3秒 | OutQuad | 実装済みだが通常フローでは未使用 |
| Hide（フェードアウト） | alpha: 現在値→0 | 0.3秒 | InQuad | |

### パラメータ

`BackgroundPresenter`のSerializeField：

| フィールド | 説明 | デフォルト |
|------------|------|-----------|
| fadeDuration | フェード時間 | 0.3秒 |
| slideDistance | スライド距離 | 1920px |

### DialogueStepでの指定

```
DialogueStep
├── hasBackground: bool      ← 背景を表示するか
└── backgroundId: string     ← 背景ID（BackgroundDatabaseで解決）
```

### 背景データベース

`BackgroundDatabase.asset`で管理：

```
BackgroundDatabase
└── backgrounds[]
    ├── [0]
    │   ├── backgroundId: "forest"
    │   ├── sprite: forest.png
    │   └── tint: Color.white
    └── [1]
        ├── backgroundId: "night_city"
        ├── sprite: night_city.png
        └── tint: (0.8, 0.8, 1.0, 1.0)  ← 青みがかった色調
```

---

## 立ち絵トランジション

### 概要

立ち絵が登場/退場する際のアニメーション。
`PortraitPresenter`が制御。

### トランジション一覧

| 種類 | enum値 | 説明 |
|------|--------|------|
| なし | `None` | 即時フェードイン |
| ロックマン風 | `Rockman` | 縦線降下→フェードイン |
| 上から | `SlideTop` | 上からスライドイン |
| 下から | `SlideBottom` | 下からスライドイン |

### ロックマン風トランジション

詳細は[ノベルパート設定仕様書.md](./ノベルパート設定仕様書.md)「立ち絵登場トランジション」セクション参照。

**動作フロー:**
```
1. RainBar（キャラ色の縦長バー）が上から降下（0.35秒）
2. RainBarがフェードアウト（0.1秒）
3. 立ち絵がフェードイン（0.3秒）
```

**色の決定:**
```
PortraitState.CharacterId
    → PortraitDatabase.GetThemeColor()
    → PortraitCharacterData.ThemeColor
    → RainBarの色
```

### 退場アニメーション

| メソッド | 動作 |
|----------|------|
| `Hide()` | フェードアウト |
| `Exit()` | 横にスライドアウト（左立ち絵は左へ、右立ち絵は右へ） |

### 立ち絵キャラ切り替えアニメーション

同じ側（左 or 右）で**別のキャラクターに切り替わった**場合に自動再生されるクロスフェード。
SOやDialogueStepでの指定は不要。`CharacterId`の変化を自動検出する。

#### 判定ロジック

```
UpdatePortrait(newState, position)
├── currentState == null          → 初登場（通常トランジション: Rockman等）
├── 同キャラ・同表情              → 何もしない
├── 同キャラ・表情変化            → 指定されたトランジション
└── 別キャラ（CharacterIdが異なる）→ ★クロスフェード（自動）
```

#### クロスフェード演出

```
t=0.0s:                旧キャラ alpha 1
                       ↓ フェードアウト（crossFadeOutDuration, InQuad）
t=crossFadeOutDuration: alpha 0 → スプライト差替え
                       ↓ フェードイン（crossFadeInDuration, OutQuad）
t=合計:                新キャラ alpha 1
```

- デフォルト合計0.2秒。ボタン操作のブロック時間を最小限に抑える
- 登場トランジション（Rockman等）は使用しない。キャラ切り替えは常にクロスフェード
- フェードアウト/フェードインの時間はInspectorで個別に調整可能

#### パラメータ（PortraitPresenter Inspector）

| フィールド | 説明 | デフォルト |
|------------|------|-----------|
| `crossFadeOutDuration` | 旧キャラのフェードアウト時間 | 0.1秒 |
| `crossFadeInDuration` | 新キャラのフェードイン時間 | 0.1秒 |

#### 中央オブジェクトとの違い

中央オブジェクトでは切り替えアニメーションは**不要**。理由:

- 中央オブジェクトは1つの会話中に別キャラへ切り替わることがない（設計制約）
- 変化するのは**表情のみ**（`SetTemporaryExpression`でスプライト即時差替え）か、**スプライトの消去**（`UpdateSprite(null)`）
- 表情変化は雑音連動で瞬時に切り替わるのが自然であり、フェードを挟む必要がない
