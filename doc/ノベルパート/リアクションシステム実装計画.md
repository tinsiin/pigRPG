# リアクションシステム実装計画

## 概要

ノベルパート内の特定テキストをクリック/タップすることで、歩行システムのイベントを発火させるシステム。
ダンロンのピンク文字に着想を得た、文字色ベースのインタラクション機構。

## 親ドキュメント

- [ノベルパート設計.md](./ノベルパート設計.md) - 設計本体（リアクションシステムセクション参照）
- [ノベルパート未実装機能一覧.md](./ノベルパート未実装機能一覧.md) - 未実装機能 #6
- [ノベルパート実装計画.md](./ノベルパート実装計画.md) - 全体実装計画

## 関連コード

- `Assets/Script/Walk/Battle/IBattleRunner.cs` - 戦闘起動インターフェース
- `Assets/Script/Walk/Battle/EncounterContext.cs` - 戦闘コンテキスト
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - イベント実行
- `Assets/Script/Walk/Dialogue/DialogueStep.cs` - セリフデータ

---

## 設計思想

### イベント規格の共通化

リアクションシステムで発火するイベントは、**歩行システムで扱われるイベントと同じ規格**を使用する。

```
歩行システムのイベント規格
├── EncounterSO + BattleRunner（戦闘）
├── EventDefinitionSO + EventRunner（汎用イベント）
└── （将来追加されるイベント種別）

          ↑ 同じ規格をそのまま使う

リアクションシステム
├── 戦闘 → EncounterSO + BattleRunner
└── （将来）歩行システムに追加されたイベント種別
```

**利点:**
- 歩行システムに新しいイベント種別が追加されたら、リアクションシステムにも同じ規格で乗せられる
- `ReactionType` enumに追加するだけで拡張可能
- イベント処理ロジックの重複を避けられる

### ノベルパートの終了パターン

リアクション発火時は「中断」ではなく「終了」。終了の仕方が異なるだけ。

```
ノベルパートの終了パターン
├── 通常終了: 全ステップ完了して終了
└── リアクション終了: リアクションクリックで終了（途中で終わる）

どちらも「終了」であり、ノベルパートへの再開はしない
```

### イベント実行の責務

リアクションで発火するイベントは、**NovelPartDialogueRunner内ではなく呼び出し元で実行**する。

```
NovelPartDialogueRunner
    ↓ DialogueResult（リアクション情報を含む）を返す
呼び出し元（AreaController等）
    ↓ リアクション情報を見てイベントを実行
歩行システムのイベント処理（既存）
```

**理由:**
1. **既存フローとの一貫性**: AreaControllerが戦闘結果を処理する既存パターンを踏襲
2. **状態管理の統一**: 歩行システムの状態（カウンタ、サイドオブジェクト等）を正しく扱える
3. **拡張しやすい**: 新しいイベント種別は呼び出し元に追加するだけ

---

## 基本概念

### リアクション可能テキスト

1つのセリフ（1クリック分のテキストボックス）内に**複数のリアクション可能文字列**を配置可能。

```
「あの<color=#FF8000>オレンジ色の敵</color>を倒せば先に進めるはず」
         ↑ クリックで戦闘発火
```

### 文字色とイベントのマッピング

| 色 | 想定用途 | 発火イベント |
|----|---------|-------------|
| オレンジ (#FF8000) | 戦闘起動 | EncounterContext → BattleRunner |

※ 将来的に他の色・用途を追加可能な設計とする

### イベント規格

**リアクションシステムのイベントは歩行システムで扱えるイベントと同じ規格**

- EncounterSO + BattleRunner（戦闘用）
- EventDefinitionSO + EventRunner（汎用イベント用、将来）

---

## 戦闘起動の既存実装調査

### IBattleRunnerパターン

```csharp
// Assets/Script/Walk/Battle/IBattleRunner.cs
public interface IBattleRunner
{
    UniTask<BattleResult> RunBattleAsync(EncounterContext context);
}
```

### EncounterContext

```csharp
// Assets/Script/Walk/Battle/EncounterContext.cs
public sealed class EncounterContext
{
    public EncounterSO Encounter { get; }
    public GameContext GameContext { get; }
    public int GlobalSteps { get; }

    public EncounterContext(EncounterSO encounter, GameContext gameContext)
    {
        Encounter = encounter;
        GameContext = gameContext;
        GlobalSteps = gameContext != null ? gameContext.Counters.GlobalSteps : 0;
    }
}
```

### AreaControllerでの戦闘起動（参考）

```csharp
// AreaController.cs:739-749
private async UniTask<BattleResult> RunEncounter(EncounterSO encounter)
{
    if (encounter == null) return BattleResult.None;
    if (context == null || context.BattleRunner == null)
    {
        Debug.LogWarning("AreaController.RunEncounter: BattleRunner is null.");
        return BattleResult.None;
    }

    return await context.BattleRunner.RunBattleAsync(
        new EncounterContext(encounter, context));
}
```

### 戦闘結果

```csharp
public readonly struct BattleResult
{
    public bool Encountered { get; }      // 戦闘が実際に発生したか
    public BattleOutcome Outcome { get; } // Victory/Defeat/Escape/Unknown
}
```

---

## データ構造設計

### ReactionSegment（新規）

```csharp
// Assets/Script/Walk/Dialogue/ReactionSegment.cs（新規）
using System;
using UnityEngine;

/// <summary>
/// リアクション可能なテキストセグメント。
/// </summary>
[Serializable]
public sealed class ReactionSegment
{
    [Header("表示")]
    [SerializeField] private string text;           // リアクション可能な文字列
    [SerializeField] private Color color;           // 表示色
    [SerializeField] private int startIndex;        // 本文中の開始位置

    [Header("発火内容")]
    [SerializeField] private ReactionType type;     // リアクションの種類
    [SerializeField] private EncounterSO encounter; // 戦闘用（type=Battle時）

    public string Text => text;
    public Color Color => color;
    public int StartIndex => startIndex;
    public ReactionType Type => type;
    public EncounterSO Encounter => encounter;

    /// <summary>
    /// 本文中の終了位置（開始位置 + テキスト長）。
    /// </summary>
    public int EndIndex => startIndex + (text?.Length ?? 0);
}

/// <summary>
/// リアクションの種類。
/// </summary>
public enum ReactionType
{
    Battle,     // 戦闘起動
    // 将来拡張用
    // Event,   // EventDefinitionSO発火
    // Custom,  // カスタム処理
}
```

### DialogueStepへの追加

```csharp
// DialogueStep.cs に追加
[Header("リアクション")]
[SerializeField] private ReactionSegment[] reactions;

public ReactionSegment[] Reactions => reactions;
public bool HasReactions => reactions != null && reactions.Length > 0;
```

---

## UI実装設計

### 文字タップ方式（テキスト内クリック検出）

リアクション可能なテキストは、**テキストボックス内の色付き文字を直接タップ**して検出する。

```
【採用方式】
テキストボックス内の色付き文字をクリック検出
→ TMP_TextUtilities.FindIntersectingLink で位置判定
→ <link>タグでリアクション領域をマーク
→ クリック位置からリアクションセグメントを特定

【ボタン方式（不採用）】
リアクションテキストをUnityのButtonとして動的生成
→ 画面がボタンで煩雑になる
→ テキストとボタンの同期が複雑
```

**採用理由:**
- ダンロンのピンク文字と同じ直感的な操作感
- テキストボックス内で完結（USERUI側にボタン配置不要）
- 既存のReactionTextHandler実装を活用可能

### リアクションテキストの表示条件

**TabStateがFieldDialogue/EventDialogueで、かつ選択肢表示中でない場合**にリアクション可能。

```
【表示条件】
- TabState = FieldDialogue or EventDialogue（NovelChoiceでは無効）
- DialogueStepにreactionsがある
- 選択肢表示中ではない

【動作フロー】
1. DialogueStepにreactionsがある
2. テキスト表示時に<link>タグ付きリッチテキストを生成
3. ReactionTextHandlerがタップ位置を監視
4. リアクション文字タップ → イベント発火
5. 次のステップに進む or リアクション発火 でリセット

【重要】
- リアクションはスルー可能（必須ではない）
- 選択肢（NovelChoice state）表示中はリアクション無効
- ユーザーは選択肢に集中できる
```

### ReactionTextHandler（既存実装を活用）

テキストボックス内のリアクション文字タップを検出するコンポーネント。

```csharp
// Assets/Script/Walk/Presentation/ReactionTextHandler.cs（既存）
// TMP_Textコンポーネントに対してタップ検出を行う

/// <summary>
/// リアクションテキストのタップ検出。
/// </summary>
public sealed class ReactionTextHandler : MonoBehaviour
{
    private TMP_Text textComponent;
    private ReactionSegment[] currentReactions;
    private Action<ReactionSegment> onReactionClicked;

    public void SetTextComponent(TMP_Text text) { ... }
    public void Setup(ReactionSegment[] reactions, Action<ReactionSegment> callback) { ... }
    public void Clear() { ... }

    // Update()でタップ位置を監視
    // TMP_TextUtilities.FindIntersectingLinkでリンク検出
}
```

### リッチテキスト生成（ReactionTextBuilder）

```csharp
// Assets/Script/Walk/Dialogue/ReactionTextBuilder.cs（既存）

/// <summary>
/// リアクションセグメントからTMPリッチテキストを生成。
/// </summary>
public static class ReactionTextBuilder
{
    /// <summary>
    /// 元テキストとリアクションから<link>タグ付きリッチテキストを生成。
    /// </summary>
    public static string Build(string originalText, ReactionSegment[] reactions)
    {
        // 例: "あのオレンジ色の敵を倒せ"
        // → "あの<link=0><color=#FF8000>オレンジ色の敵</color></link>を倒せ"
    }
}
```

### 配置場所

**EyeArea側のテキストボックス内で完結:**

```
NovelContent/TextBoxArea
├── DinoidTextBox
│   └── DinoidText ← TMP_Text + ReactionTextHandler
└── PortraitTextBox
    └── PortraitText ← TMP_Text + ReactionTextHandler
```

**TabStateとリアクションの関係:**

| TabState | リアクションタップ | 理由 |
|----------|------------------|------|
| FieldDialogue | 有効 | スルー可能 |
| EventDialogue | 有効 | スルー可能 |
| NovelChoice | 無効 | 選択肢に集中させるため |

---

## DialogueResultの拡張

リアクション終了を表現するためにDialogueResultを拡張する。

```csharp
// DialogueResult.cs 修正
public struct DialogueResult
{
    public bool Completed { get; set; }  // 全ステップ完了したか
    public int SelectedChoiceIndex { get; set; }
    public string ChangedSpiritProperty { get; set; }

    // リアクション終了用（追加）
    public ReactionSegment TriggeredReaction { get; set; }

    // 判定ヘルパー
    public bool IsReactionEnded => TriggeredReaction != null;
    public bool IsNormalEnded => Completed && TriggeredReaction == null;

    public static DialogueResult FailedResult => new() { Completed = false };
    public static DialogueResult ReactionEndedResult(ReactionSegment reaction) => new()
    {
        Completed = false,
        TriggeredReaction = reaction
    };
}
```

---

## NovelPartDialogueRunnerへの統合

### リアクション終了の処理

```csharp
// NovelPartDialogueRunner.cs 修正

public async UniTask<DialogueResult> RunDialogueAsync(DialogueContext context)
{
    // ... 既存の初期化処理 ...

    var steps = context.GetSteps();
    var currentIndex = 0;

    while (currentIndex < steps.Length)
    {
        var step = steps[currentIndex];
        if (step == null)
        {
            currentIndex++;
            continue;
        }

        // リアクションボタンの表示（テキスト表示と同時）
        if (step.HasReactions)
        {
            ui.ShowReactionButtons(step.Reactions, OnReactionClicked);
        }

        reactionTriggered = null;
        var stepResult = await ExecuteStep(step, context, currentIndex);

        // リアクションボタンがクリックされた場合 → リアクション終了
        if (reactionTriggered != null)
        {
            // ノベルパートを閉じる（終了）
            ui.ClearReactionButtons();
            await ui.HideAll();

            // リアクション情報を含めて終了を返す
            return DialogueResult.ReactionEndedResult(reactionTriggered);
        }

        // 次のステップに進む前にボタンをクリア
        ui.ClearReactionButtons();

        // ... 既存の戻る/バックログ処理 ...

        previousStep = step;
        currentIndex++;
    }

    // 通常終了
    ui.SetBackButtonEnabled(false);
    return new DialogueResult { Completed = true };
}

private ReactionSegment reactionTriggered;

private void OnReactionClicked(ReactionSegment segment)
{
    reactionTriggered = segment;
}
```

### 呼び出し元（AreaController等）での処理

```csharp
// 強制イベント等からの呼び出し例
var dialogueResult = await context.DialogueRunner.RunDialogueAsync(dialogueContext);

// リアクション終了をチェック
if (dialogueResult.IsReactionEnded)
{
    var reaction = dialogueResult.TriggeredReaction;

    switch (reaction.Type)
    {
        case ReactionType.Battle:
            // 戦闘起動（既存のRunEncounterと同じパターン）
            var battleResult = await RunEncounter(reaction.Encounter);
            await HandleEncounterOutcome(reaction.Encounter, battleResult.Outcome, ...);
            break;

        // 将来の拡張
        // case ReactionType.Event:
        //     await eventHost.RunEvent(reaction.Event);
        //     break;
    }
}
else if (dialogueResult.IsNormalEnded)
{
    // 通常終了の処理
}
```

---

## INovelEventUIへの追加

```csharp
// INovelEventUI.cs に追加

/// <summary>
/// リアクションボタンを表示する。
/// EyeAreaのテキストボックス表示中のみ有効。
/// </summary>
/// <param name="reactions">リアクションセグメント配列</param>
/// <param name="onClicked">ボタンクリック時コールバック</param>
void ShowReactionButtons(ReactionSegment[] reactions, System.Action<ReactionSegment> onClicked);

/// <summary>
/// リアクションボタンをクリアする。
/// </summary>
void ClearReactionButtons();

/// <summary>
/// 全UI要素を非表示にする（リアクション終了時）。
/// </summary>
UniTask HideAll();
```

### NovelPartEventUI既存メソッド

`HideAll()`は既に実装済み（`NovelPartEventUI.cs:301-307`）:
```csharp
public void HideAll()
{
    portraitPresenter?.ClearAll();
    backgroundPresenter?.HideImmediate();
    noisePresenter?.ClearAll();
    textBoxPresenter?.Hide();
    reactionButtonPresenter?.ClearButtons();  // 追加
}
```

---

## 実装フェーズ

### Phase R1: データ構造 ✅ 完了

| タスク | 状態 |
|--------|------|
| ReactionSegment定義 | ✅ |
| ReactionType enum定義 | ✅ |
| DialogueStep.reactions追加 | ✅ |
| DialogueResult拡張（TriggeredReaction追加） | ✅ |

### Phase R2: テキストタップUI

| タスク | 状態 |
|--------|------|
| ReactionTextHandler実装 | ✅ 既存 |
| ReactionTextBuilder実装 | ✅ 既存 |
| TMP_Text リンクタグ対応 | ⬜ |

### Phase R3: Runner統合 ✅ 完了

| タスク | 状態 |
|--------|------|
| INovelEventUI.SetReactionText/ClearReactions追加 | ✅ |
| NovelPartEventUI リアクション対応 | ✅ |
| NovelPartDialogueRunner リアクション終了処理 | ✅ |
| リアクション終了時のTabStateリセット | ✅ |
| リアクションクリック時の入力待ちキャンセル | ✅ |

### Phase R4: 呼び出し元統合 ✅ 完了

| タスク | 状態 |
|--------|------|
| AreaController リアクション終了ハンドリング | ✅ |
| 戦闘起動（既存RunEncounterパターン流用） | ✅ |
| 戦闘結果処理（既存HandleEncounterOutcome流用） | ✅ |

### Phase R5: シーン配置・結合テスト

| タスク | 状態 |
|--------|------|
| ReactionTextHandlerシーン配置 | ⬜ |
| オレンジ文字での戦闘起動テスト | ⬜ |
| 複数リアクション同時表示テスト | ⬜ |
| ノベルパート終了 → 戦闘 → 歩行継続テスト | ⬜ |

---

## ファイル構成

```
Assets/Script/
├── Walk/
│   ├── Dialogue/
│   │   ├── DialogueStep.cs           （修正：reactions追加）✅
│   │   ├── DialogueResult.cs         （修正：TriggeredReaction追加）✅
│   │   ├── ReactionSegment.cs        （新規）✅
│   │   ├── ReactionTextBuilder.cs    （新規）✅
│   │   └── NovelPartDialogueRunner.cs（修正：リアクション終了処理）✅
│   │
│   ├── Presentation/
│   │   └── ReactionTextHandler.cs    （新規：テキストタップ検出）✅
│   │
│   ├── EventKernel/
│   │   ├── INovelEventUI.cs          （修正：SetReactionText/ClearReactions追加）✅
│   │   └── NovelPartEventUI.cs       （修正：リアクション対応）✅
│   │
│   └── AreaController.cs             （修正：リアクション終了ハンドリング）✅
```

---

## テスト計画

### 正常系

- [ ] オレンジ色テキストが正しく表示される
- [ ] クリックでノベルパートが終了する
- [ ] ノベルパート終了後に戦闘が起動する
- [ ] 戦闘終了後に歩行システムに正しく戻る
- [ ] 1セリフに複数リアクションがある場合、各々が独立して動作

### 異常系

- [ ] Encounter未設定のリアクションをクリック → 警告ログ、通常進行
- [ ] BattleRunner未設定時 → 警告ログ、通常終了
- [ ] リアクション外のテキストクリック → 通常進行

### エッジケース

- [ ] リアクションテキストが重複する位置にある場合
- [ ] リアクションテキストが改行をまたぐ場合
- [ ] 全文がリアクションテキストの場合
- [ ] 最初のステップでリアクション終了した場合

---

## 将来拡張

### 他のリアクションタイプ

```csharp
public enum ReactionType
{
    Battle,     // 戦闘起動（実装済み）
    Event,      // EventDefinitionSO発火
    Inference,  // 推理パート
    Custom      // カスタム処理（delegate）
}
```

### 色マッピングの外部化

将来的にはSOでマッピングを定義できるようにする。

```csharp
[CreateAssetMenu(menuName = "Walk/Reaction Color Mapping")]
public class ReactionColorMappingSO : ScriptableObject
{
    [Serializable]
    public class ColorMapping
    {
        public Color color;
        public ReactionType type;
    }

    [SerializeField] private ColorMapping[] mappings;
}
```

---

## 備考

- リアクションはあくまでオプション機能（reactions=nullでも通常動作）
- **リアクション発火時はノベルパートを「終了」する（中断ではない）**
- ノベルパートへの再開はしない。終了後は呼び出し元がイベントを実行し、歩行に戻る
- UI配置の詳細は [ノベルパート_USERUIとEyeArea連携.md](./ノベルパート_USERUIとEyeArea連携.md) を参照

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-24 | 初版（TextMeshProリンク方式） |
| 2026-01-24 | UI方式変更: テキストクリックからボタン生成方式に変更 |
| 2026-01-24 | TabState.NovelChoice追加、リアクションボタンの表示条件明確化（選択肢中は非表示） |
| 2026-01-25 | **UI方式を文字タップ方式に戻す**: ボタン方式不採用、TextMeshProリンク方式採用 |
| 2026-01-25 | 外部レビュー対応: リアクション終了時TabStateリセット、入力待ちキャンセル処理追加 |
