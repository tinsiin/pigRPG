# リアクションシステム実装計画

## 概要

ノベルパート内の特定テキストをクリック/タップすることで、歩行システムのイベントを発火させるシステム。
ダンロンのピンク文字に着想を得た、文字色ベースのインタラクション機構。

## 親ドキュメント

- [ノベルパート設計.md](./ノベルパート設計.md) - 設計本体（リアクションシステムセクション参照）
- [ノベルパート未実装機能一覧.md](./ノベルパート未実装機能一覧.md) - 未実装機能 #6
- [ノベルパート実装計画.md](./ノベルパート実装計画.md) - 全体実装計画

## 関連コード

- `Assets/Script/Walk/Battle/IBattleRunner.cs` - 戦闘起動インターフェース
- `Assets/Script/Walk/Battle/EncounterContext.cs` - 戦闘コンテキスト
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - イベント実行
- `Assets/Script/Walk/Dialogue/DialogueStep.cs` - セリフデータ

---

## 設計思想

### イベント規格の共通化

リアクションシステムで発火するイベントは、**歩行システムで扱われるイベントと同じ規格**を使用する。

```
歩行システムのイベント規格
├── EncounterSO + BattleRunner（戦闘）
├── EventDefinitionSO + EventRunner（汎用イベント）
└── （将来追加されるイベント種別）

          ↑ 同じ規格をそのまま使う

リアクションシステム
├── 戦闘 → EncounterSO + BattleRunner
└── （将来）歩行システムに追加されたイベント種別
```

**利点:**
- 歩行システムに新しいイベント種別が追加されたら、リアクションシステムにも同じ規格で乗せられる
- `ReactionType` enumに追加するだけで拡張可能
- イベント処理ロジックの重複を避けられる

### ノベルパートの終了パターン

リアクション発火時は「中断」ではなく「終了」。終了の仕方が異なるだけ。

```
ノベルパートの終了パターン
├── 通常終了: 全ステップ完了して終了
└── リアクション終了: リアクションクリックで終了（途中で終わる）

どちらも「終了」であり、ノベルパートへの再開はしない
```

### イベント実行の責務

リアクションで発火するイベントは、**NovelPartDialogueRunner内ではなく呼び出し元で実行**する。

```
NovelPartDialogueRunner
    ↓ DialogueResult（リアクション情報を含む）を返す
呼び出し元（AreaController等）
    ↓ リアクション情報を見てイベントを実行
歩行システムのイベント処理（既存）
```

**理由:**
1. **既存フローとの一貫性**: AreaControllerが戦闘結果を処理する既存パターンを踏襲
2. **状態管理の統一**: 歩行システムの状態（カウンタ、サイドオブジェクト等）を正しく扱える
3. **拡張しやすい**: 新しいイベント種別は呼び出し元に追加するだけ

---

## 基本概念

### リアクション可能テキスト

1つのセリフ（1クリック分のテキストボックス）内に**複数のリアクション可能文字列**を配置可能。

```
「あの<color=#FF8000>オレンジ色の敵</color>を倒せば先に進めるはず」
         ↑ クリックで戦闘発火
```

### 文字色とイベントのマッピング

| 色 | 想定用途 | 発火イベント |
|----|---------|-------------|
| オレンジ (#FF8000) | 戦闘起動 | EncounterContext → BattleRunner |

※ 将来的に他の色・用途を追加可能な設計とする

### イベント規格

**リアクションシステムのイベントは歩行システムで扱えるイベントと同じ規格**

- EncounterSO + BattleRunner（戦闘用）
- EventDefinitionSO + EventRunner（汎用イベント用、将来）

---

## 戦闘起動の既存実装調査

### IBattleRunnerパターン

```csharp
// Assets/Script/Walk/Battle/IBattleRunner.cs
public interface IBattleRunner
{
    UniTask<BattleResult> RunBattleAsync(EncounterContext context);
}
```

### EncounterContext

```csharp
// Assets/Script/Walk/Battle/EncounterContext.cs
public sealed class EncounterContext
{
    public EncounterSO Encounter { get; }
    public GameContext GameContext { get; }
    public int GlobalSteps { get; }

    public EncounterContext(EncounterSO encounter, GameContext gameContext)
    {
        Encounter = encounter;
        GameContext = gameContext;
        GlobalSteps = gameContext != null ? gameContext.Counters.GlobalSteps : 0;
    }
}
```

### AreaControllerでの戦闘起動（参考）

```csharp
// AreaController.cs:739-749
private async UniTask<BattleResult> RunEncounter(EncounterSO encounter)
{
    if (encounter == null) return BattleResult.None;
    if (context == null || context.BattleRunner == null)
    {
        Debug.LogWarning("AreaController.RunEncounter: BattleRunner is null.");
        return BattleResult.None;
    }

    return await context.BattleRunner.RunBattleAsync(
        new EncounterContext(encounter, context));
}
```

### 戦闘結果

```csharp
public readonly struct BattleResult
{
    public bool Encountered { get; }      // 戦闘が実際に発生したか
    public BattleOutcome Outcome { get; } // Victory/Defeat/Escape/Unknown
}
```

---

## データ構造設計

### ReactionSegment（新規）

```csharp
// Assets/Script/Walk/Dialogue/ReactionSegment.cs（新規）
using System;
using UnityEngine;

/// <summary>
/// リアクション可能なテキストセグメント。
/// </summary>
[Serializable]
public sealed class ReactionSegment
{
    [Header("表示")]
    [SerializeField] private string text;           // リアクション可能な文字列
    [SerializeField] private Color color;           // 表示色
    [SerializeField] private int startIndex;        // 本文中の開始位置

    [Header("発火内容")]
    [SerializeField] private ReactionType type;     // リアクションの種類
    [SerializeField] private EncounterSO encounter; // 戦闘用（type=Battle時）

    public string Text => text;
    public Color Color => color;
    public int StartIndex => startIndex;
    public ReactionType Type => type;
    public EncounterSO Encounter => encounter;

    /// <summary>
    /// 本文中の終了位置（開始位置 + テキスト長）。
    /// </summary>
    public int EndIndex => startIndex + (text?.Length ?? 0);
}

/// <summary>
/// リアクションの種類。
/// </summary>
public enum ReactionType
{
    Battle,     // 戦闘起動
    // 将来拡張用
    // Event,   // EventDefinitionSO発火
    // Custom,  // カスタム処理
}
```

### DialogueStepへの追加

```csharp
// DialogueStep.cs に追加
[Header("リアクション")]
[SerializeField] private ReactionSegment[] reactions;

public ReactionSegment[] Reactions => reactions;
public bool HasReactions => reactions != null && reactions.Length > 0;
```

---

## UI実装設計

### TextMeshProリッチテキスト変換

DialogueStepのテキストとリアクションセグメントを組み合わせて、TMPリッチテキストを生成。

```csharp
// Assets/Script/Walk/Dialogue/ReactionTextBuilder.cs（新規）
public static class ReactionTextBuilder
{
    /// <summary>
    /// 平文とリアクションセグメントからTMPリッチテキストを生成。
    /// </summary>
    public static string Build(string plainText, ReactionSegment[] reactions)
    {
        if (string.IsNullOrEmpty(plainText)) return string.Empty;
        if (reactions == null || reactions.Length == 0) return plainText;

        // セグメントを開始位置でソート
        var sorted = reactions.OrderBy(r => r.StartIndex).ToArray();
        var sb = new StringBuilder();
        var currentIndex = 0;

        foreach (var segment in sorted)
        {
            // リアクション前の通常テキスト
            if (segment.StartIndex > currentIndex)
            {
                sb.Append(plainText.Substring(currentIndex, segment.StartIndex - currentIndex));
            }

            // リアクションテキスト（色付き + リンクタグ）
            var colorHex = ColorUtility.ToHtmlStringRGB(segment.Color);
            sb.Append($"<link=\"{segment.StartIndex}\"><color=#{colorHex}>{segment.Text}</color></link>");

            currentIndex = segment.EndIndex;
        }

        // 残りの通常テキスト
        if (currentIndex < plainText.Length)
        {
            sb.Append(plainText.Substring(currentIndex));
        }

        return sb.ToString();
    }
}
```

### クリック検出

TextMeshProの`<link>`タグとTMP_TextEventHandlerを使用。

```csharp
// Assets/Script/Walk/Presentation/ReactionTextHandler.cs（新規）
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// リアクションテキストのクリック検出。
/// </summary>
public sealed class ReactionTextHandler : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] private TMP_Text textComponent;

    private ReactionSegment[] currentReactions;
    private System.Action<ReactionSegment> onReactionClicked;

    public void Setup(ReactionSegment[] reactions, System.Action<ReactionSegment> callback)
    {
        currentReactions = reactions;
        onReactionClicked = callback;
    }

    public void Clear()
    {
        currentReactions = null;
        onReactionClicked = null;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (textComponent == null || currentReactions == null) return;

        // クリック位置からリンクIDを取得
        var linkIndex = TMP_TextUtilities.FindIntersectingLink(
            textComponent, eventData.position, eventData.pressEventCamera);

        if (linkIndex < 0) return;

        var linkInfo = textComponent.textInfo.linkInfo[linkIndex];
        var linkId = linkInfo.GetLinkID();

        // linkIdはstartIndexを格納している
        if (int.TryParse(linkId, out var startIndex))
        {
            var segment = FindSegmentByStartIndex(startIndex);
            if (segment != null)
            {
                onReactionClicked?.Invoke(segment);
            }
        }
    }

    private ReactionSegment FindSegmentByStartIndex(int startIndex)
    {
        if (currentReactions == null) return null;
        foreach (var segment in currentReactions)
        {
            if (segment.StartIndex == startIndex) return segment;
        }
        return null;
    }
}
```

---

## DialogueResultの拡張

リアクション終了を表現するためにDialogueResultを拡張する。

```csharp
// DialogueResult.cs 修正
public struct DialogueResult
{
    public bool Completed { get; set; }  // 全ステップ完了したか
    public int SelectedChoiceIndex { get; set; }
    public string ChangedSpiritProperty { get; set; }

    // リアクション終了用（追加）
    public ReactionSegment TriggeredReaction { get; set; }

    // 判定ヘルパー
    public bool IsReactionEnded => TriggeredReaction != null;
    public bool IsNormalEnded => Completed && TriggeredReaction == null;

    public static DialogueResult FailedResult => new() { Completed = false };
    public static DialogueResult ReactionEndedResult(ReactionSegment reaction) => new()
    {
        Completed = false,
        TriggeredReaction = reaction
    };
}
```

---

## NovelPartDialogueRunnerへの統合

### リアクション終了の処理

```csharp
// NovelPartDialogueRunner.cs 修正

public async UniTask<DialogueResult> RunDialogueAsync(DialogueContext context)
{
    // ... 既存の初期化処理 ...

    var steps = context.GetSteps();
    var currentIndex = 0;

    while (currentIndex < steps.Length)
    {
        var step = steps[currentIndex];
        if (step == null)
        {
            currentIndex++;
            continue;
        }

        // リアクションテキストの設定
        if (step.HasReactions)
        {
            var richText = ReactionTextBuilder.Build(step.Text, step.Reactions);
            ui.SetReactionText(richText, step.Reactions, OnReactionClicked);
        }

        reactionTriggered = null;
        var stepResult = await ExecuteStep(step, context, currentIndex);

        // リアクションがクリックされた場合 → リアクション終了
        if (reactionTriggered != null)
        {
            // ノベルパートを閉じる（終了）
            ui.ClearReactions();
            await ui.HideAll();

            // リアクション情報を含めて終了を返す
            return DialogueResult.ReactionEndedResult(reactionTriggered);
        }

        // ... 既存の戻る/バックログ処理 ...

        previousStep = step;
        currentIndex++;
    }

    // 通常終了
    ui.SetBackButtonEnabled(false);
    return new DialogueResult { Completed = true };
}

private ReactionSegment reactionTriggered;

private void OnReactionClicked(ReactionSegment segment)
{
    reactionTriggered = segment;
}
```

### 呼び出し元（AreaController等）での処理

```csharp
// 強制イベント等からの呼び出し例
var dialogueResult = await context.DialogueRunner.RunDialogueAsync(dialogueContext);

// リアクション終了をチェック
if (dialogueResult.IsReactionEnded)
{
    var reaction = dialogueResult.TriggeredReaction;

    switch (reaction.Type)
    {
        case ReactionType.Battle:
            // 戦闘起動（既存のRunEncounterと同じパターン）
            var battleResult = await RunEncounter(reaction.Encounter);
            await HandleEncounterOutcome(reaction.Encounter, battleResult.Outcome, ...);
            break;

        // 将来の拡張
        // case ReactionType.Event:
        //     await eventHost.RunEvent(reaction.Event);
        //     break;
    }
}
else if (dialogueResult.IsNormalEnded)
{
    // 通常終了の処理
}
```

---

## INovelEventUIへの追加

```csharp
// INovelEventUI.cs に追加

/// <summary>
/// リアクション可能テキストを設定する。
/// </summary>
/// <param name="richText">TMPリッチテキスト（色付き + linkタグ付き）</param>
/// <param name="reactions">リアクションセグメント配列</param>
/// <param name="onClicked">クリック時コールバック</param>
void SetReactionText(string richText, ReactionSegment[] reactions, System.Action<ReactionSegment> onClicked);

/// <summary>
/// リアクション設定をクリアする。
/// </summary>
void ClearReactions();

/// <summary>
/// 全UI要素を非表示にする（リアクション終了時）。
/// </summary>
UniTask HideAll();
```

### NovelPartEventUI既存メソッド

`HideAll()`は既に実装済み（`NovelPartEventUI.cs:301-307`）:
```csharp
public void HideAll()
{
    portraitPresenter?.ClearAll();
    backgroundPresenter?.HideImmediate();
    noisePresenter?.ClearAll();
    textBoxPresenter?.Hide();
}
```

---

## 実装フェーズ

### Phase R1: データ構造

| タスク | 状態 |
|--------|------|
| ReactionSegment定義 | ✅ |
| ReactionType enum定義 | ✅ |
| DialogueStep.reactions追加 | ✅ |
| DialogueResult拡張（TriggeredReaction追加） | ✅ |

### Phase R2: テキスト変換

| タスク | 状態 |
|--------|------|
| ReactionTextBuilder実装 | ✅ |
| TMPリッチテキスト生成テスト | ⬜ |

### Phase R3: クリック検出

| タスク | 状態 |
|--------|------|
| ReactionTextHandler実装 | ✅ |
| IPointerClickHandler統合 | ✅ |
| リンクID解析 | ✅ |

### Phase R4: NovelPartDialogueRunner統合

| タスク | 状態 |
|--------|------|
| INovelEventUI.SetReactionText/ClearReactions追加 | ✅ |
| NovelPartEventUI リアクション対応 | ✅ |
| NovelPartDialogueRunner リアクション終了処理 | ✅ |

### Phase R5: 呼び出し元統合

| タスク | 状態 |
|--------|------|
| AreaController リアクション終了ハンドリング | ✅ |
| 戦闘起動（既存RunEncounterパターン流用） | ✅ |
| 戦闘結果処理（既存HandleEncounterOutcome流用） | ✅ |

### Phase R6: 結合テスト

| タスク | 状態 |
|--------|------|
| オレンジ文字での戦闘起動テスト | ⬜ |
| 複数リアクション同時表示テスト | ⬜ |
| ノベルパート終了 → 戦闘 → 歩行継続テスト | ⬜ |

---

## ファイル構成

```
Assets/Script/Walk/
├── Dialogue/
│   ├── DialogueStep.cs           （修正：reactions追加）
│   ├── DialogueResult.cs         （修正：TriggeredReaction追加）
│   ├── ReactionSegment.cs        （新規）
│   ├── ReactionTextBuilder.cs    （新規）
│   └── NovelPartDialogueRunner.cs（修正：リアクション終了処理）
│
├── Presentation/
│   └── ReactionTextHandler.cs    （新規）
│
├── EventKernel/
│   ├── INovelEventUI.cs          （修正：SetReactionText/ClearReactions追加）
│   └── NovelPartEventUI.cs       （修正：リアクション対応）
│
└── AreaController.cs             （修正：リアクション終了ハンドリング）
```

---

## テスト計画

### 正常系

- [ ] オレンジ色テキストが正しく表示される
- [ ] クリックでノベルパートが終了する
- [ ] ノベルパート終了後に戦闘が起動する
- [ ] 戦闘終了後に歩行システムに正しく戻る
- [ ] 1セリフに複数リアクションがある場合、各々が独立して動作

### 異常系

- [ ] Encounter未設定のリアクションをクリック → 警告ログ、通常進行
- [ ] BattleRunner未設定時 → 警告ログ、通常終了
- [ ] リアクション外のテキストクリック → 通常進行

### エッジケース

- [ ] リアクションテキストが重複する位置にある場合
- [ ] リアクションテキストが改行をまたぐ場合
- [ ] 全文がリアクションテキストの場合
- [ ] 最初のステップでリアクション終了した場合

---

## 将来拡張

### 他のリアクションタイプ

```csharp
public enum ReactionType
{
    Battle,     // 戦闘起動（実装済み）
    Event,      // EventDefinitionSO発火
    Inference,  // 推理パート
    Custom      // カスタム処理（delegate）
}
```

### 色マッピングの外部化

将来的にはSOでマッピングを定義できるようにする。

```csharp
[CreateAssetMenu(menuName = "Walk/Reaction Color Mapping")]
public class ReactionColorMappingSO : ScriptableObject
{
    [Serializable]
    public class ColorMapping
    {
        public Color color;
        public ReactionType type;
    }

    [SerializeField] private ColorMapping[] mappings;
}
```

---

## 備考

- TextMeshProの`<link>`タグはクリック検出に必須
- リアクションはあくまでオプション機能（reactions=nullでも通常動作）
- **リアクション発火時はノベルパートを「終了」する（中断ではない）**
- ノベルパートへの再開はしない。終了後は呼び出し元がイベントを実行し、歩行に戻る
