# リアクションシステム実装計画

## 概要

ノベルパート内の特定テキストをクリック/タップすることで、歩行システムのイベントを発火させるシステム。
ダンロンのピンク文字に着想を得た、文字色ベースのインタラクション機構。

## 親ドキュメント

- [ノベルパート設計.md](./ノベルパート設計.md) - 設計本体（リアクションシステムセクション参照）
- [ノベルパート未実装機能一覧.md](./ノベルパート未実装機能一覧.md) - 未実装機能 #6
- [ノベルパート実装計画.md](./ノベルパート実装計画.md) - 全体実装計画

## 関連コード

- `Assets/Script/Walk/Battle/IBattleRunner.cs` - 戦闘起動インターフェース
- `Assets/Script/Walk/Battle/EncounterContext.cs` - 戦闘コンテキスト
- `Assets/Script/Walk/EventKernel/EventRunner.cs` - イベント実行
- `Assets/Script/Walk/Dialogue/DialogueStep.cs` - セリフデータ

---

## 設計思想

### イベント規格の共通化

リアクションシステムで発火するイベントは、**歩行システムで扱われるイベントと同じ規格**を使用する。

```
歩行システムのイベント規格
├── EncounterSO + BattleRunner（戦闘）
├── EventDefinitionSO + EventRunner（汎用イベント）
└── （将来追加されるイベント種別）

          ↑ 同じ規格をそのまま使う

リアクションシステム
├── 戦闘 → EncounterSO + BattleRunner
└── （将来）歩行システムに追加されたイベント種別
```

**利点:**
- 歩行システムに新しいイベント種別が追加されたら、リアクションシステムにも同じ規格で乗せられる
- `ReactionType` enumに追加するだけで拡張可能
- イベント処理ロジックの重複を避けられる

### ノベルパートの終了パターン

リアクション発火時は「中断」ではなく「終了」。終了の仕方が異なるだけ。

```
ノベルパートの終了パターン
├── 通常終了: 全ステップ完了して終了
└── リアクション終了: リアクションクリックで終了（途中で終わる）

どちらも「終了」であり、ノベルパートへの再開はしない
```

### イベント実行の責務

リアクションで発火するイベントは、**NovelPartDialogueRunner内ではなく呼び出し元で実行**する。

```
NovelPartDialogueRunner
    ↓ DialogueResult（リアクション情報を含む）を返す
呼び出し元（AreaController等）
    ↓ リアクション情報を見てイベントを実行
歩行システムのイベント処理（既存）
```

**理由:**
1. **既存フローとの一貫性**: AreaControllerが戦闘結果を処理する既存パターンを踏襲
2. **状態管理の統一**: 歩行システムの状態（カウンタ、サイドオブジェクト等）を正しく扱える
3. **拡張しやすい**: 新しいイベント種別は呼び出し元に追加するだけ

---

## 基本概念

### リアクション可能テキスト

1つのセリフ（1クリック分のテキストボックス）内に**複数のリアクション可能文字列**を配置可能。

```
「あの<color=#FF8000>オレンジ色の敵</color>を倒せば先に進めるはず」
         ↑ クリックで戦闘発火
```

### 文字色とイベントのマッピング

| 色 | 想定用途 | 発火イベント |
|----|---------|-------------|
| オレンジ (#FF8000) | 戦闘起動 | EncounterContext → BattleRunner |

※ 将来的に他の色・用途を追加可能な設計とする

### イベント規格

**リアクションシステムのイベントは歩行システムで扱えるイベントと同じ規格**

- EncounterSO + BattleRunner（戦闘用）
- EventDefinitionSO + EventRunner（汎用イベント用、将来）

---

## 戦闘起動の既存実装調査

### IBattleRunnerパターン

```csharp
// Assets/Script/Walk/Battle/IBattleRunner.cs
public interface IBattleRunner
{
    UniTask<BattleResult> RunBattleAsync(EncounterContext context);
}
```

### EncounterContext

```csharp
// Assets/Script/Walk/Battle/EncounterContext.cs
public sealed class EncounterContext
{
    public EncounterSO Encounter { get; }
    public GameContext GameContext { get; }
    public int GlobalSteps { get; }

    public EncounterContext(EncounterSO encounter, GameContext gameContext)
    {
        Encounter = encounter;
        GameContext = gameContext;
        GlobalSteps = gameContext != null ? gameContext.Counters.GlobalSteps : 0;
    }
}
```

### AreaControllerでの戦闘起動（参考）

```csharp
// AreaController.cs:739-749
private async UniTask<BattleResult> RunEncounter(EncounterSO encounter)
{
    if (encounter == null) return BattleResult.None;
    if (context == null || context.BattleRunner == null)
    {
        Debug.LogWarning("AreaController.RunEncounter: BattleRunner is null.");
        return BattleResult.None;
    }

    return await context.BattleRunner.RunBattleAsync(
        new EncounterContext(encounter, context));
}
```

### 戦闘結果

```csharp
public readonly struct BattleResult
{
    public bool Encountered { get; }      // 戦闘が実際に発生したか
    public BattleOutcome Outcome { get; } // Victory/Defeat/Escape/Unknown
}
```

---

## データ構造設計

### ReactionSegment（新規）

```csharp
// Assets/Script/Walk/Dialogue/ReactionSegment.cs（新規）
using System;
using UnityEngine;

/// <summary>
/// リアクション可能なテキストセグメント。
/// </summary>
[Serializable]
public sealed class ReactionSegment
{
    [Header("表示")]
    [SerializeField] private string text;           // リアクション可能な文字列
    [SerializeField] private Color color;           // 表示色
    [SerializeField] private int startIndex;        // 本文中の開始位置

    [Header("発火内容")]
    [SerializeField] private ReactionType type;     // リアクションの種類
    [SerializeField] private EncounterSO encounter; // 戦闘用（type=Battle時）

    public string Text => text;
    public Color Color => color;
    public int StartIndex => startIndex;
    public ReactionType Type => type;
    public EncounterSO Encounter => encounter;

    /// <summary>
    /// 本文中の終了位置（開始位置 + テキスト長）。
    /// </summary>
    public int EndIndex => startIndex + (text?.Length ?? 0);
}

/// <summary>
/// リアクションの種類。
/// </summary>
public enum ReactionType
{
    Battle,     // 戦闘起動
    // 将来拡張用
    // Event,   // EventDefinitionSO発火
    // Custom,  // カスタム処理
}
```

### DialogueStepへの追加

```csharp
// DialogueStep.cs に追加
[Header("リアクション")]
[SerializeField] private ReactionSegment[] reactions;

public ReactionSegment[] Reactions => reactions;
public bool HasReactions => reactions != null && reactions.Length > 0;
```

---

## UI実装設計

### ボタン方式（文字クリックではなくボタン生成）

リアクション可能なテキストは、**テキスト内のクリック検出ではなく、独立したボタンとして生成**する。

```
【従来案（廃止）】
テキストボックス内の色付き文字をクリック検出
→ TMP_TextUtilities.FindIntersectingLinkで位置判定

【新方式】
リアクションテキストをUnityのButtonとして動的生成
→ Button + TMP_Textの組み合わせ
→ ボタンのテキスト = リアクションセグメントの文字列
→ ボタンの色 = リアクションセグメントの色
```

**利点:**
- クリック判定が確実（Buttonコンポーネントの標準機能）
- 視覚的にインタラクティブだと分かりやすい
- テキストボックス表示中のみボタン表示という制御が容易

### リアクションボタンの表示条件

**TabStateがFieldDialogue/EventDialogueで、かつ選択肢表示中でない場合**にボタンが生成・表示される。

```
【表示条件】
- TabState = FieldDialogue or EventDialogue（NovelChoiceでは非表示）
- DialogueStepにreactionsがある
- 選択肢表示中ではない

【表示タイミング】
1. DialogueStepにreactionsがある
2. そのステップのテキストがEyeAreaのテキストボックスに表示される
3. テキスト表示と同時にリアクションボタンを生成
4. 次のステップに進む or リアクション発火 or 選択肢表示 でボタン削除

【重要】
- リアクションはスルー可能（必須ではない）
- 選択肢（NovelChoice state）表示中はリアクションボタン非表示
- ユーザーは選択肢に集中できる
```

### 共通基底クラス: DynamicButtonPresenterBase

既存のSelectRangeButtons/SelectTargetButtons等と同じパターンを共通化する基底クラス。

```csharp
// Assets/Script/UI/DynamicButtonPresenterBase.cs（新規）
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// 動的ボタン生成の共通基底クラス。
/// SelectRangeButtons/SelectTargetButtons等と同じレイアウトパターンを提供。
/// </summary>
public abstract class DynamicButtonPresenterBase : MonoBehaviour
{
    [SerializeField] protected Button buttonPrefab;
    [SerializeField] protected RectTransform parentRect;

    [Header("Layout Settings")]
    [SerializeField] protected float horizontalPadding = 10f;
    [SerializeField] protected float verticalPadding = 10f;

    protected Vector2 buttonSize;
    protected Vector2 parentSize;
    protected float startX;
    protected float startY;
    protected readonly List<Button> buttonList = new();

    protected virtual void Awake()
    {
        buttonSize = buttonPrefab.GetComponent<RectTransform>().sizeDelta;
        parentSize = parentRect.rect.size;
        startX = -parentSize.x / 2 + buttonSize.x / 2 + horizontalPadding;
        startY = parentSize.y / 2 - buttonSize.y + horizontalPadding;
    }

    /// <summary>
    /// 全ボタンを削除してリストをクリア。
    /// </summary>
    public virtual void ClearAllButtons()
    {
        foreach (var button in buttonList)
        {
            if (button != null) Destroy(button.gameObject);
        }
        buttonList.Clear();
    }

    /// <summary>
    /// ボタンを生成し、レイアウト位置を自動計算して配置。
    /// </summary>
    protected Button CreateButton(string text, ref float currentX, ref float currentY)
    {
        var button = Instantiate(buttonPrefab, transform);
        var rect = button.GetComponent<RectTransform>();

        // 親オブジェクトの右端を超える場合は次の行に移動
        if (currentX + buttonSize.x / 2 > parentSize.x / 2)
        {
            currentX = startX;
            currentY -= buttonSize.y + verticalPadding;
        }

        rect.anchoredPosition = new Vector2(currentX, currentY);
        currentX += buttonSize.x + horizontalPadding;

        button.GetComponentInChildren<TMP_Text>().text = text;
        buttonList.Add(button);
        return button;
    }

    /// <summary>
    /// レイアウト位置をリセット。
    /// </summary>
    protected void ResetLayoutPosition(out float currentX, out float currentY)
    {
        currentX = startX;
        currentY = startY;
    }

    protected virtual void OnDestroy()
    {
        ClearAllButtons();
    }
}
```

### ReactionButtonPresenter

```csharp
// Assets/Script/Walk/Presentation/ReactionButtonPresenter.cs（新規）
using System;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// リアクションボタンの生成・管理。
/// DynamicButtonPresenterBaseを継承し、USERUI側でボタンを動的生成する。
/// </summary>
public sealed class ReactionButtonPresenter : DynamicButtonPresenterBase
{
    private Action<ReactionSegment> onReactionClicked;

    /// <summary>
    /// リアクションボタンを生成する。
    /// </summary>
    public void ShowReactions(ReactionSegment[] reactions, Action<ReactionSegment> callback)
    {
        ClearAllButtons();
        onReactionClicked = callback;

        if (reactions == null || reactions.Length == 0) return;

        ResetLayoutPosition(out var currentX, out var currentY);

        foreach (var segment in reactions)
        {
            var button = CreateButton(segment.Text, ref currentX, ref currentY);

            // テキスト色設定
            var tmpText = button.GetComponentInChildren<TMP_Text>();
            if (tmpText != null)
            {
                tmpText.color = segment.Color;
            }

            // クリックイベント設定
            var capturedSegment = segment;  // クロージャ用
            button.onClick.AddListener(() => OnButtonClicked(capturedSegment));
        }
    }

    public override void ClearAllButtons()
    {
        base.ClearAllButtons();
        onReactionClicked = null;
    }

    private void OnButtonClicked(ReactionSegment segment)
    {
        onReactionClicked?.Invoke(segment);
    }
}
```

### 将来のリファクタ対象

既存のSelectXxxButtonsも同じ基底クラスを継承するようリファクタ可能：

| クラス | 状態 |
|--------|------|
| SelectRangeButtons | 将来リファクタ対象 |
| SelectTargetButtons | 将来リファクタ対象 |
| SelectCancelPassiveButtons | 将来リファクタ対象 |
| SelectEmotionalAttachmentSkillButtons | 将来リファクタ対象 |
| SelectSkillPassiveTargetSkillButtons | 将来リファクタ対象 |
| **ReactionButtonPresenter** | **新規作成時に基底使用** |

### ボタン配置場所

**USERUI側に配置（SelectRangeButtons/SelectTargetButtonsと同じパターン）:**

```
USERUI/ToggleButtons/PlayerContent
├── FieldDialogueObject          ← TabState.FieldDialogue時にactive
│   └── ReactionButtonContainer  ← リアクションボタン動的生成先
├── EventDialogueObject          ← TabState.EventDialogue時にactive
│   └── ReactionButtonContainer  ← リアクションボタン動的生成先
└── NovelChoiceObject            ← TabState.NovelChoice時にactive（リアクション非表示）
    └── ChoiceButtonContainer    ← 選択肢ボタン動的生成先
```

**TabStateとリアクションボタンの関係:**

| TabState | リアクションボタン | 理由 |
|----------|------------------|------|
| FieldDialogue | 表示可能 | スルー可能、タップ領域と共存 |
| EventDialogue | 表示可能 | スルー可能、左右ボタンと共存 |
| NovelChoice | 非表示 | 選択肢に集中させるため |

SelectRangeButtons等と同様に、USERUI側でボタンを動的生成・管理する。

---

## DialogueResultの拡張

リアクション終了を表現するためにDialogueResultを拡張する。

```csharp
// DialogueResult.cs 修正
public struct DialogueResult
{
    public bool Completed { get; set; }  // 全ステップ完了したか
    public int SelectedChoiceIndex { get; set; }
    public string ChangedSpiritProperty { get; set; }

    // リアクション終了用（追加）
    public ReactionSegment TriggeredReaction { get; set; }

    // 判定ヘルパー
    public bool IsReactionEnded => TriggeredReaction != null;
    public bool IsNormalEnded => Completed && TriggeredReaction == null;

    public static DialogueResult FailedResult => new() { Completed = false };
    public static DialogueResult ReactionEndedResult(ReactionSegment reaction) => new()
    {
        Completed = false,
        TriggeredReaction = reaction
    };
}
```

---

## NovelPartDialogueRunnerへの統合

### リアクション終了の処理

```csharp
// NovelPartDialogueRunner.cs 修正

public async UniTask<DialogueResult> RunDialogueAsync(DialogueContext context)
{
    // ... 既存の初期化処理 ...

    var steps = context.GetSteps();
    var currentIndex = 0;

    while (currentIndex < steps.Length)
    {
        var step = steps[currentIndex];
        if (step == null)
        {
            currentIndex++;
            continue;
        }

        // リアクションボタンの表示（テキスト表示と同時）
        if (step.HasReactions)
        {
            ui.ShowReactionButtons(step.Reactions, OnReactionClicked);
        }

        reactionTriggered = null;
        var stepResult = await ExecuteStep(step, context, currentIndex);

        // リアクションボタンがクリックされた場合 → リアクション終了
        if (reactionTriggered != null)
        {
            // ノベルパートを閉じる（終了）
            ui.ClearReactionButtons();
            await ui.HideAll();

            // リアクション情報を含めて終了を返す
            return DialogueResult.ReactionEndedResult(reactionTriggered);
        }

        // 次のステップに進む前にボタンをクリア
        ui.ClearReactionButtons();

        // ... 既存の戻る/バックログ処理 ...

        previousStep = step;
        currentIndex++;
    }

    // 通常終了
    ui.SetBackButtonEnabled(false);
    return new DialogueResult { Completed = true };
}

private ReactionSegment reactionTriggered;

private void OnReactionClicked(ReactionSegment segment)
{
    reactionTriggered = segment;
}
```

### 呼び出し元（AreaController等）での処理

```csharp
// 強制イベント等からの呼び出し例
var dialogueResult = await context.DialogueRunner.RunDialogueAsync(dialogueContext);

// リアクション終了をチェック
if (dialogueResult.IsReactionEnded)
{
    var reaction = dialogueResult.TriggeredReaction;

    switch (reaction.Type)
    {
        case ReactionType.Battle:
            // 戦闘起動（既存のRunEncounterと同じパターン）
            var battleResult = await RunEncounter(reaction.Encounter);
            await HandleEncounterOutcome(reaction.Encounter, battleResult.Outcome, ...);
            break;

        // 将来の拡張
        // case ReactionType.Event:
        //     await eventHost.RunEvent(reaction.Event);
        //     break;
    }
}
else if (dialogueResult.IsNormalEnded)
{
    // 通常終了の処理
}
```

---

## INovelEventUIへの追加

```csharp
// INovelEventUI.cs に追加

/// <summary>
/// リアクションボタンを表示する。
/// EyeAreaのテキストボックス表示中のみ有効。
/// </summary>
/// <param name="reactions">リアクションセグメント配列</param>
/// <param name="onClicked">ボタンクリック時コールバック</param>
void ShowReactionButtons(ReactionSegment[] reactions, System.Action<ReactionSegment> onClicked);

/// <summary>
/// リアクションボタンをクリアする。
/// </summary>
void ClearReactionButtons();

/// <summary>
/// 全UI要素を非表示にする（リアクション終了時）。
/// </summary>
UniTask HideAll();
```

### NovelPartEventUI既存メソッド

`HideAll()`は既に実装済み（`NovelPartEventUI.cs:301-307`）:
```csharp
public void HideAll()
{
    portraitPresenter?.ClearAll();
    backgroundPresenter?.HideImmediate();
    noisePresenter?.ClearAll();
    textBoxPresenter?.Hide();
    reactionButtonPresenter?.ClearButtons();  // 追加
}
```

---

## 実装フェーズ

### Phase R1: データ構造

| タスク | 状態 |
|--------|------|
| ReactionSegment定義 | ✅ |
| ReactionType enum定義 | ✅ |
| DialogueStep.reactions追加 | ✅ |
| DialogueResult拡張（TriggeredReaction追加） | ✅ |

### Phase R2: ボタンUI

| タスク | 状態 |
|--------|------|
| ReactionButtonPresenter実装 | ⬜ |
| reactionButtonPrefab作成 | ⬜ |
| ボタンレイアウト調整 | ⬜ |

### Phase R3: ボタン統合

| タスク | 状態 |
|--------|------|
| INovelEventUI.ShowReactionButtons追加 | ⬜ |
| NovelPartEventUI リアクションボタン対応 | ⬜ |
| テキストボックス表示時のボタン生成 | ⬜ |

### Phase R4: NovelPartDialogueRunner統合

| タスク | 状態 |
|--------|------|
| INovelEventUI.SetReactionText/ClearReactions追加 | ✅ |
| NovelPartEventUI リアクション対応 | ✅ |
| NovelPartDialogueRunner リアクション終了処理 | ✅ |

### Phase R5: 呼び出し元統合

| タスク | 状態 |
|--------|------|
| AreaController リアクション終了ハンドリング | ✅ |
| 戦闘起動（既存RunEncounterパターン流用） | ✅ |
| 戦闘結果処理（既存HandleEncounterOutcome流用） | ✅ |

### Phase R6: 結合テスト

| タスク | 状態 |
|--------|------|
| オレンジ文字での戦闘起動テスト | ⬜ |
| 複数リアクション同時表示テスト | ⬜ |
| ノベルパート終了 → 戦闘 → 歩行継続テスト | ⬜ |

---

## ファイル構成

```
Assets/Script/
├── UI/
│   └── DynamicButtonPresenterBase.cs（新規：動的ボタン生成の共通基底）
│
├── Walk/
│   ├── Dialogue/
│   │   ├── DialogueStep.cs           （修正：reactions追加）
│   │   ├── DialogueResult.cs         （修正：TriggeredReaction追加）
│   │   ├── ReactionSegment.cs        （新規）
│   │   └── NovelPartDialogueRunner.cs（修正：リアクション終了処理）
│   │
│   ├── Presentation/
│   │   └── ReactionButtonPresenter.cs（新規：DynamicButtonPresenterBase継承）
│   │
│   ├── EventKernel/
│   │   ├── INovelEventUI.cs          （修正：ShowReactionButtons/ClearReactionButtons追加）
│   │   └── NovelPartEventUI.cs       （修正：リアクションボタン対応）
│   │
│   └── AreaController.cs             （修正：リアクション終了ハンドリング）

Assets/Prefabs/
└── ReactionButtonPrefab.prefab   （新規：Button + TMP_Text）
```

---

## テスト計画

### 正常系

- [ ] オレンジ色テキストが正しく表示される
- [ ] クリックでノベルパートが終了する
- [ ] ノベルパート終了後に戦闘が起動する
- [ ] 戦闘終了後に歩行システムに正しく戻る
- [ ] 1セリフに複数リアクションがある場合、各々が独立して動作

### 異常系

- [ ] Encounter未設定のリアクションをクリック → 警告ログ、通常進行
- [ ] BattleRunner未設定時 → 警告ログ、通常終了
- [ ] リアクション外のテキストクリック → 通常進行

### エッジケース

- [ ] リアクションテキストが重複する位置にある場合
- [ ] リアクションテキストが改行をまたぐ場合
- [ ] 全文がリアクションテキストの場合
- [ ] 最初のステップでリアクション終了した場合

---

## 将来拡張

### 他のリアクションタイプ

```csharp
public enum ReactionType
{
    Battle,     // 戦闘起動（実装済み）
    Event,      // EventDefinitionSO発火
    Inference,  // 推理パート
    Custom      // カスタム処理（delegate）
}
```

### 色マッピングの外部化

将来的にはSOでマッピングを定義できるようにする。

```csharp
[CreateAssetMenu(menuName = "Walk/Reaction Color Mapping")]
public class ReactionColorMappingSO : ScriptableObject
{
    [Serializable]
    public class ColorMapping
    {
        public Color color;
        public ReactionType type;
    }

    [SerializeField] private ColorMapping[] mappings;
}
```

---

## 備考

- リアクションはあくまでオプション機能（reactions=nullでも通常動作）
- **リアクション発火時はノベルパートを「終了」する（中断ではない）**
- ノベルパートへの再開はしない。終了後は呼び出し元がイベントを実行し、歩行に戻る
- UI配置の詳細は [ノベルパート_USERUIとEyeArea連携.md](./ノベルパート_USERUIとEyeArea連携.md) を参照

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-24 | 初版（TextMeshProリンク方式） |
| 2026-01-24 | UI方式変更: テキストクリックからボタン生成方式に変更 |
| 2026-01-24 | TabState.NovelChoice追加、リアクションボタンの表示条件明確化（選択肢中は非表示） |
